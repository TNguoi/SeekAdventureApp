{"ast":null,"code":"import { parseToRgb, toColorString, parseToHsl, hslToColorString, setLightness, getLuminance } from \"polished\";\nimport { parse } from \"gradient-parser\";\nimport { responsiveStyle } from \"../css/responsiveStyle.mjs\";\nconst getLinearGradientColors = color => {\n  const gradients = parse(color);\n  return gradients[0].colorStops.map(({\n    type,\n    value\n  }) => {\n    if (typeof value !== \"string\") {\n      throw new Error(\"Gradient parsing in Braid currently only supports hex/literal values\");\n    }\n    return `${type === \"hex\" ? \"#\" : \"\"}${value}`;\n  });\n};\nconst calculateYiq = color => {\n  const {\n    red,\n    green,\n    blue\n  } = parseToRgb(color);\n  return (red * 299 + green * 587 + blue * 114) / 1e3;\n};\nconst isLight = (inputColor, foregroundColor = \"#000\") => {\n  const colors = /^linear-gradient/.test(inputColor) ? getLinearGradientColors(inputColor) : [inputColor];\n  const foregroundYiq = calculateYiq(foregroundColor);\n  return colors.some(color => {\n    const yiq = calculateYiq(color);\n    const midpoint = 256 / 2;\n    const foregroundOffset = foregroundYiq / 2;\n    return yiq >= midpoint + foregroundOffset;\n  });\n};\nconst AA_TEXT_CONTRAST = 4.52;\nfunction contrast(color1, color2) {\n  const L1 = getLuminance(color1) + 0.05;\n  const L2 = getLuminance(color2) + 0.05;\n  return L1 < L2 ? L2 / L1 : L1 / L2;\n}\nfunction findClosestAccessibleLighterColor(inputColor, fixedColor, contrastRatio = AA_TEXT_CONTRAST) {\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const {\n    hue,\n    saturation,\n    lightness\n  } = parseToHsl(normalisedInput);\n  let minLightness = lightness;\n  let maxLightness = 0.98;\n  let maxColor = hslToColorString({\n    hue,\n    saturation,\n    lightness: maxLightness\n  });\n  let minColor = hslToColorString({\n    hue,\n    saturation,\n    lightness\n  });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(`Desired contrast ratio cannot be achieved,\nForeground: ${inputColor}\nBackground:${fixedColor}\nDesired Contrast:${contrastRatio}\nActual Contrast:${actualRatio}`);\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    } else {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    }\n  }\n  return maxColor;\n}\nfunction findClosestAccessibleDarkerColor(inputColor, fixedColor, contrastRatio = AA_TEXT_CONTRAST) {\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const {\n    hue,\n    saturation,\n    lightness\n  } = parseToHsl(normalisedInput);\n  let minLightness = 0.02;\n  let maxLightness = lightness;\n  let maxColor = hslToColorString({\n    hue,\n    saturation,\n    lightness: minLightness\n  });\n  let minColor = hslToColorString({\n    hue,\n    saturation,\n    lightness\n  });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(`Desired contrast ratio cannot be achieved,\nForeground: ${inputColor}\nBackground:${fixedColor}\nDesired Contrast:${contrastRatio}\nActual Contrast:${actualRatio}`);\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    } else {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    }\n  }\n  return minColor;\n}\nconst smoothSaturation = (saturation, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return saturation * 0.8;\n  }\n  return saturation * 0.45;\n};\nconst smoothLightness = (lightness, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return 0.95 - lightness * 0.03;\n  }\n  return 0.95 - lightness * 0.06;\n};\nfunction getLightVariant(color) {\n  const {\n    hue,\n    saturation,\n    lightness\n  } = parseToHsl(color);\n  const luminance = getLuminance(color);\n  return toColorString({\n    hue,\n    saturation: smoothSaturation(saturation, luminance),\n    lightness: smoothLightness(lightness, luminance)\n  });\n}\nfunction getAccessibleVariant(color, background) {\n  return findClosestAccessibleDarkerColor(color, background ?? getLightVariant(color), AA_TEXT_CONTRAST);\n}\nconst mapToProperty = (property, breakpoint) => value => {\n  const styleRule = {\n    [property]: value\n  };\n  return breakpoint ? responsiveStyle({\n    [breakpoint]: styleRule\n  }) : styleRule;\n};\nexport { findClosestAccessibleLighterColor, getAccessibleVariant, getLightVariant, isLight, mapToProperty };","map":{"version":3,"names":["parseToRgb","toColorString","parseToHsl","hslToColorString","setLightness","getLuminance","parse","responsiveStyle","getLinearGradientColors","color","gradients","colorStops","map","type","value","Error","calculateYiq","red","green","blue","isLight","inputColor","foregroundColor","colors","test","foregroundYiq","some","yiq","midpoint","foregroundOffset","AA_TEXT_CONTRAST","contrast","color1","color2","L1","L2","findClosestAccessibleLighterColor","fixedColor","contrastRatio","normalisedInput","normalisedFixed","hue","saturation","lightness","minLightness","maxLightness","maxColor","minColor","actualRatio","lastMinColor","lastMaxColor","adjustedLightness","adjustedColor","findClosestAccessibleDarkerColor","smoothSaturation","luminance","isBright","smoothLightness","getLightVariant","getAccessibleVariant","background","mapToProperty","property","breakpoint","styleRule"],"sources":["/Users/tnguoi/Desktop/SeekAdventureApp/client/node_modules/braid-design-system/dist/styles/lib/utils/index.mjs"],"sourcesContent":["import { parseToRgb, toColorString, parseToHsl, hslToColorString, setLightness, getLuminance } from \"polished\";\nimport { parse } from \"gradient-parser\";\nimport { responsiveStyle } from \"../css/responsiveStyle.mjs\";\nconst getLinearGradientColors = (color) => {\n  const gradients = parse(color);\n  return gradients[0].colorStops.map(({ type, value }) => {\n    if (typeof value !== \"string\") {\n      throw new Error(\n        \"Gradient parsing in Braid currently only supports hex/literal values\"\n      );\n    }\n    return `${type === \"hex\" ? \"#\" : \"\"}${value}`;\n  });\n};\nconst calculateYiq = (color) => {\n  const { red, green, blue } = parseToRgb(color);\n  return (red * 299 + green * 587 + blue * 114) / 1e3;\n};\nconst isLight = (inputColor, foregroundColor = \"#000\") => {\n  const colors = /^linear-gradient/.test(inputColor) ? getLinearGradientColors(inputColor) : [inputColor];\n  const foregroundYiq = calculateYiq(foregroundColor);\n  return colors.some((color) => {\n    const yiq = calculateYiq(color);\n    const midpoint = 256 / 2;\n    const foregroundOffset = foregroundYiq / 2;\n    return yiq >= midpoint + foregroundOffset;\n  });\n};\nconst AA_TEXT_CONTRAST = 4.52;\nfunction contrast(color1, color2) {\n  const L1 = getLuminance(color1) + 0.05;\n  const L2 = getLuminance(color2) + 0.05;\n  return L1 < L2 ? L2 / L1 : L1 / L2;\n}\nfunction findClosestAccessibleLighterColor(inputColor, fixedColor, contrastRatio = AA_TEXT_CONTRAST) {\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const { hue, saturation, lightness } = parseToHsl(normalisedInput);\n  let minLightness = lightness;\n  let maxLightness = 0.98;\n  let maxColor = hslToColorString({ hue, saturation, lightness: maxLightness });\n  let minColor = hslToColorString({ hue, saturation, lightness });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(\n      `Desired contrast ratio cannot be achieved,\nForeground: ${inputColor}\nBackground:${fixedColor}\nDesired Contrast:${contrastRatio}\nActual Contrast:${actualRatio}`\n    );\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    } else {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    }\n  }\n  return maxColor;\n}\nfunction findClosestAccessibleDarkerColor(inputColor, fixedColor, contrastRatio = AA_TEXT_CONTRAST) {\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const { hue, saturation, lightness } = parseToHsl(normalisedInput);\n  let minLightness = 0.02;\n  let maxLightness = lightness;\n  let maxColor = hslToColorString({ hue, saturation, lightness: minLightness });\n  let minColor = hslToColorString({ hue, saturation, lightness });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(\n      `Desired contrast ratio cannot be achieved,\nForeground: ${inputColor}\nBackground:${fixedColor}\nDesired Contrast:${contrastRatio}\nActual Contrast:${actualRatio}`\n    );\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    } else {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    }\n  }\n  return minColor;\n}\nconst smoothSaturation = (saturation, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return saturation * 0.8;\n  }\n  return saturation * 0.45;\n};\nconst smoothLightness = (lightness, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return 0.95 - lightness * 0.03;\n  }\n  return 0.95 - lightness * 0.06;\n};\nfunction getLightVariant(color) {\n  const { hue, saturation, lightness } = parseToHsl(color);\n  const luminance = getLuminance(color);\n  return toColorString({\n    hue,\n    saturation: smoothSaturation(saturation, luminance),\n    lightness: smoothLightness(lightness, luminance)\n  });\n}\nfunction getAccessibleVariant(color, background) {\n  return findClosestAccessibleDarkerColor(\n    color,\n    background ?? getLightVariant(color),\n    AA_TEXT_CONTRAST\n  );\n}\nconst mapToProperty = (property, breakpoint) => (value) => {\n  const styleRule = { [property]: value };\n  return breakpoint ? responsiveStyle({ [breakpoint]: styleRule }) : styleRule;\n};\nexport {\n  findClosestAccessibleLighterColor,\n  getAccessibleVariant,\n  getLightVariant,\n  isLight,\n  mapToProperty\n};\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,aAAa,EAAEC,UAAU,EAAEC,gBAAgB,EAAEC,YAAY,EAAEC,YAAY,QAAQ,UAAU;AAC9G,SAASC,KAAK,QAAQ,iBAAiB;AACvC,SAASC,eAAe,QAAQ,4BAA4B;AAC5D,MAAMC,uBAAuB,GAAIC,KAAK,IAAK;EACzC,MAAMC,SAAS,GAAGJ,KAAK,CAACG,KAAK,CAAC;EAC9B,OAAOC,SAAS,CAAC,CAAC,CAAC,CAACC,UAAU,CAACC,GAAG,CAAC,CAAC;IAAEC,IAAI;IAAEC;EAAM,CAAC,KAAK;IACtD,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,MAAM,IAAIC,KAAK,CACb,sEACF,CAAC;IACH;IACA,OAAQ,GAAEF,IAAI,KAAK,KAAK,GAAG,GAAG,GAAG,EAAG,GAAEC,KAAM,EAAC;EAC/C,CAAC,CAAC;AACJ,CAAC;AACD,MAAME,YAAY,GAAIP,KAAK,IAAK;EAC9B,MAAM;IAAEQ,GAAG;IAAEC,KAAK;IAAEC;EAAK,CAAC,GAAGnB,UAAU,CAACS,KAAK,CAAC;EAC9C,OAAO,CAACQ,GAAG,GAAG,GAAG,GAAGC,KAAK,GAAG,GAAG,GAAGC,IAAI,GAAG,GAAG,IAAI,GAAG;AACrD,CAAC;AACD,MAAMC,OAAO,GAAGA,CAACC,UAAU,EAAEC,eAAe,GAAG,MAAM,KAAK;EACxD,MAAMC,MAAM,GAAG,kBAAkB,CAACC,IAAI,CAACH,UAAU,CAAC,GAAGb,uBAAuB,CAACa,UAAU,CAAC,GAAG,CAACA,UAAU,CAAC;EACvG,MAAMI,aAAa,GAAGT,YAAY,CAACM,eAAe,CAAC;EACnD,OAAOC,MAAM,CAACG,IAAI,CAAEjB,KAAK,IAAK;IAC5B,MAAMkB,GAAG,GAAGX,YAAY,CAACP,KAAK,CAAC;IAC/B,MAAMmB,QAAQ,GAAG,GAAG,GAAG,CAAC;IACxB,MAAMC,gBAAgB,GAAGJ,aAAa,GAAG,CAAC;IAC1C,OAAOE,GAAG,IAAIC,QAAQ,GAAGC,gBAAgB;EAC3C,CAAC,CAAC;AACJ,CAAC;AACD,MAAMC,gBAAgB,GAAG,IAAI;AAC7B,SAASC,QAAQA,CAACC,MAAM,EAAEC,MAAM,EAAE;EAChC,MAAMC,EAAE,GAAG7B,YAAY,CAAC2B,MAAM,CAAC,GAAG,IAAI;EACtC,MAAMG,EAAE,GAAG9B,YAAY,CAAC4B,MAAM,CAAC,GAAG,IAAI;EACtC,OAAOC,EAAE,GAAGC,EAAE,GAAGA,EAAE,GAAGD,EAAE,GAAGA,EAAE,GAAGC,EAAE;AACpC;AACA,SAASC,iCAAiCA,CAACf,UAAU,EAAEgB,UAAU,EAAEC,aAAa,GAAGR,gBAAgB,EAAE;EACnG,MAAMS,eAAe,GAAGtC,aAAa,CAACD,UAAU,CAACqB,UAAU,CAAC,CAAC;EAC7D,MAAMmB,eAAe,GAAGvC,aAAa,CAACD,UAAU,CAACqC,UAAU,CAAC,CAAC;EAC7D,MAAM;IAAEI,GAAG;IAAEC,UAAU;IAAEC;EAAU,CAAC,GAAGzC,UAAU,CAACqC,eAAe,CAAC;EAClE,IAAIK,YAAY,GAAGD,SAAS;EAC5B,IAAIE,YAAY,GAAG,IAAI;EACvB,IAAIC,QAAQ,GAAG3C,gBAAgB,CAAC;IAAEsC,GAAG;IAAEC,UAAU;IAAEC,SAAS,EAAEE;EAAa,CAAC,CAAC;EAC7E,IAAIE,QAAQ,GAAG5C,gBAAgB,CAAC;IAAEsC,GAAG;IAAEC,UAAU;IAAEC;EAAU,CAAC,CAAC;EAC/D,IAAIZ,QAAQ,CAACQ,eAAe,EAAEC,eAAe,CAAC,IAAIF,aAAa,EAAE;IAC/D,OAAOjB,UAAU;EACnB;EACA,MAAM2B,WAAW,GAAGjB,QAAQ,CAACe,QAAQ,EAAEN,eAAe,CAAC;EACvD,IAAIQ,WAAW,GAAGV,aAAa,EAAE;IAC/B,MAAM,IAAIvB,KAAK,CACZ;AACP,cAAcM,UAAW;AACzB,aAAagB,UAAW;AACxB,mBAAmBC,aAAc;AACjC,kBAAkBU,WAAY,EAC1B,CAAC;EACH;EACA,IAAIC,YAAY;EAChB,IAAIC,YAAY;EAChB,IAAIC,iBAAiB;EACrB,IAAIC,aAAa,GAAGb,eAAe;EACnC,OAAOQ,QAAQ,KAAKE,YAAY,IAAIH,QAAQ,KAAKI,YAAY,EAAE;IAC7DD,YAAY,GAAGF,QAAQ;IACvBG,YAAY,GAAGJ,QAAQ;IACvBK,iBAAiB,GAAG,CAACP,YAAY,GAAGC,YAAY,IAAI,CAAC;IACrDO,aAAa,GAAGhD,YAAY,CAAC+C,iBAAiB,EAAEC,aAAa,CAAC;IAC9D,IAAIrB,QAAQ,CAACqB,aAAa,EAAEZ,eAAe,CAAC,GAAGF,aAAa,EAAE;MAC5DM,YAAY,GAAGO,iBAAiB;MAChCJ,QAAQ,GAAGK,aAAa;IAC1B,CAAC,MAAM;MACLP,YAAY,GAAGM,iBAAiB;MAChCL,QAAQ,GAAGM,aAAa;IAC1B;EACF;EACA,OAAON,QAAQ;AACjB;AACA,SAASO,gCAAgCA,CAAChC,UAAU,EAAEgB,UAAU,EAAEC,aAAa,GAAGR,gBAAgB,EAAE;EAClG,MAAMS,eAAe,GAAGtC,aAAa,CAACD,UAAU,CAACqB,UAAU,CAAC,CAAC;EAC7D,MAAMmB,eAAe,GAAGvC,aAAa,CAACD,UAAU,CAACqC,UAAU,CAAC,CAAC;EAC7D,MAAM;IAAEI,GAAG;IAAEC,UAAU;IAAEC;EAAU,CAAC,GAAGzC,UAAU,CAACqC,eAAe,CAAC;EAClE,IAAIK,YAAY,GAAG,IAAI;EACvB,IAAIC,YAAY,GAAGF,SAAS;EAC5B,IAAIG,QAAQ,GAAG3C,gBAAgB,CAAC;IAAEsC,GAAG;IAAEC,UAAU;IAAEC,SAAS,EAAEC;EAAa,CAAC,CAAC;EAC7E,IAAIG,QAAQ,GAAG5C,gBAAgB,CAAC;IAAEsC,GAAG;IAAEC,UAAU;IAAEC;EAAU,CAAC,CAAC;EAC/D,IAAIZ,QAAQ,CAACQ,eAAe,EAAEC,eAAe,CAAC,IAAIF,aAAa,EAAE;IAC/D,OAAOjB,UAAU;EACnB;EACA,MAAM2B,WAAW,GAAGjB,QAAQ,CAACe,QAAQ,EAAEN,eAAe,CAAC;EACvD,IAAIQ,WAAW,GAAGV,aAAa,EAAE;IAC/B,MAAM,IAAIvB,KAAK,CACZ;AACP,cAAcM,UAAW;AACzB,aAAagB,UAAW;AACxB,mBAAmBC,aAAc;AACjC,kBAAkBU,WAAY,EAC1B,CAAC;EACH;EACA,IAAIC,YAAY;EAChB,IAAIC,YAAY;EAChB,IAAIC,iBAAiB;EACrB,IAAIC,aAAa,GAAGb,eAAe;EACnC,OAAOQ,QAAQ,KAAKE,YAAY,IAAIH,QAAQ,KAAKI,YAAY,EAAE;IAC7DD,YAAY,GAAGF,QAAQ;IACvBG,YAAY,GAAGJ,QAAQ;IACvBK,iBAAiB,GAAG,CAACP,YAAY,GAAGC,YAAY,IAAI,CAAC;IACrDO,aAAa,GAAGhD,YAAY,CAAC+C,iBAAiB,EAAEC,aAAa,CAAC;IAC9D,IAAIrB,QAAQ,CAACqB,aAAa,EAAEZ,eAAe,CAAC,GAAGF,aAAa,EAAE;MAC5DO,YAAY,GAAGM,iBAAiB;MAChCL,QAAQ,GAAGM,aAAa;IAC1B,CAAC,MAAM;MACLR,YAAY,GAAGO,iBAAiB;MAChCJ,QAAQ,GAAGK,aAAa;IAC1B;EACF;EACA,OAAOL,QAAQ;AACjB;AACA,MAAMO,gBAAgB,GAAGA,CAACZ,UAAU,EAAEa,SAAS,KAAK;EAClD,MAAMC,QAAQ,GAAGD,SAAS,GAAG,GAAG;EAChC,IAAIC,QAAQ,EAAE;IACZ,OAAOd,UAAU,GAAG,GAAG;EACzB;EACA,OAAOA,UAAU,GAAG,IAAI;AAC1B,CAAC;AACD,MAAMe,eAAe,GAAGA,CAACd,SAAS,EAAEY,SAAS,KAAK;EAChD,MAAMC,QAAQ,GAAGD,SAAS,GAAG,GAAG;EAChC,IAAIC,QAAQ,EAAE;IACZ,OAAO,IAAI,GAAGb,SAAS,GAAG,IAAI;EAChC;EACA,OAAO,IAAI,GAAGA,SAAS,GAAG,IAAI;AAChC,CAAC;AACD,SAASe,eAAeA,CAACjD,KAAK,EAAE;EAC9B,MAAM;IAAEgC,GAAG;IAAEC,UAAU;IAAEC;EAAU,CAAC,GAAGzC,UAAU,CAACO,KAAK,CAAC;EACxD,MAAM8C,SAAS,GAAGlD,YAAY,CAACI,KAAK,CAAC;EACrC,OAAOR,aAAa,CAAC;IACnBwC,GAAG;IACHC,UAAU,EAAEY,gBAAgB,CAACZ,UAAU,EAAEa,SAAS,CAAC;IACnDZ,SAAS,EAAEc,eAAe,CAACd,SAAS,EAAEY,SAAS;EACjD,CAAC,CAAC;AACJ;AACA,SAASI,oBAAoBA,CAAClD,KAAK,EAAEmD,UAAU,EAAE;EAC/C,OAAOP,gCAAgC,CACrC5C,KAAK,EACLmD,UAAU,IAAIF,eAAe,CAACjD,KAAK,CAAC,EACpCqB,gBACF,CAAC;AACH;AACA,MAAM+B,aAAa,GAAGA,CAACC,QAAQ,EAAEC,UAAU,KAAMjD,KAAK,IAAK;EACzD,MAAMkD,SAAS,GAAG;IAAE,CAACF,QAAQ,GAAGhD;EAAM,CAAC;EACvC,OAAOiD,UAAU,GAAGxD,eAAe,CAAC;IAAE,CAACwD,UAAU,GAAGC;EAAU,CAAC,CAAC,GAAGA,SAAS;AAC9E,CAAC;AACD,SACE5B,iCAAiC,EACjCuB,oBAAoB,EACpBD,eAAe,EACftC,OAAO,EACPyC,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}