{"ast":null,"code":"// In the absence of a WeakSet or WeakMap implementation, don't break, but don't cache either.\nfunction noop() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n}\nfunction createWeakMap() {\n  if (typeof WeakMap !== \"undefined\") {\n    return new WeakMap();\n  } else {\n    return fakeSetOrMap();\n  }\n}\n/**\n * Creates and returns a no-op implementation of a WeakMap / WeakSet that never stores anything.\n */\nfunction fakeSetOrMap() {\n  return {\n    add: noop,\n    delete: noop,\n    get: noop,\n    set: noop,\n    has: function (k) {\n      return false;\n    }\n  };\n}\n// Safe hasOwnProperty\nvar hop = Object.prototype.hasOwnProperty;\nvar has = function (obj, prop) {\n  return hop.call(obj, prop);\n};\n// Copy all own enumerable properties from source to target\nfunction extend(target, source) {\n  for (var prop in source) {\n    if (has(source, prop)) {\n      target[prop] = source[prop];\n    }\n  }\n  return target;\n}\nvar reLeadingNewline = /^[ \\t]*(?:\\r\\n|\\r|\\n)/;\nvar reTrailingNewline = /(?:\\r\\n|\\r|\\n)[ \\t]*$/;\nvar reStartsWithNewlineOrIsEmpty = /^(?:[\\r\\n]|$)/;\nvar reDetectIndentation = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/;\nvar reOnlyWhitespaceWithAtLeastOneNewline = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\nfunction _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options) {\n  // If first interpolated value is a reference to outdent,\n  // determine indentation level from the indentation of the interpolated value.\n  var indentationLevel = 0;\n  var match = strings[0].match(reDetectIndentation);\n  if (match) {\n    indentationLevel = match[1].length;\n  }\n  var reSource = \"(\\\\r\\\\n|\\\\r|\\\\n).{0,\" + indentationLevel + \"}\";\n  var reMatchIndent = new RegExp(reSource, \"g\");\n  if (firstInterpolatedValueSetsIndentationLevel) {\n    strings = strings.slice(1);\n  }\n  var newline = options.newline,\n    trimLeadingNewline = options.trimLeadingNewline,\n    trimTrailingNewline = options.trimTrailingNewline;\n  var normalizeNewlines = typeof newline === \"string\";\n  var l = strings.length;\n  var outdentedStrings = strings.map(function (v, i) {\n    // Remove leading indentation from all lines\n    v = v.replace(reMatchIndent, \"$1\");\n    // Trim a leading newline from the first string\n    if (i === 0 && trimLeadingNewline) {\n      v = v.replace(reLeadingNewline, \"\");\n    }\n    // Trim a trailing newline from the last string\n    if (i === l - 1 && trimTrailingNewline) {\n      v = v.replace(reTrailingNewline, \"\");\n    }\n    // Normalize newlines\n    if (normalizeNewlines) {\n      v = v.replace(/\\r\\n|\\n|\\r/g, function (_) {\n        return newline;\n      });\n    }\n    return v;\n  });\n  return outdentedStrings;\n}\nfunction concatStringsAndValues(strings, values) {\n  var ret = \"\";\n  for (var i = 0, l = strings.length; i < l; i++) {\n    ret += strings[i];\n    if (i < l - 1) {\n      ret += values[i];\n    }\n  }\n  return ret;\n}\nfunction isTemplateStringsArray(v) {\n  return has(v, \"raw\") && has(v, \"length\");\n}\n/**\n * It is assumed that opts will not change.  If this is a problem, clone your options object and pass the clone to\n * makeInstance\n * @param options\n * @return {outdent}\n */\nfunction createInstance(options) {\n  /** Cache of pre-processed template literal arrays */\n  var arrayAutoIndentCache = createWeakMap();\n  /**\n     * Cache of pre-processed template literal arrays, where first interpolated value is a reference to outdent,\n     * before interpolated values are injected.\n     */\n  var arrayFirstInterpSetsIndentCache = createWeakMap();\n  function outdent(stringsOrOptions) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      values[_i - 1] = arguments[_i];\n    }\n    /* tslint:enable:no-shadowed-variable */\n    if (isTemplateStringsArray(stringsOrOptions)) {\n      var strings = stringsOrOptions;\n      // Is first interpolated value a reference to outdent, alone on its own line, without any preceding non-whitespace?\n      var firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1]);\n      // Perform outdentation\n      var cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;\n      var renderedArray = cache.get(strings);\n      if (!renderedArray) {\n        renderedArray = _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options);\n        cache.set(strings, renderedArray);\n      }\n      /** If no interpolated values, skip concatenation step */\n      if (values.length === 0) {\n        return renderedArray[0];\n      }\n      /** Concatenate string literals with interpolated values */\n      var rendered = concatStringsAndValues(renderedArray, firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values);\n      return rendered;\n    } else {\n      // Create and return a new instance of outdent with the given options\n      return createInstance(extend(extend({}, options), stringsOrOptions || {}));\n    }\n  }\n  var fullOutdent = extend(outdent, {\n    string: function (str) {\n      return _outdentArray([str], false, options)[0];\n    }\n  });\n  return fullOutdent;\n}\nvar defaultOutdent = createInstance({\n  trimLeadingNewline: true,\n  trimTrailingNewline: true\n});\n// Named exports.  Simple and preferred.\n// import outdent from 'outdent';\nexport default defaultOutdent;\n// import {outdent} from 'outdent';\nexport { defaultOutdent as outdent };\nif (typeof module !== \"undefined\") {\n  // In webpack harmony-modules environments, module.exports is read-only,\n  // so we fail gracefully.\n  try {\n    module.exports = defaultOutdent;\n    Object.defineProperty(defaultOutdent, \"__esModule\", {\n      value: true\n    });\n    defaultOutdent.default = defaultOutdent;\n    defaultOutdent.outdent = defaultOutdent;\n  } catch (e) {}\n}","map":{"version":3,"names":["noop","args","_i","arguments","length","createWeakMap","WeakMap","fakeSetOrMap","add","delete","get","set","has","k","hop","Object","prototype","hasOwnProperty","obj","prop","call","extend","target","source","reLeadingNewline","reTrailingNewline","reStartsWithNewlineOrIsEmpty","reDetectIndentation","reOnlyWhitespaceWithAtLeastOneNewline","_outdentArray","strings","firstInterpolatedValueSetsIndentationLevel","options","indentationLevel","match","reSource","reMatchIndent","RegExp","slice","newline","trimLeadingNewline","trimTrailingNewline","normalizeNewlines","l","outdentedStrings","map","v","i","replace","_","concatStringsAndValues","values","ret","isTemplateStringsArray","createInstance","arrayAutoIndentCache","arrayFirstInterpSetsIndentCache","outdent","stringsOrOptions","defaultOutdent","test","cache","renderedArray","rendered","fullOutdent","string","str","module","exports","defineProperty","value","default","e"],"sources":["/Users/tnguoi/Desktop/SeekAdventureApp/client/node_modules/outdent/src/index.ts"],"sourcesContent":["type TODO = any;\n\n// In the absence of a WeakSet or WeakMap implementation, don't break, but don't cache either.\nfunction noop(...args: Array<any>) {}\nfunction createWeakMap<K extends object, V>(): MyWeakMap<K, V> {\n  if (typeof WeakMap !== \"undefined\") {\n    return new WeakMap<K, V>();\n  } else {\n    return fakeSetOrMap<K, V>();\n  }\n}\n\ntype MyWeakMap<K extends object, V> = Pick<\n  WeakMap<K, V>,\n  \"delete\" | \"get\" | \"set\" | \"has\"\n>;\ntype MyWeakSetMap<K extends object, V> =\n  & Pick<WeakMap<K, V>, \"delete\" | \"get\" | \"set\" | \"has\">\n  & Pick<WeakSet<K>, \"add\">;\n\n/**\n * Creates and returns a no-op implementation of a WeakMap / WeakSet that never stores anything.\n */\nfunction fakeSetOrMap<K extends object, V = any>(): MyWeakSetMap<K, V> {\n  return {\n    add: noop as WeakSet<K>[\"add\"],\n    delete: noop as WeakMap<K, V>[\"delete\"],\n    get: noop as WeakMap<K, V>[\"get\"],\n    set: noop as WeakMap<K, V>[\"set\"],\n    has(k: K) {\n      return false;\n    },\n  };\n}\n\n// Safe hasOwnProperty\nconst hop = Object.prototype.hasOwnProperty;\nconst has = function (obj: object, prop: string): boolean {\n  return hop.call(obj, prop);\n};\n\n// Copy all own enumerable properties from source to target\nfunction extend<T, S extends object>(target: T, source: S) {\n  type Extended = T & S;\n  for (const prop in source) {\n    if (has(source, prop)) {\n      (target as any)[prop] = source[prop];\n    }\n  }\n  return target as Extended;\n}\n\nconst reLeadingNewline = /^[ \\t]*(?:\\r\\n|\\r|\\n)/;\nconst reTrailingNewline = /(?:\\r\\n|\\r|\\n)[ \\t]*$/;\nconst reStartsWithNewlineOrIsEmpty = /^(?:[\\r\\n]|$)/;\nconst reDetectIndentation = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/;\nconst reOnlyWhitespaceWithAtLeastOneNewline = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\n\nfunction _outdentArray(\n  strings: ReadonlyArray<string>,\n  firstInterpolatedValueSetsIndentationLevel: boolean,\n  options: Options,\n) {\n  // If first interpolated value is a reference to outdent,\n  // determine indentation level from the indentation of the interpolated value.\n  let indentationLevel = 0;\n\n  const match = strings[0].match(reDetectIndentation);\n  if (match) {\n    indentationLevel = match[1].length;\n  }\n\n  const reSource = `(\\\\r\\\\n|\\\\r|\\\\n).{0,${indentationLevel}}`;\n  const reMatchIndent = new RegExp(reSource, \"g\");\n\n  if (firstInterpolatedValueSetsIndentationLevel) {\n    strings = strings.slice(1);\n  }\n\n  const { newline, trimLeadingNewline, trimTrailingNewline } = options;\n  const normalizeNewlines = typeof newline === \"string\";\n  const l = strings.length;\n  const outdentedStrings = strings.map((v, i) => {\n    // Remove leading indentation from all lines\n    v = v.replace(reMatchIndent, \"$1\");\n    // Trim a leading newline from the first string\n    if (i === 0 && trimLeadingNewline) {\n      v = v.replace(reLeadingNewline, \"\");\n    }\n    // Trim a trailing newline from the last string\n    if (i === l - 1 && trimTrailingNewline) {\n      v = v.replace(reTrailingNewline, \"\");\n    }\n    // Normalize newlines\n    if (normalizeNewlines) {\n      v = v.replace(/\\r\\n|\\n|\\r/g, (_) => newline as string);\n    }\n    return v;\n  });\n  return outdentedStrings;\n}\n\nfunction concatStringsAndValues(\n  strings: ReadonlyArray<string>,\n  values: ReadonlyArray<any>,\n): string {\n  let ret = \"\";\n  for (let i = 0, l = strings.length; i < l; i++) {\n    ret += strings[i];\n    if (i < l - 1) {\n      ret += values[i];\n    }\n  }\n  return ret;\n}\n\nfunction isTemplateStringsArray(v: any): v is TemplateStringsArray {\n  return has(v, \"raw\") && has(v, \"length\");\n}\n\n/**\n * It is assumed that opts will not change.  If this is a problem, clone your options object and pass the clone to\n * makeInstance\n * @param options\n * @return {outdent}\n */\nfunction createInstance(options: Options): Outdent {\n  /** Cache of pre-processed template literal arrays */\n  const arrayAutoIndentCache = createWeakMap<\n    TemplateStringsArray,\n    Array<string>\n  >();\n  /**\n     * Cache of pre-processed template literal arrays, where first interpolated value is a reference to outdent,\n     * before interpolated values are injected.\n     */\n  const arrayFirstInterpSetsIndentCache = createWeakMap<\n    TemplateStringsArray,\n    Array<string>\n  >();\n\n  /* tslint:disable:no-shadowed-variable */\n  function outdent(\n    stringsOrOptions: TemplateStringsArray,\n    ...values: Array<any>\n  ): string;\n  function outdent(stringsOrOptions: Options): Outdent;\n  function outdent(\n    stringsOrOptions: TemplateStringsArray | Options,\n    ...values: Array<any>\n  ): string | Outdent {\n    /* tslint:enable:no-shadowed-variable */\n    if (isTemplateStringsArray(stringsOrOptions)) {\n      const strings = stringsOrOptions;\n\n      // Is first interpolated value a reference to outdent, alone on its own line, without any preceding non-whitespace?\n      const firstInterpolatedValueSetsIndentationLevel =\n        (values[0] === outdent || values[0] === defaultOutdent) &&\n        reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) &&\n        reStartsWithNewlineOrIsEmpty.test(strings[1]);\n\n      // Perform outdentation\n      const cache = firstInterpolatedValueSetsIndentationLevel\n        ? arrayFirstInterpSetsIndentCache\n        : arrayAutoIndentCache;\n      let renderedArray = cache.get(strings);\n      if (!renderedArray) {\n        renderedArray = _outdentArray(\n          strings,\n          firstInterpolatedValueSetsIndentationLevel,\n          options,\n        );\n        cache.set(strings, renderedArray);\n      }\n      /** If no interpolated values, skip concatenation step */\n      if (values.length === 0) {\n        return renderedArray[0];\n      }\n      /** Concatenate string literals with interpolated values */\n      const rendered = concatStringsAndValues(\n        renderedArray,\n        firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values,\n      );\n\n      return rendered;\n    } else {\n      // Create and return a new instance of outdent with the given options\n      return createInstance(\n        extend(extend({}, options), stringsOrOptions || {}),\n      );\n    }\n  }\n\n  const fullOutdent = extend(outdent, {\n    string(str: string): string {\n      return _outdentArray([str], false, options)[0];\n    },\n  });\n\n  return fullOutdent;\n}\n\nconst defaultOutdent = createInstance({\n  trimLeadingNewline: true,\n  trimTrailingNewline: true,\n});\n\nexport interface Outdent {\n  /**\n     * Remove indentation from a template literal.\n     */\n  (strings: TemplateStringsArray, ...values: Array<any>): string;\n  /**\n     * Create and return a new Outdent instance with the given options.\n     */\n  (options: Options): Outdent;\n\n  /**\n     * Remove indentation from a string\n     */\n  string(str: string): string;\n\n  // /**\n  //  * Remove indentation from a template literal, but return a tuple of the\n  //  * outdented TemplateStringsArray and\n  //  */\n  // pass(strings: TemplateStringsArray, ...values: Array<any>): [TemplateStringsArray, ...Array<any>];\n}\nexport interface Options {\n  trimLeadingNewline?: boolean;\n  trimTrailingNewline?: boolean;\n  /**\n     * Normalize all newlines in the template literal to this value.\n     * \n     * If `null`, newlines are left untouched.\n     * \n     * Newlines that get normalized are '\\r\\n', '\\r', and '\\n'.\n     * \n     * Newlines within interpolated values are *never* normalized.\n     * \n     * Although intended for normalizing to '\\n' or '\\r\\n',\n     * you can also set to any string; for example ' '.\n     */\n  newline?: string | null;\n}\n\n// Named exports.  Simple and preferred.\n// import outdent from 'outdent';\nexport default defaultOutdent;\n// import {outdent} from 'outdent';\nexport { defaultOutdent as outdent };\n\n// In CommonJS environments, enable `var outdent = require('outdent');` by\n// replacing the exports object.\n// Make sure that our replacement includes the named exports from above.\ndeclare var module: any;\nif (typeof module !== \"undefined\") {\n  // In webpack harmony-modules environments, module.exports is read-only,\n  // so we fail gracefully.\n  try {\n    module.exports = defaultOutdent;\n    Object.defineProperty(defaultOutdent, \"__esModule\", { value: true });\n    (defaultOutdent as any).default = defaultOutdent;\n    (defaultOutdent as any).outdent = defaultOutdent;\n  } catch (e) {}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}