{"ast":null,"code":"import { parseToRgb, toColorString, parseToHsl, hslToColorString, setLightness, getLuminance } from \"polished\";\nimport { parse } from \"gradient-parser\";\nimport { responsiveStyle } from \"../css/responsiveStyle.mjs\";\nconst getLinearGradientColors = color => {\n  const gradients = parse(color);\n  return gradients[0].colorStops.map(_ref => {\n    let {\n      type,\n      value\n    } = _ref;\n    if (typeof value !== \"string\") {\n      throw new Error(\"Gradient parsing in Braid currently only supports hex/literal values\");\n    }\n    return \"\".concat(type === \"hex\" ? \"#\" : \"\").concat(value);\n  });\n};\nconst calculateYiq = color => {\n  const {\n    red,\n    green,\n    blue\n  } = parseToRgb(color);\n  return (red * 299 + green * 587 + blue * 114) / 1e3;\n};\nconst isLight = function (inputColor) {\n  let foregroundColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"#000\";\n  const colors = /^linear-gradient/.test(inputColor) ? getLinearGradientColors(inputColor) : [inputColor];\n  const foregroundYiq = calculateYiq(foregroundColor);\n  return colors.some(color => {\n    const yiq = calculateYiq(color);\n    const midpoint = 256 / 2;\n    const foregroundOffset = foregroundYiq / 2;\n    return yiq >= midpoint + foregroundOffset;\n  });\n};\nconst AA_TEXT_CONTRAST = 4.52;\nfunction contrast(color1, color2) {\n  const L1 = getLuminance(color1) + 0.05;\n  const L2 = getLuminance(color2) + 0.05;\n  return L1 < L2 ? L2 / L1 : L1 / L2;\n}\nfunction findClosestAccessibleLighterColor(inputColor, fixedColor) {\n  let contrastRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AA_TEXT_CONTRAST;\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const {\n    hue,\n    saturation,\n    lightness\n  } = parseToHsl(normalisedInput);\n  let minLightness = lightness;\n  let maxLightness = 0.98;\n  let maxColor = hslToColorString({\n    hue,\n    saturation,\n    lightness: maxLightness\n  });\n  let minColor = hslToColorString({\n    hue,\n    saturation,\n    lightness\n  });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(\"Desired contrast ratio cannot be achieved,\\nForeground: \".concat(inputColor, \"\\nBackground:\").concat(fixedColor, \"\\nDesired Contrast:\").concat(contrastRatio, \"\\nActual Contrast:\").concat(actualRatio));\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    } else {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    }\n  }\n  return maxColor;\n}\nfunction findClosestAccessibleDarkerColor(inputColor, fixedColor) {\n  let contrastRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AA_TEXT_CONTRAST;\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const {\n    hue,\n    saturation,\n    lightness\n  } = parseToHsl(normalisedInput);\n  let minLightness = 0.02;\n  let maxLightness = lightness;\n  let maxColor = hslToColorString({\n    hue,\n    saturation,\n    lightness: minLightness\n  });\n  let minColor = hslToColorString({\n    hue,\n    saturation,\n    lightness\n  });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(\"Desired contrast ratio cannot be achieved,\\nForeground: \".concat(inputColor, \"\\nBackground:\").concat(fixedColor, \"\\nDesired Contrast:\").concat(contrastRatio, \"\\nActual Contrast:\").concat(actualRatio));\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    } else {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    }\n  }\n  return minColor;\n}\nconst smoothSaturation = (saturation, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return saturation * 0.8;\n  }\n  return saturation * 0.45;\n};\nconst smoothLightness = (lightness, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return 0.95 - lightness * 0.03;\n  }\n  return 0.95 - lightness * 0.06;\n};\nfunction getLightVariant(color) {\n  const {\n    hue,\n    saturation,\n    lightness\n  } = parseToHsl(color);\n  const luminance = getLuminance(color);\n  return toColorString({\n    hue,\n    saturation: smoothSaturation(saturation, luminance),\n    lightness: smoothLightness(lightness, luminance)\n  });\n}\nfunction getAccessibleVariant(color, background) {\n  return findClosestAccessibleDarkerColor(color, background !== null && background !== void 0 ? background : getLightVariant(color), AA_TEXT_CONTRAST);\n}\nconst mapToProperty = (property, breakpoint) => value => {\n  const styleRule = {\n    [property]: value\n  };\n  return breakpoint ? responsiveStyle({\n    [breakpoint]: styleRule\n  }) : styleRule;\n};\nexport { findClosestAccessibleLighterColor, getAccessibleVariant, getLightVariant, isLight, mapToProperty };","map":{"version":3,"names":["parseToRgb","toColorString","parseToHsl","hslToColorString","setLightness","getLuminance","parse","responsiveStyle","getLinearGradientColors","color","gradients","colorStops","map","_ref","type","value","Error","concat","calculateYiq","red","green","blue","isLight","inputColor","foregroundColor","arguments","length","undefined","colors","test","foregroundYiq","some","yiq","midpoint","foregroundOffset","AA_TEXT_CONTRAST","contrast","color1","color2","L1","L2","findClosestAccessibleLighterColor","fixedColor","contrastRatio","normalisedInput","normalisedFixed","hue","saturation","lightness","minLightness","maxLightness","maxColor","minColor","actualRatio","lastMinColor","lastMaxColor","adjustedLightness","adjustedColor","findClosestAccessibleDarkerColor","smoothSaturation","luminance","isBright","smoothLightness","getLightVariant","getAccessibleVariant","background","mapToProperty","property","breakpoint","styleRule"],"sources":["/Users/tnguoi/Desktop/SeekAdventureApp/client/node_modules/braid-design-system/dist/styles/lib/utils/index.mjs"],"sourcesContent":["import { parseToRgb, toColorString, parseToHsl, hslToColorString, setLightness, getLuminance } from \"polished\";\nimport { parse } from \"gradient-parser\";\nimport { responsiveStyle } from \"../css/responsiveStyle.mjs\";\nconst getLinearGradientColors = (color) => {\n  const gradients = parse(color);\n  return gradients[0].colorStops.map(({ type, value }) => {\n    if (typeof value !== \"string\") {\n      throw new Error(\n        \"Gradient parsing in Braid currently only supports hex/literal values\"\n      );\n    }\n    return `${type === \"hex\" ? \"#\" : \"\"}${value}`;\n  });\n};\nconst calculateYiq = (color) => {\n  const { red, green, blue } = parseToRgb(color);\n  return (red * 299 + green * 587 + blue * 114) / 1e3;\n};\nconst isLight = (inputColor, foregroundColor = \"#000\") => {\n  const colors = /^linear-gradient/.test(inputColor) ? getLinearGradientColors(inputColor) : [inputColor];\n  const foregroundYiq = calculateYiq(foregroundColor);\n  return colors.some((color) => {\n    const yiq = calculateYiq(color);\n    const midpoint = 256 / 2;\n    const foregroundOffset = foregroundYiq / 2;\n    return yiq >= midpoint + foregroundOffset;\n  });\n};\nconst AA_TEXT_CONTRAST = 4.52;\nfunction contrast(color1, color2) {\n  const L1 = getLuminance(color1) + 0.05;\n  const L2 = getLuminance(color2) + 0.05;\n  return L1 < L2 ? L2 / L1 : L1 / L2;\n}\nfunction findClosestAccessibleLighterColor(inputColor, fixedColor, contrastRatio = AA_TEXT_CONTRAST) {\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const { hue, saturation, lightness } = parseToHsl(normalisedInput);\n  let minLightness = lightness;\n  let maxLightness = 0.98;\n  let maxColor = hslToColorString({ hue, saturation, lightness: maxLightness });\n  let minColor = hslToColorString({ hue, saturation, lightness });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(\n      `Desired contrast ratio cannot be achieved,\nForeground: ${inputColor}\nBackground:${fixedColor}\nDesired Contrast:${contrastRatio}\nActual Contrast:${actualRatio}`\n    );\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    } else {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    }\n  }\n  return maxColor;\n}\nfunction findClosestAccessibleDarkerColor(inputColor, fixedColor, contrastRatio = AA_TEXT_CONTRAST) {\n  const normalisedInput = toColorString(parseToRgb(inputColor));\n  const normalisedFixed = toColorString(parseToRgb(fixedColor));\n  const { hue, saturation, lightness } = parseToHsl(normalisedInput);\n  let minLightness = 0.02;\n  let maxLightness = lightness;\n  let maxColor = hslToColorString({ hue, saturation, lightness: minLightness });\n  let minColor = hslToColorString({ hue, saturation, lightness });\n  if (contrast(normalisedInput, normalisedFixed) >= contrastRatio) {\n    return inputColor;\n  }\n  const actualRatio = contrast(maxColor, normalisedFixed);\n  if (actualRatio < contrastRatio) {\n    throw new Error(\n      `Desired contrast ratio cannot be achieved,\nForeground: ${inputColor}\nBackground:${fixedColor}\nDesired Contrast:${contrastRatio}\nActual Contrast:${actualRatio}`\n    );\n  }\n  let lastMinColor;\n  let lastMaxColor;\n  let adjustedLightness;\n  let adjustedColor = normalisedInput;\n  while (minColor !== lastMinColor || maxColor !== lastMaxColor) {\n    lastMinColor = minColor;\n    lastMaxColor = maxColor;\n    adjustedLightness = (minLightness + maxLightness) / 2;\n    adjustedColor = setLightness(adjustedLightness, adjustedColor);\n    if (contrast(adjustedColor, normalisedFixed) < contrastRatio) {\n      maxLightness = adjustedLightness;\n      maxColor = adjustedColor;\n    } else {\n      minLightness = adjustedLightness;\n      minColor = adjustedColor;\n    }\n  }\n  return minColor;\n}\nconst smoothSaturation = (saturation, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return saturation * 0.8;\n  }\n  return saturation * 0.45;\n};\nconst smoothLightness = (lightness, luminance) => {\n  const isBright = luminance > 0.6;\n  if (isBright) {\n    return 0.95 - lightness * 0.03;\n  }\n  return 0.95 - lightness * 0.06;\n};\nfunction getLightVariant(color) {\n  const { hue, saturation, lightness } = parseToHsl(color);\n  const luminance = getLuminance(color);\n  return toColorString({\n    hue,\n    saturation: smoothSaturation(saturation, luminance),\n    lightness: smoothLightness(lightness, luminance)\n  });\n}\nfunction getAccessibleVariant(color, background) {\n  return findClosestAccessibleDarkerColor(\n    color,\n    background ?? getLightVariant(color),\n    AA_TEXT_CONTRAST\n  );\n}\nconst mapToProperty = (property, breakpoint) => (value) => {\n  const styleRule = { [property]: value };\n  return breakpoint ? responsiveStyle({ [breakpoint]: styleRule }) : styleRule;\n};\nexport {\n  findClosestAccessibleLighterColor,\n  getAccessibleVariant,\n  getLightVariant,\n  isLight,\n  mapToProperty\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}