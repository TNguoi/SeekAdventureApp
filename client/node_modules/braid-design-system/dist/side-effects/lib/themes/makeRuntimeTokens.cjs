"use strict";
const mapValues = require("lodash/mapValues.js");
const styles_lib_utils_index_cjs = require("../../../styles/lib/utils/index.cjs");
const _interopDefaultCompat = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
const mapValues__default = /* @__PURE__ */ _interopDefaultCompat(mapValues);
const makeWebFonts = (webFont) => {
  if (!webFont) {
    return [];
  }
  return [{ linkTag: `<link href="${webFont}" rel="stylesheet" />` }];
};
const makeRuntimeTokens = (tokens) => ({
  name: tokens.name,
  displayName: tokens.displayName,
  /**
   * The boundary for making updated design decisions without disturbing
   * existing consumers. Updated decisions can be assessed as part of
   * migrating between themes.
   *
   * This token will be removed when the `apac` theme is retired.
   */
  legacy: tokens.legacy,
  background: {
    lightMode: tokens.color.background.body,
    darkMode: tokens.color.background.bodyDark
  },
  webFonts: makeWebFonts(tokens.typography.webFont),
  space: {
    grid: tokens.grid,
    space: tokens.space
  },
  color: tokens.color,
  backgroundLightness: mapValues__default.default(
    tokens.color.background,
    (background, name) => {
      const referenceColorMap = {
        brandAccentActive: "brandAccent",
        brandAccentHover: "brandAccent",
        formAccentActive: "formAccent",
        formAccentHover: "formAccent"
      };
      const referenceColor = name in referenceColorMap ? tokens.color.background[referenceColorMap[name]] : background;
      if (!referenceColor) {
        throw new Error(
          `Error resolving background lightness for background "${background}" in "${tokens.name}" theme.`
        );
      }
      return styles_lib_utils_index_cjs.isLight(referenceColor, tokens.color.foreground.neutral) ? "light" : "dark";
    }
  )
});
exports.makeRuntimeTokens = makeRuntimeTokens;
