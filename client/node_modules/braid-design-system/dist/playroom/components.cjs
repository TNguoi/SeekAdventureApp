"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const dedent = require("dedent");
const jsxRuntime = require("react/jsx-runtime");
const styles_lib_css_atoms_sprinkles_css_cjs = require("../styles/lib/css/atoms/sprinkles.css.cjs");
require("../styles/lib/themes/apac/apacTheme.css.cjs");
require("../styles/lib/themes/seekJobs/seekJobs.css.cjs");
require("../styles/lib/themes/seekBusiness/seekBusinessTheme.css.cjs");
const styles_lib_themes_wireframe_wireframeTheme_css_cjs = require("../styles/lib/themes/wireframe/wireframeTheme.css.cjs");
require("../styles/lib/themes/docs/docsTheme.css.cjs");
const index = require("../index.chunk.cjs");
const playroomState = require("../playroomState.chunk.cjs");
const React = require("react");
const uuid = require("uuid");
const ToastContext = require("../ToastContext.chunk.cjs");
const styles_lib_css_atoms_atoms_cjs = require("../styles/lib/css/atoms/atoms.cjs");
const styles_lib_css_breakpoints_cjs = require("../styles/lib/css/breakpoints.cjs");
const styles_lib_css_atoms_atomicProperties_cjs = require("../styles/lib/css/atoms/atomicProperties.cjs");
const styles_lib_components_private_Placeholder_Placeholder_css_cjs = require("../styles/lib/components/private/Placeholder/Placeholder.css.cjs");
const sideEffects_lib_components_BraidProvider_BraidProvider_cjs = require("../side-effects/lib/components/BraidProvider/BraidProvider.cjs");
const _interopDefaultCompat = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
const dedent__default = /* @__PURE__ */ _interopDefaultCompat(dedent);
const spaceScale = ["none", ...Object.keys(styles_lib_themes_wireframe_wireframeTheme_css_cjs.wireframe.space.space)];
const filterSpace = (space) => {
  const filteredSpace = styles_lib_css_atoms_sprinkles_css_cjs.mapResponsiveValue(space, (value) => {
    if (spaceScale.includes(value) && !index.validSpaceValues.includes(value)) {
      throw new Error(
        `To ensure adequate space for touch targets, 'space' prop values must be one of the following: ${index.validSpaceValues.map((x) => `"${x}"`).join(", ")}`
      );
    }
    return index.validSpaceValues.includes(value) ? value : "medium";
  });
  return filteredSpace;
};
const Accordion = ({
  space,
  size,
  tone,
  weight,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Accordion,
  {
    size: typeof size === "boolean" ? void 0 : size,
    tone: typeof tone === "boolean" ? void 0 : tone,
    weight: typeof weight === "boolean" ? void 0 : weight,
    space: typeof space === "string" || Array.isArray(space) ? filterSpace(space) : void 0,
    ...restProps
  }
);
const useFallbackId = () => React.useRef(`fallbackId-${uuid.v4()}`).current;
const AccordionItem = ({
  id,
  label,
  stateName,
  expanded,
  onToggle,
  size,
  tone,
  weight,
  badge,
  icon,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    expanded,
    onToggle,
    false
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.AccordionItem,
    {
      id: id ?? fallbackId,
      expanded: state,
      onToggle: handleChange,
      label: typeof label !== "boolean" ? label : "",
      size: typeof size === "boolean" ? void 0 : size,
      tone: typeof tone === "boolean" ? void 0 : tone,
      weight: typeof weight === "boolean" ? void 0 : weight,
      badge: typeof badge === "boolean" ? void 0 : badge,
      icon: typeof icon === "boolean" ? void 0 : icon,
      ...restProps
    }
  );
};
const Alert = ({ tone, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Alert,
  {
    tone: typeof tone !== "boolean" ? tone : void 0,
    ...restProps
  }
);
function Autosuggest({
  id,
  stateName,
  value,
  onChange,
  onClear,
  ...restProps
}) {
  const fallbackId = useFallbackId();
  const blankValue = { text: "" };
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    value,
    onChange,
    blankValue
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Autosuggest,
    {
      id: id ?? fallbackId,
      value: state,
      onChange: handleChange,
      onClear: () => {
        handleChange(blankValue);
        onClear == null ? void 0 : onClear();
      },
      ...restProps
    }
  );
}
const Badge = ({ tone, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Badge,
  {
    tone: typeof tone !== "boolean" ? tone : void 0,
    ...restProps
  }
);
Badge.__isBadge__ = true;
const Bleed = ({ component, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  ToastContext.Bleed,
  {
    component: component && ToastContext.validBleedComponents.indexOf(component) > -1 ? component : void 0,
    ...restProps
  }
);
const Box = React.forwardRef((props, ref) => {
  const sprinklesProps = {};
  const otherProps = {};
  for (const key in props) {
    if (styles_lib_css_atoms_sprinkles_css_cjs.sprinkles.properties.has(key)) {
      const value = props[key];
      try {
        styles_lib_css_atoms_atoms_cjs.atoms({ [key]: value });
        sprinklesProps[key] = value;
      } catch (e) {
        if (key === "background") {
          if (typeof value === "string" && /^customDark|customLight$/.test(value) || typeof value === "object" && (value.darkMode || value.lightMode)) {
            sprinklesProps[key] = value;
          }
        }
      }
    } else {
      otherProps[key] = props[key];
    }
  }
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { ref, ...sprinklesProps, ...otherProps });
});
Box.displayName = "Box";
const Button = React.forwardRef(
  ({ variant, tone, ...restProps }, ref) => {
    const isValidVariant = variant && ToastContext.buttonVariants.indexOf(variant) > -1;
    const isValidTone = tone && ToastContext.buttonTones.indexOf(tone) > -1;
    return /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Button,
      {
        ref,
        variant: isValidVariant ? variant : void 0,
        tone: isValidTone ? tone : void 0,
        ...restProps
      }
    );
  }
);
Button.displayName = "Button";
const ButtonIcon = React.forwardRef(
  ({ variant, id, tone, ...restProps }, ref) => {
    const fallbackId = useFallbackId();
    const isValidVariant = variant && ToastContext.buttonIconVariants.indexOf(variant) > -1;
    const isValidTone = tone && ToastContext.buttonIconTones.indexOf(tone) > -1;
    return /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.ButtonIcon,
      {
        ref,
        id: id ?? fallbackId,
        variant: isValidVariant ? variant : void 0,
        tone: isValidTone ? tone : void 0,
        ...restProps
      }
    );
  }
);
ButtonIcon.displayName = "ButtonIcon";
const ButtonLink = React.forwardRef(
  ({ variant, ...restProps }, ref) => {
    const isValidVariant = variant && ToastContext.buttonVariants.indexOf(variant) > -1;
    return /* @__PURE__ */ jsxRuntime.jsx(
      index.ButtonLink,
      {
        ref,
        variant: isValidVariant ? variant : void 0,
        ...restProps
      }
    );
  }
);
ButtonLink.displayName = "ButtonLink";
const Card = ({ component, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Card,
  {
    component: component && index.validCardComponents.indexOf(component) > -1 ? component : void 0,
    ...restProps
  }
);
const Checkbox = ({
  id,
  stateName,
  checked,
  onChange,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    checked,
    onChange,
    false
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Checkbox,
    {
      id: id ?? fallbackId,
      checked: state,
      onChange: handleChange,
      ...restProps
    }
  );
};
const CheckboxStandalone = ({
  id,
  stateName,
  checked,
  onChange,
  "aria-label": ariaLabel,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    checked,
    onChange,
    false
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.CheckboxStandalone,
    {
      id: id ?? fallbackId,
      checked: state,
      onChange: handleChange,
      "aria-label": ariaLabel ?? "",
      ...restProps
    }
  );
};
const validSpaceValues = Object.keys(styles_lib_css_atoms_atomicProperties_cjs.space);
const cleanSpaceValue = (space) => {
  const validResponsiveObject = typeof space === "object" && Object.keys(space).some(
    (bp) => styles_lib_css_breakpoints_cjs.breakpointNames.includes(bp) && validSpaceValues.includes(space[bp])
  );
  const validArray = Array.isArray(space) && space.some((s) => validSpaceValues.includes(s));
  const validSpace = typeof space === "string" && validSpaceValues.includes(space);
  return validSpace || validResponsiveObject || validArray ? space : void 0;
};
const Columns = ({
  space,
  align,
  alignY,
  component,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  ToastContext.Columns,
  {
    space: cleanSpaceValue(space) || "none",
    align: typeof align !== "boolean" ? align : void 0,
    alignY: typeof alignY !== "boolean" ? alignY : void 0,
    component: component && ToastContext.validColumnsComponents.indexOf(component) > -1 ? component : void 0,
    ...restProps
  }
);
const Dialog = ({
  id,
  stateName,
  open,
  onClose,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    open,
    onClose,
    false
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.AllowCloseContext.Provider,
    {
      value: onClose !== void 0 || stateName !== void 0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        index.Dialog,
        {
          id: id ?? fallbackId,
          open: state,
          onClose: handleChange,
          ...restProps
        }
      )
    }
  );
};
const Disclosure = ({
  id,
  stateName,
  expanded,
  expandLabel,
  collapseLabel,
  onToggle,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    expanded,
    onToggle,
    false
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Disclosure,
    {
      id: id ?? fallbackId,
      expanded: state,
      onToggle: handleChange,
      expandLabel: typeof expandLabel !== "boolean" ? expandLabel : "",
      collapseLabel: typeof collapseLabel !== "boolean" ? collapseLabel : "",
      ...restProps
    }
  );
};
const Drawer = ({
  id,
  stateName,
  open,
  onClose,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    open,
    onClose,
    false
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.AllowCloseContext.Provider,
    {
      value: onClose !== void 0 || stateName !== void 0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        index.Drawer,
        {
          id: id ?? fallbackId,
          ...restProps,
          open: state,
          onClose: handleChange
        }
      )
    }
  );
};
const Dropdown = ({
  id,
  stateName,
  value,
  onChange,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    value,
    onChange,
    ""
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Dropdown,
    {
      id: id ?? fallbackId,
      value: state,
      onChange: handleChange,
      ...restProps
    }
  );
};
const FieldLabel = ({
  id,
  htmlFor,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const fallbackFor = useFallbackId();
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.FieldLabel,
    {
      id: id ?? fallbackId,
      htmlFor: htmlFor ?? fallbackFor,
      ...restProps
    }
  );
};
const FieldMessage = ({
  id,
  tone,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.FieldMessage,
    {
      id: id ?? fallbackId,
      tone: tone && index.tones.indexOf(tone) > -1 ? tone : void 0,
      ...restProps
    }
  );
};
const Heading = ({ level, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(index.Heading, { level: level || "3", ...restProps });
const Inline = ({
  space,
  align,
  alignY,
  component,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  ToastContext.Inline,
  {
    space: cleanSpaceValue(space) || "none",
    align: typeof align !== "boolean" ? align : void 0,
    alignY: typeof alignY !== "boolean" ? alignY : void 0,
    component: component && ToastContext.validInlineComponents.indexOf(component) > -1 ? component : void 0,
    ...restProps
  }
);
const Link = React.forwardRef(
  ({ href, onClick, ...restProps }, ref) => /* @__PURE__ */ jsxRuntime.jsx(
    index.Link,
    {
      ref,
      href: href ?? "",
      onClick: onClick ? onClick : (event) => event == null ? void 0 : event.preventDefault(),
      ...restProps
    }
  )
);
const List = ({ space, ...props }) => {
  const cleanSpace = cleanSpaceValue(space);
  if (props.type === "icon" && (!("icon" in props) || !props.icon)) {
    return /* @__PURE__ */ jsxRuntime.jsx(index.List, { ...props, space: cleanSpace, icon: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconClear, {}) });
  }
  return /* @__PURE__ */ jsxRuntime.jsx(index.List, { space: cleanSpace, ...props });
};
const MonthPicker = ({
  id,
  stateName,
  value,
  onChange,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    value,
    onChange,
    {}
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.MonthPicker,
    {
      id: id ?? fallbackId,
      value: state,
      onChange: handleChange,
      ...restProps
    }
  );
};
const MenuItem = ({ badge, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.MenuItem,
  {
    badge: typeof badge === "boolean" ? void 0 : badge,
    ...restProps
  }
);
MenuItem.__isMenuItem__ = true;
const MenuItemLink = ({ badge, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.MenuItemLink,
  {
    badge: typeof badge === "boolean" ? void 0 : badge,
    ...restProps
  }
);
MenuItemLink.__isMenuItem__ = true;
const MenuItemCheckbox = ({
  badge,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  index.MenuItemCheckbox,
  {
    badge: typeof badge === "boolean" ? void 0 : badge,
    ...restProps
  }
);
MenuItemCheckbox.__isMenuItem__ = true;
const Notice = ({ tone, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Notice,
  {
    tone: typeof tone !== "boolean" ? tone : void 0,
    ...restProps
  }
);
const OverflowMenu = ({ id, ...restProps }) => {
  const fallbackId = useFallbackId();
  return /* @__PURE__ */ jsxRuntime.jsx(index.OverflowMenu, { id: id ?? fallbackId, ...restProps });
};
const defaultPage = 1;
const defaultTotal = 10;
const resolveFallbackPage = (page, total) => {
  if (typeof page === "number") {
    return page > 0 ? page : 1;
  }
  if (typeof total === "number" && total > 0) {
    return Math.ceil(total / 2);
  }
  return defaultPage;
};
const resolveFallbackTotal = (total, resolvedPage) => {
  if (typeof total === "number" && total > 0) {
    return total;
  }
  return resolvedPage > index.defaultPageLimit ? resolvedPage * 2 : defaultTotal;
};
const Pagination = ({
  page,
  total,
  linkProps,
  label,
  ...restProps
}) => {
  const fallbackPage = resolveFallbackPage(page, total);
  const fallbackTotal = resolveFallbackTotal(total, fallbackPage);
  const [currentPage, setCurrentPage] = React.useState(fallbackPage);
  const fallbackLinkProps = ({
    page: newPage
  }) => ({
    href: "#",
    onClick: (e) => {
      e.preventDefault();
      setCurrentPage(newPage);
    }
  });
  React.useEffect(() => {
    setCurrentPage(resolveFallbackPage(page, total));
  }, [page, total]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Pagination,
    {
      page: currentPage,
      total: total || fallbackTotal,
      label: label || `Page ${currentPage} of results`,
      linkProps: linkProps ?? fallbackLinkProps,
      ...restProps
    }
  );
};
const PasswordField = ({
  id,
  stateName,
  value,
  onChange,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    value,
    onChange,
    ""
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.PasswordField,
    {
      id: id ?? fallbackId,
      value: state,
      onChange: handleChange,
      autoComplete: "off",
      ...restProps
    }
  );
};
const Radio = ({
  id,
  checked,
  onChange,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [fallbackChecked, setFallbackChecked] = React.useState(false);
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Radio,
    {
      id: id ?? fallbackId,
      checked: checked ?? fallbackChecked,
      onChange: onChange ? onChange : (event) => setFallbackChecked(event.currentTarget.checked),
      ...restProps
    }
  );
};
const RadioGroup = ({
  id,
  stateName,
  value,
  onChange,
  children,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(stateName, value, onChange);
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.RadioGroup,
    {
      ...restProps,
      id: id ?? fallbackId,
      value: state,
      onChange: handleChange,
      children
    }
  );
};
const Rating = ({ rating, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Rating,
  {
    rating: typeof rating === "number" ? rating : 0,
    ...restProps
  }
);
const Stack = ({
  space,
  align,
  component,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  ToastContext.Stack,
  {
    space: cleanSpaceValue(space) || "none",
    align: typeof align !== "boolean" ? align : void 0,
    component: component && ToastContext.validStackComponents.indexOf(component) > -1 ? component : void 0,
    ...restProps
  }
);
const TabsProvider = ({
  id,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  return /* @__PURE__ */ jsxRuntime.jsx(index.TabsProvider, { id: id ?? fallbackId, ...restProps });
};
const Tabs = ({ label, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(index.Tabs, { label: "", ...restProps });
const Tab = ({ icon, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Tab,
  {
    icon: typeof icon === "boolean" ? void 0 : icon,
    ...restProps
  }
);
Tab.__isTab__ = true;
const Tag = ({ icon, id, ...restProps }) => {
  const fallbackId = useFallbackId();
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Tag,
    {
      id: id ?? fallbackId,
      icon: typeof icon !== "boolean" ? icon : void 0,
      ...restProps
    }
  );
};
const Textarea = ({
  id,
  stateName,
  value,
  onChange,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    value,
    onChange,
    ""
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Textarea,
    {
      id: id ?? fallbackId,
      value: state,
      onChange: handleChange,
      autoComplete: "off",
      ...restProps
    }
  );
};
const fallbackOptions = ["TextDropdown"];
function resolveValue(value, options) {
  if (typeof value === "undefined") {
    if (Array.isArray(options) && options.length > 0) {
      return index.parseSimpleToComplexOption(options[0]).value;
    }
    return fallbackOptions[0];
  }
  return value;
}
function resolveOptions(options) {
  return Array.isArray(options) && options.length > 0 ? options : fallbackOptions;
}
function TextDropdown({
  id,
  value,
  label,
  onChange,
  options = fallbackOptions,
  ...restProps
}) {
  const fallbackId = useFallbackId();
  const [internalValue, setInternalValue] = React.useState(
    resolveValue(value, options)
  );
  const [internalOptions, setInternalOptions] = React.useState(
    resolveOptions(options)
  );
  React.useEffect(() => {
    if (options !== internalOptions) {
      setInternalOptions(resolveOptions(options));
      setInternalValue(resolveValue(value, options));
    }
  }, [internalOptions, value, options]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.TextDropdown,
    {
      id: id ?? fallbackId,
      label: label ?? "No label provided",
      value: internalValue,
      options: internalOptions,
      onChange: onChange ? onChange : setInternalValue,
      ...restProps
    }
  );
}
const TextField = ({
  id,
  stateName,
  value,
  onChange,
  onClear,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    value,
    onChange,
    ""
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.TextField,
    {
      id: id ?? fallbackId,
      value: state,
      onChange: handleChange,
      onClear: () => {
        handleChange({ currentTarget: { value: "" } });
        onClear == null ? void 0 : onClear();
      },
      autoComplete: "off",
      ...restProps
    }
  );
};
const Tiles = ({ space, columns, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  index.Tiles,
  {
    space: cleanSpaceValue(space) || "none",
    columns: typeof columns === "boolean" || !columns ? 1 : columns,
    ...restProps
  }
);
const Toggle = ({
  id,
  stateName,
  on,
  onChange,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  const [state, handleChange] = playroomState.useFallbackState(
    stateName,
    on,
    onChange,
    false
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    index.Toggle,
    {
      id: id ?? fallbackId,
      on: state,
      onChange: handleChange,
      ...restProps
    }
  );
};
const TooltipRenderer = ({
  id,
  ...restProps
}) => {
  const fallbackId = useFallbackId();
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.TooltipRenderer, { id: id ?? fallbackId, ...restProps });
};
const resolveToPxIfUnitless = (value) => typeof value === "string" && /[0-9]$/.test(value) ? `${value}px` : value;
const PlaceholderContent = ({
  label,
  image
}) => {
  if (image) {
    return null;
  }
  if (label) {
    return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.PublicBox, { paddingX: "xsmall", paddingY: "xxsmall", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { size: "small", weight: "strong", align: "center", baseline: false, children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.PublicBox, { className: styles_lib_components_private_Placeholder_Placeholder_css_cjs.label, children: label }) }) });
  }
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      className: styles_lib_css_atoms_atoms_cjs.atoms({
        reset: "svg",
        position: "absolute",
        width: "full",
        height: "full"
      }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("line", { className: styles_lib_components_private_Placeholder_Placeholder_css_cjs.line, x1: 0, y1: 0, x2: "100%", y2: "100%" }),
        /* @__PURE__ */ jsxRuntime.jsx("line", { className: styles_lib_components_private_Placeholder_Placeholder_css_cjs.line, x1: "100%", y1: 0, x2: 0, y2: "100%" })
      ]
    }
  );
};
const Placeholder = ({
  label,
  width = "auto",
  height = 120,
  shape = "rectangle",
  image,
  imageSize = "cover"
}) => {
  const lightness = ToastContext.useBackgroundLightness();
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.PublicBox,
    {
      position: "relative",
      overflow: "hidden",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: shape === "round" ? "full" : void 0,
      className: [
        styles_lib_themes_wireframe_wireframeTheme_css_cjs.wireframe.vanillaTheme,
        styles_lib_components_private_Placeholder_Placeholder_css_cjs.lightTheme[lightness.lightMode],
        styles_lib_components_private_Placeholder_Placeholder_css_cjs.darkTheme[lightness.darkMode],
        !image ? styles_lib_components_private_Placeholder_Placeholder_css_cjs.box : void 0
      ],
      style: {
        width: resolveToPxIfUnitless(width),
        height: resolveToPxIfUnitless(height),
        background: image ? `url(${image}) no-repeat center center` : void 0,
        backgroundSize: imageSize
      },
      children: /* @__PURE__ */ jsxRuntime.jsx(PlaceholderContent, { label, image })
    }
  );
};
const global = globalThis;
if (global.__IS_PLAYROOM_ENVIRONMENT__ !== "clearly") {
  throw new Error(dedent__default.default`
    Playroom prototyping components are being imported instead of Braid components.
    ‎
    These components must not be used in production. Please import from the top level Braid entry point:
    ‎
    -import { Component } from 'braid-design-system/playroom/components';
    +import { Component } from 'braid-design-system';
  `);
}
exports.Actions = index.Actions;
exports.BoxRenderer = index.BoxRenderer;
exports.HiddenVisually = index.HiddenVisually;
exports.IconAdd = index.IconAdd;
exports.IconArrow = index.IconArrow;
exports.IconBookmark = index.IconBookmark;
exports.IconCaution = index.IconCaution;
exports.IconChevron = index.IconChevron;
exports.IconCompany = index.IconCompany;
exports.IconCompose = index.IconCompose;
exports.IconCopy = index.IconCopy;
exports.IconCreditCard = index.IconCreditCard;
exports.IconDate = index.IconDate;
exports.IconDelete = index.IconDelete;
exports.IconDesktop = index.IconDesktop;
exports.IconDocument = index.IconDocument;
exports.IconDocumentBroken = index.IconDocumentBroken;
exports.IconDownload = index.IconDownload;
exports.IconEdit = index.IconEdit;
exports.IconEducation = index.IconEducation;
exports.IconEnlarge = index.IconEnlarge;
exports.IconFilter = index.IconFilter;
exports.IconFlag = index.IconFlag;
exports.IconGrid = index.IconGrid;
exports.IconHeart = index.IconHeart;
exports.IconHelp = index.IconHelp;
exports.IconHistory = index.IconHistory;
exports.IconHome = index.IconHome;
exports.IconImage = index.IconImage;
exports.IconInfo = index.IconInfo;
exports.IconInvoice = index.IconInvoice;
exports.IconLanguage = index.IconLanguage;
exports.IconLink = index.IconLink;
exports.IconLinkBroken = index.IconLinkBroken;
exports.IconList = index.IconList;
exports.IconLocation = index.IconLocation;
exports.IconMail = index.IconMail;
exports.IconMessage = index.IconMessage;
exports.IconMinus = index.IconMinus;
exports.IconMobile = index.IconMobile;
exports.IconMoney = index.IconMoney;
exports.IconNewWindow = index.IconNewWindow;
exports.IconNote = index.IconNote;
exports.IconNotification = index.IconNotification;
exports.IconOverflow = index.IconOverflow;
exports.IconPeople = index.IconPeople;
exports.IconPersonAdd = index.IconPersonAdd;
exports.IconPersonVerified = index.IconPersonVerified;
exports.IconPhone = index.IconPhone;
exports.IconPlatformAndroid = index.IconPlatformAndroid;
exports.IconPlatformApple = index.IconPlatformApple;
exports.IconPrint = index.IconPrint;
exports.IconProfile = index.IconProfile;
exports.IconPromote = index.IconPromote;
exports.IconRecommended = index.IconRecommended;
exports.IconRefresh = index.IconRefresh;
exports.IconResume = index.IconResume;
exports.IconSearch = index.IconSearch;
exports.IconSecurity = index.IconSecurity;
exports.IconSend = index.IconSend;
exports.IconSent = index.IconSent;
exports.IconSettings = index.IconSettings;
exports.IconShare = index.IconShare;
exports.IconSocialFacebook = index.IconSocialFacebook;
exports.IconSocialGitHub = index.IconSocialGitHub;
exports.IconSocialInstagram = index.IconSocialInstagram;
exports.IconSocialLinkedIn = index.IconSocialLinkedIn;
exports.IconSocialMedium = index.IconSocialMedium;
exports.IconSocialTwitter = index.IconSocialTwitter;
exports.IconSocialYouTube = index.IconSocialYouTube;
exports.IconStar = index.IconStar;
exports.IconStatistics = index.IconStatistics;
exports.IconSubCategory = index.IconSubCategory;
exports.IconTag = index.IconTag;
exports.IconThumb = index.IconThumb;
exports.IconTick = index.IconTick;
exports.IconTime = index.IconTime;
exports.IconTip = index.IconTip;
exports.IconUpload = index.IconUpload;
exports.IconVideo = index.IconVideo;
exports.IconVisibility = index.IconVisibility;
exports.IconWorkExperience = index.IconWorkExperience;
exports.IconZoomIn = index.IconZoomIn;
exports.IconZoomOut = index.IconZoomOut;
exports.Loader = index.Loader;
exports.MenuItemDivider = index.MenuItemDivider;
exports.MenuRenderer = index.MenuRenderer;
exports.Page = index.Page;
exports.PageBlock = index.PageBlock;
exports.RadioItem = index.RadioItem;
exports.Secondary = index.Secondary;
exports.Step = index.Step;
exports.Stepper = index.Stepper;
exports.Strong = index.Strong;
exports.TabPanel = index.TabPanel;
exports.TabPanels = index.TabPanels;
exports.ThemeNameConsumer = index.ThemeNameConsumer;
exports.filterSuggestions = index.filterSuggestions;
exports.useBreakpoint = index.useBreakpoint;
exports.useColor = index.useColor;
exports.BraidPortal = ToastContext.BraidPortal;
exports.Column = ToastContext.Column;
exports.ContentBlock = ToastContext.ContentBlock;
exports.Divider = ToastContext.Divider;
exports.Hidden = ToastContext.Hidden;
exports.IconClear = ToastContext.IconClear;
exports.IconCritical = ToastContext.IconCritical;
exports.IconPositive = ToastContext.IconPositive;
exports.IconRenderer = ToastContext.IconRenderer;
exports.Text = ToastContext.Text;
exports.TextLink = ToastContext.TextLink;
exports.TextLinkButton = ToastContext.TextLinkButton;
exports.ToastProvider = ToastContext.ToastProvider;
exports.useResponsiveValue = ToastContext.useResponsiveValue;
exports.useSpace = ToastContext.useSpace;
exports.useThemeName = ToastContext.useThemeName;
exports.useToast = ToastContext.useToast;
exports.BraidProvider = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.BraidProvider;
exports.makeLinkComponent = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.makeLinkComponent;
exports.Accordion = Accordion;
exports.AccordionItem = AccordionItem;
exports.Alert = Alert;
exports.Autosuggest = Autosuggest;
exports.Badge = Badge;
exports.Bleed = Bleed;
exports.Box = Box;
exports.Button = Button;
exports.ButtonIcon = ButtonIcon;
exports.ButtonLink = ButtonLink;
exports.Card = Card;
exports.Checkbox = Checkbox;
exports.CheckboxStandalone = CheckboxStandalone;
exports.Columns = Columns;
exports.Dialog = Dialog;
exports.Disclosure = Disclosure;
exports.Drawer = Drawer;
exports.Dropdown = Dropdown;
exports.FieldLabel = FieldLabel;
exports.FieldMessage = FieldMessage;
exports.Heading = Heading;
exports.Inline = Inline;
exports.Link = Link;
exports.List = List;
exports.MenuItem = MenuItem;
exports.MenuItemCheckbox = MenuItemCheckbox;
exports.MenuItemLink = MenuItemLink;
exports.MonthPicker = MonthPicker;
exports.Notice = Notice;
exports.OverflowMenu = OverflowMenu;
exports.Pagination = Pagination;
exports.PasswordField = PasswordField;
exports.Placeholder = Placeholder;
exports.Radio = Radio;
exports.RadioGroup = RadioGroup;
exports.Rating = Rating;
exports.Stack = Stack;
exports.Tab = Tab;
exports.Tabs = Tabs;
exports.TabsProvider = TabsProvider;
exports.Tag = Tag;
exports.TextDropdown = TextDropdown;
exports.TextField = TextField;
exports.Textarea = Textarea;
exports.Tiles = Tiles;
exports.Toggle = Toggle;
exports.TooltipRenderer = TooltipRenderer;
