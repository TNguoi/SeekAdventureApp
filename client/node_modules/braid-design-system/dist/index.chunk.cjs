"use strict";
const sideEffects_lib_components_BraidProvider_BraidProvider_cjs = require("./side-effects/lib/components/BraidProvider/BraidProvider.cjs");
const ToastContext = require("./ToastContext.chunk.cjs");
const jsxRuntime = require("react/jsx-runtime");
const assert = require("assert");
const React = require("react");
const styles_lib_css_atoms_sprinkles_css_cjs = require("./styles/lib/css/atoms/sprinkles.css.cjs");
const styles_lib_components_Accordion_AccordionItem_css_cjs = require("./styles/lib/components/Accordion/AccordionItem.css.cjs");
const styles_lib_components_icons_IconChevron_IconChevron_css_cjs = require("./styles/lib/components/icons/IconChevron/IconChevron.css.cjs");
const styles_lib_components_private_hideFocusRings_hideFocusRings_css_cjs = require("./styles/lib/components/private/hideFocusRings/hideFocusRings.css.cjs");
const styles_lib_css_textAlignedToIcon_css_cjs = require("./styles/lib/css/textAlignedToIcon.css.cjs");
const styles_lib_components_Alert_Alert_css_cjs = require("./styles/lib/components/Alert/Alert.css.cjs");
const dedent = require("dedent");
const parseHighlights = require("autosuggest-highlight/parse/index.js");
const styles_lib_css_typography_css_cjs = require("./styles/lib/css/typography.css.cjs");
const styles_lib_components_HiddenVisually_HiddenVisually_css_cjs = require("./styles/lib/components/HiddenVisually/HiddenVisually.css.cjs");
const reactDom = require("react-dom");
const styles_lib_css_atoms_atoms_cjs = require("./styles/lib/css/atoms/atoms.cjs");
const clsx = require("clsx");
const styles_lib_components_private_Field_Field_css_cjs = require("./styles/lib/components/private/Field/Field.css.cjs");
const reactRemoveScroll = require("react-remove-scroll");
const styles_lib_components_Autosuggest_Autosuggest_css_cjs = require("./styles/lib/components/Autosuggest/Autosuggest.css.cjs");
const matchHighlights = require("autosuggest-highlight/match/index.js");
const styles_lib_components_private_Keyline_Keyline_css_cjs = require("./styles/lib/components/private/Keyline/Keyline.css.cjs");
const styles_lib_components_private_InlineField_InlineField_css_cjs = require("./styles/lib/components/private/InlineField/InlineField.css.cjs");
const FocusLock = require("react-focus-lock");
const styles_lib_components_private_Modal_ModalExternalGutter_cjs = require("./styles/lib/components/private/Modal/ModalExternalGutter.cjs");
const styles_lib_components_private_Modal_Modal_css_cjs = require("./styles/lib/components/private/Modal/Modal.css.cjs");
const styles_lib_components_Dropdown_Dropdown_css_cjs = require("./styles/lib/components/Dropdown/Dropdown.css.cjs");
const styles_lib_css_lineHeightContainer_css_cjs = require("./styles/lib/css/lineHeightContainer.css.cjs");
const styles_lib_components_List_List_css_cjs = require("./styles/lib/components/List/List.css.cjs");
const styles_lib_components_Loader_Loader_css_cjs = require("./styles/lib/components/Loader/Loader.css.cjs");
const styles_lib_components_MenuRenderer_MenuRenderer_css_cjs = require("./styles/lib/components/MenuRenderer/MenuRenderer.css.cjs");
const styles_lib_components_MenuItem_useMenuItem_css_cjs = require("./styles/lib/components/MenuItem/useMenuItem.css.cjs");
const styles_lib_components_MenuItemCheckbox_MenuItemCheckbox_css_cjs = require("./styles/lib/components/MenuItemCheckbox/MenuItemCheckbox.css.cjs");
const styles_lib_components_OverflowMenu_OverflowMenu_css_cjs = require("./styles/lib/components/OverflowMenu/OverflowMenu.css.cjs");
const isMobile = require("is-mobile");
const styles_lib_components_MonthPicker_MonthPicker_css_cjs = require("./styles/lib/components/MonthPicker/MonthPicker.css.cjs");
const styles_lib_components_Page_Page_css_cjs = require("./styles/lib/components/Page/Page.css.cjs");
const styles_lib_components_Pagination_Pagination_css_cjs = require("./styles/lib/components/Pagination/Pagination.css.cjs");
const styles_lib_components_Rating_Rating_css_cjs = require("./styles/lib/components/Rating/Rating.css.cjs");
const styles_lib_components_Stepper_Stepper_css_cjs = require("./styles/lib/components/Stepper/Stepper.css.cjs");
const styles_lib_components_Tabs_Tabs_css_cjs = require("./styles/lib/components/Tabs/Tabs.css.cjs");
const dynamic = require("@vanilla-extract/dynamic");
const styles_lib_components_Tag_Tag_css_cjs = require("./styles/lib/components/Tag/Tag.css.cjs");
const styles_lib_components_Textarea_Highlight_Highlight_css_cjs = require("./styles/lib/components/Textarea/Highlight/Highlight.css.cjs");
const styles_lib_components_Textarea_Textarea_css_cjs = require("./styles/lib/components/Textarea/Textarea.css.cjs");
const styles_lib_components_TextDropdown_TextDropdown_css_cjs = require("./styles/lib/components/TextDropdown/TextDropdown.css.cjs");
const styles_lib_components_Tiles_Tiles_css_cjs = require("./styles/lib/components/Tiles/Tiles.css.cjs");
const styles_lib_components_Toggle_Toggle_css_cjs = require("./styles/lib/components/Toggle/Toggle.css.cjs");
const styles_lib_components_icons_IconArrow_IconArrow_css_cjs = require("./styles/lib/components/icons/IconArrow/IconArrow.css.cjs");
const styles_lib_components_icons_IconThumb_IconThumb_css_cjs = require("./styles/lib/components/icons/IconThumb/IconThumb.css.cjs");
const _interopDefaultCompat = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
const assert__default = /* @__PURE__ */ _interopDefaultCompat(assert);
const dedent__default = /* @__PURE__ */ _interopDefaultCompat(dedent);
const parseHighlights__default = /* @__PURE__ */ _interopDefaultCompat(parseHighlights);
const clsx__default = /* @__PURE__ */ _interopDefaultCompat(clsx);
const matchHighlights__default = /* @__PURE__ */ _interopDefaultCompat(matchHighlights);
const FocusLock__default = /* @__PURE__ */ _interopDefaultCompat(FocusLock);
const ThemeNameConsumer = ({ children }) => children(ToastContext.useThemeName());
const useColor = () => sideEffects_lib_components_BraidProvider_BraidProvider_cjs.useBraidTheme().color;
const useBreakpoint = () => {
  if (process.env.NODE_ENV !== "production") {
    console.warn(
      `'useBreakpoint' has been deprecated. Use 'useResponsiveValue' instead: https://seek-oss.github.io/braid-design-system/components/useResponsiveValue`
    );
  }
  return ToastContext.useResponsiveValue()({
    mobile: "mobile",
    tablet: "tablet",
    desktop: "desktop"
  });
};
const validTones$1 = ["neutral", "secondary"];
const AccordionContext = React.createContext(
  null
);
const validSpaceValues = ["medium", "large", "xlarge"];
const defaultSpaceForSize = {
  divided: {
    xsmall: "medium",
    small: "medium",
    standard: "medium",
    large: "large"
  },
  undivided: {
    xsmall: "large",
    small: "large",
    standard: "large",
    large: "large"
  }
};
const Accordion = ({
  children,
  size = "large",
  tone,
  weight,
  space: spaceProp,
  dividers = true,
  data,
  ...restProps
}) => {
  assert__default.default(
    spaceProp === void 0 || Object.values(styles_lib_css_atoms_sprinkles_css_cjs.normalizeResponsiveValue(spaceProp)).every(
      (value) => value === void 0 || validSpaceValues.includes(value)
    ),
    `To ensure adequate space for touch targets, 'space' prop values must be one of the following: ${validSpaceValues.map((x) => `"${x}"`).join(", ")}`
  );
  assert__default.default(
    tone === void 0 || validTones$1.includes(tone),
    `The 'tone' prop should be one of the following: ${validTones$1.map((x) => `"${x}"`).join(", ")}`
  );
  const contextValue = React.useMemo(
    () => ({ size, tone, weight }),
    [size, tone, weight]
  );
  const space = spaceProp ?? defaultSpaceForSize[dividers ? "divided" : "undivided"][size];
  return /* @__PURE__ */ jsxRuntime.jsx(AccordionContext.Provider, { value: contextValue, children: !dividers ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Stack, { space, data, children }) : /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }), children: [
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Divider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingY: space, children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Stack, { space, dividers: true, children }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Divider, {})
  ] }) });
};
const IconAddSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M18 11h-5V6c0-.6-.4-1-1-1s-1 .4-1 1v5H6c-.6 0-1 .4-1 1s.4 1 1 1h5v5c0 .6.4 1 1 1s1-.4 1-1v-5h5c.6 0 1-.4 1-1s-.4-1-1-1z" })
    ]
  }
);
const IconAdd = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconAddSvg, ...iconProps });
};
const IconArrowSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m11.293 4.293-7 7a1 1 0 1 0 1.414 1.414L11 7.414V19a1 1 0 1 0 2 0V7.414l5.293 5.293a1 1 0 1 0 1.414-1.414l-7-7a1 1 0 0 0-1.414 0Z" })
    ]
  }
);
const IconArrow = ({ direction = "up", ...props }) => {
  const { className, ...iconProps } = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: IconArrowSvg,
      className: [
        styles_lib_components_icons_IconArrow_IconArrow_css_cjs.root,
        className,
        {
          [styles_lib_components_icons_IconArrow_IconArrow_css_cjs.rotate]: direction === "right" || direction === "left",
          [styles_lib_components_icons_IconArrow_IconArrow_css_cjs.flip]: direction === "down",
          [styles_lib_components_icons_IconArrow_IconArrow_css_cjs.mirror]: direction === "left"
        }
      ],
      ...iconProps
    }
  );
};
const IconBookmarkSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 5.1c.1-1.6-1.1-2.9-2.7-3.1H7.6C6.1 2.1 4.9 3.5 5 5v16c0 .4.2.7.5.9.3.2.7.2 1 0l5.4-3.6 5.4 3.6c.2.1.4.2.6.2.2 0 .3 0 .5-.1.3-.2.5-.5.5-.9l.1-16zm-2 14-4.4-3c-.3-.2-.8-.2-1.1 0l-4.4 3L7 4.9c0-.4.3-.9.7-.9h8.5c.5 0 .8.5.8 1v14.1z" })
    ]
  }
);
const IconBookmarkActiveSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 5.1c.1-1.6-1.1-2.9-2.7-3.1H7.6C6.1 2.1 4.9 3.5 5 5v16c0 .4.2.7.5.9.3.2.7.2 1 0l5.4-3.6 5.4 3.6c.2.1.4.2.6.2.2 0 .3 0 .5-.1.3-.2.5-.5.5-.9l.1-16z" })
    ]
  }
);
const IconBookmark = ({
  active = false,
  ...props
}) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: active ? IconBookmarkActiveSvg : IconBookmarkSvg,
      ...iconProps
    }
  );
};
const IconCautionSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M22.71 17.262 14.738 3.71A3.183 3.183 0 0 0 12 2.013 3.183 3.183 0 0 0 9.262 3.71L1.29 17.262a3.152 3.152 0 0 0-.14 3.225A3.152 3.152 0 0 0 4 22h16a3.023 3.023 0 0 0 2.71-4.738ZM20 20H4c-1.1 0-1.544-.776-.986-1.724l7.972-13.552A1.232 1.232 0 0 1 12 4.013a1.232 1.232 0 0 1 1.014.71l7.972 13.553C21.544 19.224 21.1 20 20 20Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 12, cy: 17, r: 1 }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M11.978 14a1 1 0 0 0 1-1V9a1 1 0 0 0-2 0v4a1 1 0 0 0 1 1Z" })
    ]
  }
);
const IconCaution = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconCautionSvg, ...iconProps });
};
const IconChevronSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20.7 7.3c-.4-.4-1-.4-1.4 0L12 14.6 4.7 7.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l8 8c.2.2.5.3.7.3s.5-.1.7-.3l8-8c.4-.4.4-1 0-1.4z" })
    ]
  }
);
const IconChevron = ({
  direction = "down",
  ...props
}) => {
  const { className, ...iconProps } = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: IconChevronSvg,
      className: [
        styles_lib_components_icons_IconChevron_IconChevron_css_cjs.root,
        className,
        {
          [styles_lib_components_icons_IconChevron_IconChevron_css_cjs.up]: direction === "up",
          [styles_lib_components_icons_IconChevron_IconChevron_css_cjs.left]: direction === "left",
          [styles_lib_components_icons_IconChevron_IconChevron_css_cjs.right]: direction === "right"
        }
      ],
      ...iconProps
    }
  );
};
const IconCompanySvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M9 6h2v2H9zm4 0h2v2h-2zm-4 4h2v2H9zm4 0h2v2h-2zm-4 4h2v2H9zm4 0h2v2h-2z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M17 2.2V2c0-.6-.4-1-1-1H8c-.6 0-1 .4-1 1v.2C5.9 2.6 5 3.7 5 5v16c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V5c0-1.3-.9-2.4-2-2.8zM17 20h-3v-2h-4v2H7V5c0-.6.4-1 1-1h8c.6 0 1 .4 1 1v15z" })
    ]
  }
);
const IconCompany = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconCompanySvg, ...iconProps });
};
const IconComposeSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m22.3 1.9-.2-.2C20.9.5 19 .5 17.9 1.7l-7.6 7.6c-.1.1-.2.3-.3.5l-1 4c-.1.3 0 .7.3.9.2.2.4.3.7.3h.2l4-1c.2 0 .3-.1.5-.3l7.6-7.6c.6-.6.9-1.3.9-2.1s-.3-1.6-.9-2.1zm-8.8 10.2-2.1.5.5-2.1L17 5.4 18.6 7l-5.1 5.1zm7.4-7.4-.9.9L18.4 4l.9-.9c.4-.4 1-.4 1.4 0l.2.2c.2.2.3.4.3.7s-.1.5-.3.7z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 11c-.6 0-1 .4-1 1v6c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1V6c0-.6.4-1 1-1h6c.6 0 1-.4 1-1s-.4-1-1-1H6C4.3 3 3 4.3 3 6v12c0 1.7 1.3 3 3 3h12c1.7 0 3-1.3 3-3v-6c0-.6-.4-1-1-1z" })
    ]
  }
);
const IconCompose = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconComposeSvg, ...iconProps });
};
const IconCopySvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M14 7H6c-1.7 0-3 1.3-3 3v8c0 1.7 1.3 3 3 3h8c1.7 0 3-1.3 3-3v-8c0-1.7-1.3-3-3-3zm1 11c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1h8c.6 0 1 .4 1 1v8z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 2h-8C9.3 2 8 3.3 8 5h2c0-.6.4-1 1-1h8c.6 0 1 .4 1 1v8c0 .6-.4 1-1 1v2c1.7 0 3-1.3 3-3V5c0-1.7-1.3-3-3-3z" })
    ]
  }
);
const IconCopy = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconCopySvg, ...iconProps });
};
const IconCreditCardSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 4H4C2.3 4 1 5.3 1 7v10c0 1.7 1.3 3 3 3h16c1.7 0 3-1.3 3-3V7c0-1.7-1.3-3-3-3zM3 7c0-.6.4-1 1-1h16c.6 0 1 .4 1 1v1H3V7zm18 10c0 .6-.4 1-1 1H4c-.6 0-1-.4-1-1v-7h18v7z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M6 16h4c.6 0 1-.4 1-1s-.4-1-1-1H6c-.6 0-1 .4-1 1s.4 1 1 1z" })
    ]
  }
);
const IconCreditCard = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconCreditCardSvg, ...iconProps });
};
const IconDateSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 4h-2V3c0-.6-.4-1-1-1s-1 .4-1 1v1H9V3c0-.6-.4-1-1-1s-1 .4-1 1v1H5C3.3 4 2 5.3 2 7v12c0 1.7 1.3 3 3 3h14c1.7 0 3-1.3 3-3V7c0-1.7-1.3-3-3-3zM4 7c0-.6.4-1 1-1h2v1c0 .6.4 1 1 1s1-.4 1-1V6h6v1c0 .6.4 1 1 1s1-.4 1-1V6h2c.6 0 1 .4 1 1v3H4V7zm16 12c0 .6-.4 1-1 1H5c-.6 0-1-.4-1-1v-7h16v7z" })
    ]
  }
);
const IconDate = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconDateSvg, ...iconProps });
};
const IconDeleteSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M10 17c.6 0 1-.4 1-1v-6c0-.6-.4-1-1-1s-1 .4-1 1v6c0 .6.4 1 1 1zm4 0c.6 0 1-.4 1-1v-6c0-.6-.4-1-1-1s-1 .4-1 1v6c0 .6.4 1 1 1z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 4h-4V3c0-1.1-.9-2-2-2h-4c-1.1 0-2 .9-2 2v1H4c-.6 0-1 .4-1 1s.4 1 1 1v13c0 1.7 1.3 3 3 3h10c1.7 0 3-1.3 3-3V6c.6 0 1-.4 1-1s-.4-1-1-1zM10 3h4v1h-4V3zm8 16c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V6h12v13z" })
    ]
  }
);
const IconDelete = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconDeleteSvg, ...iconProps });
};
const IconDesktopSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19.2 2H4.8A2.908 2.908 0 0 0 2 5v10a2.908 2.908 0 0 0 2.8 3H11v2.005H8a1 1 0 0 0 0 2h8a1 1 0 0 0 0-2h-3V18h6.2a2.908 2.908 0 0 0 2.8-3V5a2.908 2.908 0 0 0-2.8-3Zm.8 13a.93.93 0 0 1-.8 1H4.8a.93.93 0 0 1-.8-1V5a.93.93 0 0 1 .8-1h14.4a.93.93 0 0 1 .8 1Z" })
    ]
  }
);
const IconDesktop = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconDesktopSvg, ...iconProps });
};
const IconDocumentSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m19.5 6.7-3.6-3.2-1.2-1.2c-.2-.2-.4-.3-.7-.3H5.8C4.8 2 4 3.1 4 4.5V20c-.1 1 .7 1.9 1.7 2H18c1 .1 1.9-.7 2-1.7V8c0-.5-.2-1-.5-1.3zM15 5.4 16.6 7H15V5.4zM7 20c-.6 0-1-.4-1-1V5c0-.6.4-1 1-1h6v4c0 .6.4 1 1 1h4v10c0 .6-.4 1-1 1H7z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M14 11H9c-.6 0-1 .4-1 1s.4 1 1 1h5c.6 0 1-.4 1-1s-.4-1-1-1zm-2 4H9c-.6 0-1 .4-1 1s.4 1 1 1h3c.6 0 1-.4 1-1s-.4-1-1-1z" })
    ]
  }
);
const IconDocument = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconDocumentSvg, ...iconProps });
};
const IconDocumentBrokenSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { fill: "none", d: "M15 5.414V7h1.586L15 5.414z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m19.707 7.293-5-5A1 1 0 0 0 14 2H7a3.003 3.003 0 0 0-3 3v14a3.003 3.003 0 0 0 3 3h5v-2H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h6v4a1 1 0 0 0 1 1h4v5h2V8a1 1 0 0 0-.293-.707ZM15 7V5.414L16.586 7Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19.707 16.293a1 1 0 0 0-1.414 0L17 17.586l-1.293-1.293a1 1 0 0 0-1.414 1.414L15.586 19l-1.293 1.293a1 1 0 1 0 1.414 1.414L17 20.414l1.293 1.293a1 1 0 0 0 1.414-1.414L18.414 19l1.293-1.293a1 1 0 0 0 0-1.414Z" })
    ]
  }
);
const IconDocumentBroken = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconDocumentBrokenSvg, ...iconProps });
};
const IconDownloadSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 16c-.6 0-1 .4-1 1v1c0 .6-.5 1-1.1 1H7.1c-.6 0-1-.5-1.1-1v-1c0-.6-.4-1-1-1s-1 .4-1 1v1c0 1.7 1.4 3 3 3h9.9c1.7 0 3.1-1.3 3.1-3v-1c0-.6-.4-1-1-1zm-7.7-1.3c.2.2.5.3.7.3s.5-.1.7-.3l5-5c.4-.4.4-1 0-1.4s-1-.4-1.4 0L13 11.6V4c0-.6-.4-1-1-1s-1 .4-1 1v7.6L7.7 8.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l5 5z" })
    ]
  }
);
const IconDownload = (props) => {
  const iconProps = ToastContext.useIcon(props, {
    verticalCorrection: {
      uppercase: "none",
      lowercase: "up"
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconDownloadSvg, ...iconProps });
};
const IconEditSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20.7 4.1c-1.4-1.4-4-1.4-5.4 0l-11 11c-.1.1-.2.3-.3.5l-1 5c-.1.3 0 .7.3.9.2.2.4.3.7.3h.2l5-1c.2 0 .4-.1.5-.3l11-11c1.5-1.5 1.5-3.9 0-5.4zM8.5 18.9l-3.2.6.6-3.2 8.6-8.6 2.6 2.6-8.6 8.6zM19.3 8.1l-.8.8-2.6-2.6.8-.8c.7-.7 1.9-.7 2.6 0 .7.7.7 1.9 0 2.6z" })
    ]
  }
);
const IconEdit = (props) => {
  const iconProps = ToastContext.useIcon(props, {
    verticalCorrection: {
      uppercase: "none",
      lowercase: "up"
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconEditSvg, ...iconProps });
};
const IconEducationSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 2H7C5.3 2 4 3.3 4 5v14c0 1.7 1.3 3 3 3h12c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1zM7 4h11v12H7c-.4 0-.7.1-1 .2V5c0-.6.4-1 1-1zm11 16H7c-.6 0-1-.4-1-1s.4-1 1-1h11v2z" })
    ]
  }
);
const IconEducation = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconEducationSvg, ...iconProps });
};
const IconEnlargeSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19.923 4.618A.999.999 0 0 0 19 4h-4a1 1 0 1 0 0 2h1.586l-3.293 3.293a1 1 0 1 0 1.414 1.414L18 7.414V9a1 1 0 1 0 2 0V5c0-.13-.026-.26-.077-.382Zm-10.63 8.675L6 16.586V15a1 1 0 1 0-2 0v4a1 1 0 0 0 .618.923A1 1 0 0 0 5 20h4a1 1 0 1 0 0-2H7.414l3.293-3.293a1 1 0 1 0-1.414-1.414Z" })
    ]
  }
);
const IconEnlargeActiveSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M10.382 13.077A1 1 0 0 0 10 13H6a1 1 0 1 0 0 2h1.586l-3.293 3.293a1 1 0 1 0 1.414 1.414L9 16.414V18a1 1 0 1 0 2 0v-4a.999.999 0 0 0-.618-.923Zm9.325-8.784a1 1 0 0 0-1.414 0L15 7.586V6a1 1 0 1 0-2 0v4a1 1 0 0 0 .618.923A1 1 0 0 0 14 11h4a1 1 0 1 0 0-2h-1.586l3.293-3.293a1 1 0 0 0 0-1.414Z" })
    ]
  }
);
const IconEnlarge = ({ active = false, ...props }) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: active ? IconEnlargeActiveSvg : IconEnlargeSvg,
      ...iconProps
    }
  );
};
const IconFilterSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M6 9.2V5c0-.6-.4-1-1-1s-1 .4-1 1v4.2c-1.2.4-2 1.5-2 2.8 0 1.3.9 2.4 2 2.8V19c0 .6.4 1 1 1s1-.4 1-1v-4.2c1.2-.4 2-1.5 2-2.8 0-1.3-.8-2.4-2-2.8zM5 13c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1-.4 1-1 1zm8 1.2V5c0-.6-.4-1-1-1s-1 .4-1 1v9.2c-1.2.4-2 1.5-2 2.8 0 1.7 1.3 3 3 3s3-1.3 3-3c0-1.3-.9-2.4-2-2.8zM12 18c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1-.4 1-1 1zM22 7c0-1.7-1.3-3-3-3s-3 1.3-3 3c0 1.3.9 2.4 2 2.8V19c0 .6.4 1 1 1s1-.4 1-1V9.8c1.1-.4 2-1.5 2-2.8zm-3 1c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1-.4 1-1 1z" })
    ]
  }
);
const IconFilter = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconFilterSvg, ...iconProps });
};
const IconFlagSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19.41 2.967a1.031 1.031 0 0 0-1.08.148 4.778 4.778 0 0 1-2.83.599 8.47 8.47 0 0 1-3.135-.788A10.177 10.177 0 0 0 8.5 2c-2.887 0-4.005.952-4.2 1.144a1 1 0 0 0-.3.713V21a1 1 0 0 0 2 0v-6.298a6.167 6.167 0 0 1 2.5-.416 8.47 8.47 0 0 1 3.135.788A10.177 10.177 0 0 0 15.5 16c2.887 0 4.005-.952 4.2-1.144a1 1 0 0 0 .3-.713V3.857a.996.996 0 0 0-.59-.89ZM18 13.584a6.174 6.174 0 0 1-2.5.416 8.47 8.47 0 0 1-3.135-.788 10.178 10.178 0 0 0-3.865-.926 9.467 9.467 0 0 0-2.5.298V4.416A6.174 6.174 0 0 1 8.5 4a8.47 8.47 0 0 1 3.135.788 10.178 10.178 0 0 0 3.865.926 9.467 9.467 0 0 0 2.5-.298Z" })
    ]
  }
);
const IconFlag = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconFlagSvg, ...iconProps });
};
const IconGridSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M8 3H6C4.3 3 3 4.3 3 6v2c0 1.7 1.3 3 3 3h2c1.7 0 3-1.3 3-3V6c0-1.7-1.3-3-3-3zm1 5c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1V6c0-.6.4-1 1-1h2c.6 0 1 .4 1 1v2zm-1 5H6c-1.7 0-3 1.3-3 3v2c0 1.7 1.3 3 3 3h2c1.7 0 3-1.3 3-3v-2c0-1.7-1.3-3-3-3zm1 5c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-2c0-.6.4-1 1-1h2c.6 0 1 .4 1 1v2zm9-15h-2c-1.7 0-3 1.3-3 3v2c0 1.7 1.3 3 3 3h2c1.7 0 3-1.3 3-3V6c0-1.7-1.3-3-3-3zm1 5c0 .6-.4 1-1 1h-2c-.6 0-1-.4-1-1V6c0-.6.4-1 1-1h2c.6 0 1 .4 1 1v2zm-1 5h-2c-1.7 0-3 1.3-3 3v2c0 1.7 1.3 3 3 3h2c1.7 0 3-1.3 3-3v-2c0-1.7-1.3-3-3-3zm1 5c0 .6-.4 1-1 1h-2c-.6 0-1-.4-1-1v-2c0-.6.4-1 1-1h2c.6 0 1 .4 1 1v2z" })
    ]
  }
);
const IconGrid = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconGridSvg, ...iconProps });
};
const IconHeartSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M15.7 4c-.1 0-.1 0 0 0-1.4 0-2.7.5-3.7 1.3C11 4.5 9.7 4 8.4 4 5.5 4 3 6.3 3 9.3c0 4 5 8.9 8.6 10.6.1.1.3.1.4.1s.3 0 .4-.1C16 18.2 21 13.3 21 9.3c0-3-2.4-5.3-5.3-5.3zM12 17.9c-3-1.6-7-5.7-7-8.6C5 7.5 6.5 6 8.4 6h.1c1.1 0 2.1.5 2.8 1.4.4.5 1.2.5 1.6 0 .6-.9 1.6-1.4 2.7-1.4C17.5 6 19 7.5 19 9.3c0 2.9-4 7-7 8.6z" })
    ]
  }
);
const IconHeartActiveSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M15.7 4c-.1 0-.1 0 0 0-1.4 0-2.7.5-3.7 1.3C11 4.5 9.7 4 8.4 4 5.5 4 3 6.3 3 9.3c0 4 5 8.9 8.6 10.6.1.1.3.1.4.1s.3 0 .4-.1C16 18.2 21 13.3 21 9.3c0-3-2.4-5.3-5.3-5.3z" })
    ]
  }
);
const IconHeart = ({ active = false, ...props }) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: active ? IconHeartActiveSvg : IconHeartSvg,
      ...iconProps
    }
  );
};
const IconHelpSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 1C5.9 1 1 5.9 1 12s4.9 11 11 11 11-4.9 11-11S18.1 1 12 1zm0 20c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12.7 16.3c-.4-.4-1.1-.4-1.4 0-.1.1-.2.2-.2.3 0 .1-.1.2-.1.4 0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3c.1-.1.2-.2.2-.3 0-.1.1-.2.1-.4s0-.3-.1-.4c0-.1-.1-.2-.2-.3zm.6-10.1c-2-.7-4.3.4-5.1 2.5-.2.5.1 1 .6 1.2.5.2 1.1-.1 1.3-.6.4-1 1.5-1.6 2.6-1.2.8.3 1.3 1 1.3 1.9 0 .5-.3.7-1.3 1.2-.7.3-1.7.8-1.7 1.8 0 .6.4 1 1 1 .5 0 .9-.3 1-.7.1-.1.4-.2.6-.3.9-.4 2.5-1.2 2.5-3-.1-1.7-1.2-3.2-2.8-3.8z" })
    ]
  }
);
const IconHelp = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconHelpSvg, ...iconProps });
};
const IconHistorySvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 6c-.6 0-1 .4-1 1v5c0 .4.2.7.6.9l4 2c.1.1.2.1.4.1.4 0 .7-.2.9-.6.2-.5 0-1.1-.4-1.3L13 11.4V7c0-.6-.4-1-1-1z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19.1 4.9C15.2 1 8.8 1 4.9 4.9 3.3 6.6 2.3 8.7 2 11H1c-.4 0-.8.2-.9.6-.2.4-.1.8.2 1.1l2 2c.2.2.4.3.7.3s.5-.1.7-.3l2-2c.3-.3.4-.7.2-1.1-.1-.4-.5-.6-.9-.6h-.9c.2-1.8 1-3.4 2.3-4.7 3.1-3.1 8.2-3.1 11.3 0 3.1 3.1 3.1 8.2 0 11.3-3.1 3.1-8.2 3.1-11.3 0-.4-.4-1-.4-1.4 0s-.4 1 0 1.4c1.9 2 4.4 3 7 3 2.6 0 5.1-1 7.1-2.9 3.9-3.9 3.9-10.3 0-14.2z" })
    ]
  }
);
const IconHistory = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconHistorySvg, ...iconProps });
};
const IconHomeSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m20.7 9.2-8-7c-.4-.3-.9-.3-1.3 0l-8 7c-.3.2-.4.5-.4.8v11c0 .6.4 1 1 1h16c.6 0 1-.4 1-1V10c0-.3-.1-.6-.3-.8zM19 20h-5v-4c0-.6-.4-1-1-1h-2c-.6 0-1 .4-1 1v4H5v-9.5l7-6.1 7 6.1V20z" })
    ]
  }
);
const IconHome = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconHomeSvg, ...iconProps });
};
const IconImageSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 2H5C3.3 2 2 3.3 2 5v14c0 1.7 1.3 3 3 3h14c1.7 0 3-1.3 3-3V5c0-1.7-1.3-3-3-3zM4 5c0-.6.4-1 1-1h14c.6 0 1 .4 1 1v7.6L17.4 10c-.8-.8-2.1-.8-2.8 0l-9.9 9.9c-.4-.1-.7-.5-.7-.9V5zm15 15H7.4l8.6-8.6 4 4V19c0 .6-.4 1-1 1z" }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 8, cy: 8, r: 2 })
    ]
  }
);
const IconImage = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconImageSvg, ...iconProps });
};
const IconInfoSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 1C5.9 1 1 5.9 1 12s4.9 11 11 11 11-4.9 11-11S18.1 1 12 1zm0 20c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 11c-.6 0-1 .4-1 1v4c0 .6.4 1 1 1s1-.4 1-1v-4c0-.6-.4-1-1-1zm.9-3.4c0-.1-.1-.1-.1-.2s-.1-.1-.1-.1c-.3-.3-.7-.4-1.1-.2-.1.1-.2.1-.3.2l-.1.1c0 .1-.1.1-.1.2s0 .1-.1.2V8c0 .3.1.5.3.7.1.1.2.2.3.2.1.1.3.1.4.1h.2c.1 0 .1 0 .2-.1.1 0 .1-.1.2-.1l.1-.1c.2-.2.3-.4.3-.7v-.2c0-.1-.1-.1-.1-.2z" })
    ]
  }
);
const IconInfo = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconInfoSvg, ...iconProps });
};
const IconInvoiceSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 2H4c-.6 0-1 .4-1 1v18c0 .3.2.7.5.9.3.2.7.2 1 0l1.5-.8 1.6.8c.3.1.6.1.9 0l1.6-.8 1.6.8c.3.1.6.1.9 0l1.6-.8 1.6.8c.3.1.6.1.9 0l1.6-.8 1.6.8c-.2.1-.1.1.1.1s.4 0 .5-.1c.3-.2.5-.5.5-.9V3c0-.6-.4-1-1-1zm-1 17.4-.6-.3c-.3-.1-.6-.1-.9 0l-1.5.8-1.6-.8c-.1-.1-.2-.1-.4-.1s-.3 0-.4.1l-1.6.8-1.6-.8c-.3-.1-.6-.1-.9 0l-1.5.8-1.6-.8c-.3-.1-.6-.1-.9 0l-.5.3V4h14v15.4z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M8 12h8c.6 0 1-.4 1-1s-.4-1-1-1H8c-.6 0-1 .4-1 1s.4 1 1 1zm0-4h8c.6 0 1-.4 1-1s-.4-1-1-1H8c-.6 0-1 .4-1 1s.4 1 1 1zm8 6h-3c-.6 0-1 .4-1 1s.4 1 1 1h3c.6 0 1-.4 1-1s-.4-1-1-1z" })
    ]
  }
);
const IconInvoice = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconInvoiceSvg, ...iconProps });
};
const IconLanguageSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20.784 18.593a10.917 10.917 0 0 0 0-13.186.995.995 0 0 0-.094-.126 10.96 10.96 0 0 0-17.38 0 .99.99 0 0 0-.094.126 10.917 10.917 0 0 0 0 13.186.988.988 0 0 0 .094.126 10.96 10.96 0 0 0 17.38 0 .993.993 0 0 0 .094-.126ZM4.522 7h2.922a14.936 14.936 0 0 0-.902 4H3.06a8.942 8.942 0 0 1 1.463-4Zm12.936 4a14.936 14.936 0 0 0-.902-4h2.922a8.942 8.942 0 0 1 1.463 4ZM4.522 17a8.942 8.942 0 0 1-1.463-4h3.483a14.936 14.936 0 0 0 .902 4Zm4.028-4h6.9a13.453 13.453 0 0 1-1.058 4H9.608a13.453 13.453 0 0 1-1.058-4Zm0-2a13.453 13.453 0 0 1 1.058-4h4.784a13.453 13.453 0 0 1 1.058 4Zm7.12-6a20.175 20.175 0 0 0-.882-1.553A8.988 8.988 0 0 1 17.645 5ZM12 3l.028.001A17.948 17.948 0 0 1 13.382 5h-2.764a17.948 17.948 0 0 1 1.354-1.999ZM8.33 5H6.355a8.988 8.988 0 0 1 2.857-1.553c-.287.456-.587.977-.882 1.553Zm0 14c.295.576.595 1.097.882 1.553A8.988 8.988 0 0 1 6.355 19ZM12 21l-.028-.001A17.948 17.948 0 0 1 10.618 19h2.764a17.948 17.948 0 0 1-1.354 1.999Zm3.67-2h1.975a8.988 8.988 0 0 1-2.857 1.553c.287-.456.587-.977.882-1.553Zm.886-2a14.936 14.936 0 0 0 .902-4h3.483a8.942 8.942 0 0 1-1.463 4Z" })
    ]
  }
);
const IconLanguage = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconLanguageSvg, ...iconProps });
};
const IconLinkSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12.848 17.334a6.214 6.214 0 0 1-1.476-.2L9.44 19.066a3.188 3.188 0 1 1-4.51-4.508l2.962-2.961a3.208 3.208 0 0 1 4.509 0 1 1 0 1 0 1.414-1.414 5.205 5.205 0 0 0-6.832-.413 5.102 5.102 0 0 0-.505.413l-2.961 2.96a5.188 5.188 0 0 0 7.337 7.337l3.293-3.293a6.226 6.226 0 0 1-1.3.147Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M11.15 6.664a6.214 6.214 0 0 1 1.476.2l1.932-1.932a3.188 3.188 0 1 1 4.508 4.508l-2.96 2.961a3.208 3.208 0 0 1-4.51 0 1 1 0 0 0-1.413 1.414 5.205 5.205 0 0 0 6.831.413 5.101 5.101 0 0 0 .506-.413l2.96-2.96a5.188 5.188 0 0 0-7.336-7.337L9.85 6.812a6.226 6.226 0 0 1 1.298-.148Z" })
    ]
  }
);
const IconLink = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconLinkSvg, ...iconProps });
};
const IconLinkBrokenSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12.848 17.334a6.214 6.214 0 0 1-1.476-.2L9.44 19.066a3.188 3.188 0 1 1-4.51-4.508l2.962-2.961a3.208 3.208 0 0 1 4.509 0 1 1 0 1 0 1.414-1.414 5.205 5.205 0 0 0-6.832-.413 5.102 5.102 0 0 0-.505.413l-2.961 2.96a5.188 5.188 0 0 0 7.337 7.337l3.293-3.293a6.226 6.226 0 0 1-1.3.147Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M11.15 6.664a6.214 6.214 0 0 1 1.476.2l1.932-1.932a3.188 3.188 0 1 1 4.508 4.508l-2.96 2.961a3.208 3.208 0 0 1-4.51 0 1 1 0 0 0-1.413 1.414 5.205 5.205 0 0 0 6.831.413 5.101 5.101 0 0 0 .506-.413l2.96-2.96a5.188 5.188 0 0 0-7.336-7.337L9.85 6.812a6.226 6.226 0 0 1 1.298-.148Zm-5.736-.25a.997.997 0 0 1-.707-.293L3.293 4.707a1 1 0 0 1 1.414-1.414l1.414 1.414a1 1 0 0 1-.707 1.707ZM3.736 9.321a.994.994 0 0 1-.26-.034l-1.93-.517a1 1 0 0 1 .518-1.932l1.931.517a1 1 0 0 1-.258 1.966ZM8.32 4.735a.999.999 0 0 1-.965-.74l-.517-1.933a1 1 0 0 1 1.932-.517l.517 1.932a1 1 0 0 1-.967 1.258Z" })
    ]
  }
);
const IconLinkBroken = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconLinkBrokenSvg, ...iconProps });
};
const IconListSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M9 8h10c.6 0 1-.4 1-1s-.4-1-1-1H9c-.6 0-1 .4-1 1s.4 1 1 1zm10 3H9c-.6 0-1 .4-1 1s.4 1 1 1h10c.6 0 1-.4 1-1s-.4-1-1-1zm0 5H9c-.6 0-1 .4-1 1s.4 1 1 1h10c.6 0 1-.4 1-1s-.4-1-1-1z" }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 5, cy: 7, r: 1 }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 5, cy: 12, r: 1 }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 5, cy: 17, r: 1 })
    ]
  }
);
const IconList = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconListSvg, ...iconProps });
};
const IconLocationSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 1C7.6 1 4 4.6 4 9c0 4.1 6.5 12.6 7.2 13.6.2.2.5.4.8.4s.6-.1.8-.4c.7-1 7.2-9.5 7.2-13.6 0-4.4-3.6-8-8-8zm0 19.3c-2.2-3-6-8.8-6-11.3 0-3.3 2.7-6 6-6s6 2.7 6 6c0 2.5-3.8 8.3-6 11.3z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 5c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm0 4c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1-.4 1-1 1z" })
    ]
  }
);
const IconLocation = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconLocationSvg, ...iconProps });
};
const IconMailSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M22 6.8C21.9 5.2 20.6 4 19 4H5C3.4 4 2.1 5.2 2 6.8V17c0 1.7 1.3 3 3 3h14c1.7 0 3-1.3 3-3V6.8zM5 6h14c.4 0 .7.2.9.5L12 11.8 4.1 6.5c.2-.3.5-.5.9-.5zm14 12H5c-.6 0-1-.4-1-1V8.9l7.4 5c.2.1.4.2.6.2s.4-.1.6-.2l7.4-5V17c0 .6-.4 1-1 1z" })
    ]
  }
);
const IconMail = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconMailSvg, ...iconProps });
};
const IconMessageSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M12 3a9 9 0 0 0-7.605 13.815L3 21l4.909-.982A9 9 0 1 0 12 3Z",
          fill: "none",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: 2
        }
      )
    ]
  }
);
const IconMessage = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconMessageSvg, ...iconProps });
};
const IconMinusSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M18 11H6c-.6 0-1 .4-1 1s.4 1 1 1h12c.6 0 1-.4 1-1s-.4-1-1-1z" })
    ]
  }
);
const IconMinus = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconMinusSvg, ...iconProps });
};
const IconMobileSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12.71 16.29a1.047 1.047 0 0 0-1.42 0 1.029 1.029 0 0 0-.21.33.832.832 0 0 0-.08.38.951.951 0 0 0 .29.7.96.96 0 0 0 .71.3 1 1 0 0 0 .38-.08 1.012 1.012 0 0 0 .33-.22.955.955 0 0 0 .29-.7 1 1 0 0 0-.08-.38 1.029 1.029 0 0 0-.21-.33Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M16.286 2H7.714A2.761 2.761 0 0 0 5 4.8v14.4A2.761 2.761 0 0 0 7.714 22h8.572A2.761 2.761 0 0 0 19 19.2V4.8A2.761 2.761 0 0 0 16.286 2ZM17 19.2a.761.761 0 0 1-.714.8H7.714A.761.761 0 0 1 7 19.2V4.8a.761.761 0 0 1 .714-.8h8.572a.761.761 0 0 1 .714.8Z" })
    ]
  }
);
const IconMobile = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconMobileSvg, ...iconProps });
};
const IconMoneySvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M17 15.5c0-1.6-1.3-4.3-4.9-4.5-3-.2-3.1-2.5-3.1-2.5 0-.7.3-1.3.8-1.7.6-.5 1.4-.8 2.2-.8.8 0 1.6.3 2.2.8.4.4 1.1.3 1.4-.1.4-.4.3-1.1-.1-1.4-.7-.6-1.6-1-2.5-1.2V3c0-.6-.4-1-1-1s-1 .4-1 1v1.1c-.9.2-1.7.5-2.5 1.2C7.6 6.1 7 7.2 7 8.5c0 1.6 1.3 4.3 4.9 4.5 3 .2 3.1 2.5 3.1 2.5 0 .7-.3 1.3-.8 1.7-.6.5-1.4.8-2.2.8-.8 0-1.6-.3-2.2-.8-.4-.4-1.1-.3-1.4.1-.4.4-.3 1.1.1 1.4.7.6 1.6 1 2.5 1.2V21c0 .6.4 1 1 1s1-.4 1-1v-1.1c.9-.2 1.7-.5 2.5-1.2.9-.8 1.5-1.9 1.5-3.2z" })
    ]
  }
);
const IconMoney = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconMoneySvg, ...iconProps });
};
const IconNewWindowSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 11c-.6 0-1 .4-1 1v5c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V7c0-.6.4-1 1-1h5c.6 0 1-.4 1-1s-.4-1-1-1H7C5.3 4 4 5.3 4 7v10c0 1.7 1.3 3 3 3h10c1.7 0 3-1.3 3-3v-5c0-.6-.4-1-1-1z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M21 3v-.4l-.1-.1c0-.1-.1-.1-.1-.2 0 0-.1 0-.1-.1-.1 0-.1-.1-.2-.1h-4.3c-.6 0-1 .4-1 1s.4 1 1 1H18l-6.5 7.3c-.4.4-.3 1 .1 1.4.2.2.4.3.7.3.3 0 .6-.1.7-.3l6.3-7V7c0 .6.4 1 1 1s1-.4 1-1L21 3z" })
    ]
  }
);
const IconNewWindow = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconNewWindowSvg, ...iconProps });
};
const IconNoteSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M13 11H8c-.6 0-1 .4-1 1s.4 1 1 1h5c.6 0 1-.4 1-1s-.4-1-1-1zm-2 4H8c-.6 0-1 .4-1 1s.4 1 1 1h3c.6 0 1-.4 1-1s-.4-1-1-1z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20.9 8.6c-.1-.1-.1-.2-.2-.3l-5-5c-.1-.1-.2-.2-.3-.2-.1-.1-.3-.1-.4-.1H6C4.3 3 3 4.3 3 6v12c0 1.7 1.3 3 3 3h12c1.7 0 3-1.3 3-3V9c0-.1 0-.3-.1-.4zM16 6.4 17.6 8H16V6.4zM18 19H6c-.6 0-1-.4-1-1V6c0-.6.4-1 1-1h8v4c0 .6.4 1 1 1h4v8c0 .6-.4 1-1 1z" })
    ]
  }
);
const IconNote = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconNoteSvg, ...iconProps });
};
const IconNotificationSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 16v-6a8.018 8.018 0 0 0-5.45-7.577 2.996 2.996 0 0 0-5.1 0A8.018 8.018 0 0 0 4 10v6a1 1 0 0 0 0 2h16a1 1 0 0 0 0-2ZM6 16v-6a6.008 6.008 0 0 1 4.411-5.78 1.001 1.001 0 0 0 .663-.591.996.996 0 0 1 1.852 0 1.001 1.001 0 0 0 .663.592A6.008 6.008 0 0 1 18 10v6Zm6 6a2.991 2.991 0 0 0 2.816-2H9.184A2.991 2.991 0 0 0 12 22Z" })
    ]
  }
);
const IconNotification = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconNotificationSvg, ...iconProps });
};
const IconOverflowSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 12, cy: 4, r: 2 }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 12, cy: 20, r: 2 }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 12, cy: 12, r: 2 })
    ]
  }
);
const IconOverflow = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconOverflowSvg, ...iconProps });
};
const IconPeopleSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M14.772 4.023c.076-.006.15-.023.228-.023a3 3 0 0 1 0 6c-.078 0-.152-.017-.228-.023a6.529 6.529 0 0 1-1.325 1.751A4.934 4.934 0 0 0 15 12a5 5 0 0 0 0-10 4.934 4.934 0 0 0-1.553.272 6.529 6.529 0 0 1 1.325 1.751ZM17 14h-1.853a6.54 6.54 0 0 1 1.613 2H17a3.003 3.003 0 0 1 3 3v2a1 1 0 0 0 2 0v-2a5.006 5.006 0 0 0-5-5Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M9 12a5 5 0 1 1 5-5 5.006 5.006 0 0 1-5 5Zm0-8a3 3 0 1 0 3 3 3.003 3.003 0 0 0-3-3Zm6 18a1 1 0 0 1-1-1v-2a3.003 3.003 0 0 0-3-3H7a3.003 3.003 0 0 0-3 3v2a1 1 0 0 1-2 0v-2a5.006 5.006 0 0 1 5-5h4a5.006 5.006 0 0 1 5 5v2a1 1 0 0 1-1 1Z" })
    ]
  }
);
const IconPeople = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPeopleSvg, ...iconProps });
};
const IconPersonAddSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M9 12a5 5 0 1 0-5-5 5.006 5.006 0 0 0 5 5Zm0-8a3 3 0 1 1-3 3 3.003 3.003 0 0 1 3-3Zm12 7h-2V9a1 1 0 0 0-2 0v2h-2a1 1 0 0 0 0 2h2v2a1 1 0 0 0 2 0v-2h2a1 1 0 0 0 0-2Zm-10 3H7a5.006 5.006 0 0 0-5 5v2a1 1 0 0 0 2 0v-2a3.003 3.003 0 0 1 3-3h4a3.003 3.003 0 0 1 3 3v2a1 1 0 0 0 2 0v-2a5.006 5.006 0 0 0-5-5Z" })
    ]
  }
);
const IconPersonAdd = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPersonAddSvg, ...iconProps });
};
const IconPersonVerifiedSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m20.4 4.1-8-3c-.2-.1-.5-.1-.7 0l-8 3c-.4.1-.7.5-.7.9v7c0 6.5 8.2 10.7 8.6 10.9.1.1.2.1.4.1s.3 0 .4-.1c.4-.2 8.6-4.4 8.6-10.9V5c0-.4-.3-.8-.6-.9zM19 12c0 4.5-5.4 7.9-7 8.9-1.6-.9-7-4.3-7-8.9V5.7l7-2.6 7 2.6V12z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M9.7 11.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l2 2c.2.2.5.3.7.3s.5-.1.7-.3l4-4c.4-.4.4-1 0-1.4s-1-.4-1.4 0L11 12.6l-1.3-1.3z" })
    ]
  }
);
const IconPersonVerified = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPersonVerifiedSvg, ...iconProps });
};
const IconPhoneSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M18.338 20.999a2.45 2.45 0 0 1-.292-.017A17.205 17.205 0 0 1 3.018 5.954a2.63 2.63 0 0 1 .655-2.047A2.723 2.723 0 0 1 5.699 3h3.29a1 1 0 0 1 .894.553l1.694 3.387a1 1 0 0 1-.062 1.002l-1.33 1.995a14.439 14.439 0 0 0 3.754 3.792l1.119-1.119a1.003 1.003 0 0 1 1.078-.221l4.235 1.694a1 1 0 0 1 .629.929V18.3a2.723 2.723 0 0 1-.907 2.026 2.641 2.641 0 0 1-1.755.672ZM5.699 5a.717.717 0 0 0-.534.24.63.63 0 0 0-.161.488 15.191 15.191 0 0 0 13.268 13.268.65.65 0 0 0 .489-.161.717.717 0 0 0 .239-.534v-2.613l-2.994-1.197-1.229 1.228a.998.998 0 0 1-1.236.141 16.495 16.495 0 0 1-5.402-5.403.998.998 0 0 1 .017-1.082l1.372-2.059L8.37 5Z" })
    ]
  }
);
const IconPhone = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPhoneSvg, ...iconProps });
};
const IconPlatformAndroidSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m17.09 10.255 1.674-2.891a.577.577 0 0 0-.237-.773.58.58 0 0 0-.754.2l-1.71 2.945a10.42 10.42 0 0 0-8.127 0L6.227 6.791a.584.584 0 0 0-.79-.182.58.58 0 0 0-.2.755l1.672 2.89A9.8 9.8 0 0 0 2 18h20a9.8 9.8 0 0 0-4.91-7.745ZM7.456 15.5a1.137 1.137 0 1 1 0-2.274 1.137 1.137 0 0 1 0 2.274Zm9.09 0a1.137 1.137 0 1 1 .001-2.274 1.137 1.137 0 0 1 0 2.274Z" })
    ]
  }
);
const IconPlatformAndroid = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPlatformAndroidSvg, ...iconProps });
};
const IconPlatformAppleSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M17.957 8.241c-.104.081-1.948 1.12-1.948 3.43 0 2.67 2.346 3.616 2.416 3.64-.01.057-.373 1.294-1.237 2.554-.77 1.109-1.575 2.216-2.799 2.216s-1.54-.711-2.952-.711c-1.377 0-1.867.734-2.987.734s-1.9-1.026-2.799-2.286c-1.04-1.48-1.881-3.779-1.881-5.96 0-3.5 2.275-5.356 4.515-5.356 1.19 0 2.181.781 2.929.781.71 0 1.82-.828 3.173-.828.513 0 2.357.047 3.57 1.786Zm-4.212-3.267c.56-.665.955-1.586.955-2.508 0-.128-.01-.257-.034-.362-.91.034-1.994.607-2.648 1.365-.513.583-.992 1.505-.992 2.439 0 .14.024.28.035.326.057.01.15.023.244.023.818 0 1.846-.547 2.44-1.283Z" })
    ]
  }
);
const IconPlatformApple = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPlatformAppleSvg, ...iconProps });
};
const IconPrintSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 8h-1V3c0-.6-.4-1-1-1H7c-.6 0-1 .4-1 1v5H5c-1.7 0-3 1.3-3 3v4c0 1.7 1.3 3 3 3v3c0 .6.4 1 1 1h12c.6 0 1-.4 1-1v-3c1.7 0 3-1.3 3-3v-4c0-1.7-1.3-3-3-3zM8 4h8v4H8V4zm9 16H7v-4h10v4zm3-5c0 .6-.4 1-1 1v-1c0-.6-.4-1-1-1H6c-.6 0-1 .4-1 1v1c-.6 0-1-.4-1-1v-4c0-.6.4-1 1-1h14c.6 0 1 .4 1 1v4z" })
    ]
  }
);
const IconPrint = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPrintSvg, ...iconProps });
};
const IconProfileSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 12a5 5 0 1 1 5-5 5.006 5.006 0 0 1-5 5Zm0-8a3 3 0 1 0 3 3 3.003 3.003 0 0 0-3-3Zm6 18a1 1 0 0 1-1-1v-2a3.003 3.003 0 0 0-3-3h-4a3.003 3.003 0 0 0-3 3v2a1 1 0 0 1-2 0v-2a5.006 5.006 0 0 1 5-5h4a5.006 5.006 0 0 1 5 5v2a1 1 0 0 1-1 1Z" })
    ]
  }
);
const IconProfile = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconProfileSvg, ...iconProps });
};
const IconPromoteSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M6 10h1c.6 0 1-.4 1-1s-.4-1-1-1H6V7c0-.6-.4-1-1-1s-1 .4-1 1v1H3c-.6 0-1 .4-1 1s.4 1 1 1h1v1c0 .6.4 1 1 1s1-.4 1-1v-1zm5 8h-1v-1c0-.6-.4-1-1-1s-1 .4-1 1v1H7c-.6 0-1 .4-1 1s.4 1 1 1h1v1c0 .6.4 1 1 1s1-.4 1-1v-1h1c.6 0 1-.4 1-1s-.4-1-1-1zm10-7c-2.2 0-4-3.2-4-7 0-.6-.4-1-1-1s-1 .4-1 1c0 3.8-1.8 7-4 7-.6 0-1 .4-1 1s.4 1 1 1c2.2 0 4 3.2 4 7 0 .6.4 1 1 1s1-.4 1-1c0-3.8 1.8-7 4-7 .6 0 1-.4 1-1s-.4-1-1-1zm-5 4c-.6-1.3-1.3-2.3-2.2-3 .9-.7 1.7-1.7 2.2-3 .6 1.3 1.3 2.3 2.2 3-.9.7-1.6 1.7-2.2 3z" })
    ]
  }
);
const IconPromote = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconPromoteSvg, ...iconProps });
};
const IconRecommendedSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19 8c0-3.9-3.1-7-7-7S5 4.1 5 8c0 2 .8 3.8 2.2 5.1L6 21.9c-.1.4.1.8.4 1 .3.2.7.2 1.1 0l4.5-2.7 4.5 2.7c.1.1.3.1.5.1s.4-.1.5-.2c.3-.2.5-.6.4-1L16.7 13c1.5-1.2 2.3-3 2.3-5zM7 8c0-2.8 2.2-5 5-5s5 2.2 5 5-2.2 5-5 5-5-2.2-5-5zm8.7 12.1-3.2-1.9c-.3-.2-.7-.2-1 0l-3.2 1.9.7-5.8c.9.4 1.9.7 3 .7s2.1-.2 3-.7l.7 5.8z" })
    ]
  }
);
const IconRecommended = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconRecommendedSvg, ...iconProps });
};
const IconRefreshSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M23.607 10.29a1 1 0 0 0-1.414 0l-.304.304A9.995 9.995 0 1 0 12 22a1 1 0 0 0 0-2 8 8 0 1 1 7.86-9.457l-.253-.253a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l2-2a1 1 0 0 0 0-1.414Z" })
    ]
  }
);
const IconRefresh = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconRefreshSvg, ...iconProps });
};
const IconResumeSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M17 2H7C5.3 2 4 3.3 4 5v14c0 1.7 1.3 3 3 3h10c1.7 0 3-1.3 3-3V5c0-1.7-1.3-3-3-3zm1 17c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V5c0-.6.4-1 1-1h10c.6 0 1 .4 1 1v14z" }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 10, cy: 8, r: 2 }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M15 12H9c-.6 0-1 .4-1 1s.4 1 1 1h6c.6 0 1-.4 1-1s-.4-1-1-1zm-2 4H9c-.6 0-1 .4-1 1s.4 1 1 1h4c.6 0 1-.4 1-1s-.4-1-1-1z" })
    ]
  }
);
const IconResume = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconResumeSvg, ...iconProps });
};
const IconSearchSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M21.7 20.3 18 16.6c1.2-1.5 2-3.5 2-5.6 0-5-4-9-9-9s-9 4-9 9 4 9 9 9c2.1 0 4.1-.7 5.6-2l3.7 3.7c.2.2.5.3.7.3s.5-.1.7-.3c.4-.4.4-1 0-1.4zM4 11c0-3.9 3.1-7 7-7s7 3.1 7 7c0 1.9-.8 3.7-2 4.9-1.3 1.3-3 2-4.9 2-4 .1-7.1-3-7.1-6.9z" })
    ]
  }
);
const IconSearch = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSearchSvg, ...iconProps });
};
const IconSecuritySvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M17 10V7c0-2.8-2.2-5-5-5S7 4.2 7 7v3c-1.7 0-3 1.3-3 3v6c0 1.7 1.3 3 3 3h10c1.7 0 3-1.3 3-3v-6c0-1.7-1.3-3-3-3zM9 7c0-1.7 1.3-3 3-3s3 1.3 3 3v3H9V7zm9 12c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1v-6c0-.6.4-1 1-1h10c.6 0 1 .4 1 1v6z" })
    ]
  }
);
const IconSecurity = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSecuritySvg, ...iconProps });
};
const IconSendSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M22 3c0-.1 0-.2-.1-.3v-.1c0-.1-.1-.2-.2-.3-.1-.1-.2-.1-.3-.2h-.1c-.1-.1-.2-.1-.3-.1h-.3l-19 6c-.4.2-.6.5-.7.9 0 .4.1.8.5 1l7.8 4.9 4.9 7.8c.2.3.5.5.8.5h.1c.4 0 .7-.3.8-.7l6-19c.1-.2.1-.3.1-.4zm-4.6 2.2-7.5 7.5-5.5-3.4 13-4.1zm-2.7 14.4-3.4-5.5 7.5-7.5-4.1 13z" })
    ]
  }
);
const IconSend = (props) => {
  const iconProps = ToastContext.useIcon(props, {
    verticalCorrection: {
      uppercase: "none",
      lowercase: "up"
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSendSvg, ...iconProps });
};
const IconSentSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M13 8.2V6.4c0-1.1-.9-2-2-2-.5 0-1 .2-1.4.6l-6.3 6.3c-.4.4-.4 1 0 1.4L9.6 19c.8.8 2 .8 2.8 0 .4-.4.6-.9.6-1.4v-1.7c2.5 0 4.9 1.3 6.1 3.6.2.3.5.5.9.5h.2c.4-.1.8-.5.8-1 0-3.3-1.7-9.5-8-10.8zM11.9 14c-.5.1-.9.5-.9 1v2.6L5.4 12 11 6.4V9c0 .5.4.9.9 1 4.1.5 5.8 3.4 6.6 5.7-1.9-1.4-4.3-2-6.6-1.7z" })
    ]
  }
);
const IconSent = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSentSvg, ...iconProps });
};
const IconSettingsSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m21.3 13.3-.2-.2c-.5-.7-.5-1.5 0-2.2l.2-.2c.6-.8.9-1.7.8-2.7-.2-2.1-2.1-3.6-4.2-3.4h-.3c-.8.1-1.6-.3-1.9-1.1l-.1-.3c-.4-.9-1.1-1.6-2-2-.9-.4-2-.4-2.9-.1-1 .4-1.7 1.1-2.1 2l-.2.4c-.3.8-1.1 1.2-1.9 1.1h-.3c-1-.1-1.9.2-2.7.7-1.6 1.3-2 3.7-.8 5.4l.2.2c.5.6.5 1.5 0 2.2l-.2.2c-.5.8-.8 1.7-.7 2.7.1 1 .6 1.9 1.4 2.6.8.6 1.8.9 2.8.8h.3c.8-.1 1.6.3 1.9 1.1l.1.3c.4.9 1.1 1.6 2 2 .5.2 1 .3 1.5.3s.9-.1 1.4-.3c1-.4 1.7-1.1 2.1-2l.1-.3c.3-.7 1.1-1.2 1.9-1.1h.3c.9.1 1.9-.2 2.7-.7.8-.6 1.4-1.5 1.5-2.5.2-1 0-2.1-.7-2.9zm-1.2 2.6c-.1.5-.3.9-.7 1.2-.4.3-.8.4-1.3.3h-.3c-1.7-.2-3.2.7-3.9 2.3l-.1.3c-.2.5-.6.8-1 1-.5.2-1 .2-1.4 0-.4-.2-.8-.5-.9-.9l-.1-.3c-.6-1.4-2-2.3-3.5-2.3h-.7c-.5.1-1-.1-1.4-.4-.4-.3-.6-.7-.7-1.2 0-.5.1-.9.3-1.3l.2-.2c1-1.4 1-3.2 0-4.5l-.2-.4c-.3-.4-.4-.9-.4-1.4.1-.5.3-.9.7-1.2.4-.2.9-.4 1.3-.3h.3c1.7.2 3.3-.7 4-2.2l.1-.3c.2-.4.6-.8 1-1 .5-.2 1-.2 1.4 0 .4.2.8.5.9.9l.1.3c.7 1.5 2.3 2.4 3.9 2.3h.3c1-.1 1.9.6 2 1.6 0 .5-.1.9-.3 1.3l-.2.2c-1 1.4-1 3.2 0 4.5l.2.2c.3.5.4 1 .4 1.5z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 8c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.7-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.8 2-2 2z" })
    ]
  }
);
const IconSettings = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSettingsSvg, ...iconProps });
};
const IconShareSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20.7 11.3 14.4 5c-.4-.4-.9-.6-1.4-.6-1.1 0-2 .9-2 2v1.7C4.7 9.5 3 15.7 3 19c0 .5.3.9.8 1H4c.4 0 .7-.2.9-.5 1.2-2.2 3.6-3.6 6.1-3.6v1.7c0 .5.2 1 .6 1.4.8.8 2 .8 2.8 0l6.3-6.3c.4-.4.4-1 0-1.4zM13 17.6V15c0-.5-.4-.9-.9-1-.4-.1-.8-.1-1.2-.1-1.9 0-3.8.6-5.4 1.8.7-2.4 2.5-5.2 6.6-5.7.5-.1.9-.5.9-1V6.4l5.6 5.6-5.6 5.6z" })
    ]
  }
);
const IconShare = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconShareSvg, ...iconProps });
};
const IconSocialFacebookSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M13.227 20v-7.288h2.46l.367-2.853h-2.827V8.042c0-.825.23-1.384 1.413-1.384h1.511V4.111A20.858 20.858 0 0 0 13.958 4a3.424 3.424 0 0 0-3.656 3.759v2.099H7.85v2.853h2.453V20Z" })
    ]
  }
);
const IconSocialFacebook = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSocialFacebookSvg, ...iconProps });
};
const IconSocialGitHubSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M12.006 2a10 10 0 0 0-3.16 19.489c.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.341-3.369-1.341a2.648 2.648 0 0 0-1.11-1.463c-.908-.62.068-.608.068-.608a2.1 2.1 0 0 1 1.532 1.03 2.13 2.13 0 0 0 2.91.831 2.137 2.137 0 0 1 .635-1.336c-2.22-.253-4.555-1.11-4.555-4.943a3.865 3.865 0 0 1 1.03-2.683 3.597 3.597 0 0 1 .098-2.647s.84-.269 2.75 1.026a9.478 9.478 0 0 1 5.007 0c1.909-1.294 2.747-1.026 2.747-1.026a3.592 3.592 0 0 1 .1 2.647 3.859 3.859 0 0 1 1.027 2.683c0 3.842-2.338 4.687-4.566 4.935a2.387 2.387 0 0 1 .68 1.852c0 1.336-.013 2.415-.013 2.743 0 .267.18.578.688.48A10.001 10.001 0 0 0 12.006 2Z",
          fillRule: "evenodd"
        }
      )
    ]
  }
);
const IconSocialGitHub = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSocialGitHubSvg, ...iconProps });
};
const IconSocialInstagramSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 5.441c2.136 0 2.39.009 3.233.047a4.426 4.426 0 0 1 1.485.276 2.65 2.65 0 0 1 1.518 1.518 4.427 4.427 0 0 1 .276 1.485c.038.844.047 1.097.047 3.233s-.009 2.39-.047 3.233a4.427 4.427 0 0 1-.276 1.485 2.65 2.65 0 0 1-1.518 1.518 4.427 4.427 0 0 1-1.485.276c-.844.038-1.097.047-3.233.047s-2.39-.009-3.233-.047a4.427 4.427 0 0 1-1.485-.276 2.65 2.65 0 0 1-1.518-1.518 4.426 4.426 0 0 1-.276-1.485c-.038-.844-.047-1.097-.047-3.233s.009-2.39.047-3.233a4.426 4.426 0 0 1 .276-1.485 2.65 2.65 0 0 1 1.518-1.518 4.426 4.426 0 0 1 1.485-.276c.844-.038 1.097-.047 3.233-.047M12 4c-2.173 0-2.445.01-3.298.048a5.872 5.872 0 0 0-1.942.372 4.09 4.09 0 0 0-2.34 2.34 5.872 5.872 0 0 0-.372 1.942C4.01 9.555 4 9.827 4 12s.01 2.445.048 3.298a5.872 5.872 0 0 0 .372 1.942 4.09 4.09 0 0 0 2.34 2.34 5.872 5.872 0 0 0 1.942.372C9.555 19.99 9.827 20 12 20s2.445-.01 3.298-.048a5.872 5.872 0 0 0 1.942-.372 4.09 4.09 0 0 0 2.34-2.34 5.872 5.872 0 0 0 .372-1.942C19.99 14.445 20 14.173 20 12s-.01-2.445-.048-3.298a5.872 5.872 0 0 0-.372-1.942 4.09 4.09 0 0 0-2.34-2.34 5.872 5.872 0 0 0-1.942-.372C14.445 4.01 14.173 4 12 4Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 7.892A4.108 4.108 0 1 0 16.108 12 4.108 4.108 0 0 0 12 7.892Zm0 6.775A2.667 2.667 0 1 1 14.667 12 2.667 2.667 0 0 1 12 14.667Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 16.27, cy: 7.73, r: 0.96 })
    ]
  }
);
const IconSocialInstagram = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSocialInstagramSvg, ...iconProps });
};
const IconSocialLinkedInSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M8.134 18.987H5.23V9.653h2.904Zm-1.45-10.61a1.682 1.682 0 1 1 1.68-1.682 1.682 1.682 0 0 1-1.68 1.683ZM19 18.988h-2.9v-4.54c0-1.082-.02-2.474-1.508-2.474-1.51 0-1.74 1.18-1.74 2.397v4.617H9.954V9.653h2.781v1.276h.04a3.047 3.047 0 0 1 2.745-1.508c2.937 0 3.48 1.933 3.48 4.447Z" })
    ]
  }
);
const IconSocialLinkedIn = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSocialLinkedInSvg, ...iconProps });
};
const IconSocialMediumSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M21 21H3V3h18ZM7.295 14.365a.615.615 0 0 1-.163.53l-1.27 1.54v.204h3.601v-.203l-1.27-1.54a.638.638 0 0 1-.175-.531V9.742l3.161 6.897h.367l2.716-6.897v5.497c0 .147 0 .175-.096.271l-.977.948v.204h4.742v-.204l-.943-.925a.282.282 0 0 1-.107-.271v-6.8a.282.282 0 0 1 .107-.272l.966-.925v-.203h-3.342l-2.383 5.942-2.71-5.942H6.015v.203l1.129 1.36a.468.468 0 0 1 .152.395Z" })
    ]
  }
);
const IconSocialMedium = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSocialMediumSvg, ...iconProps });
};
const IconSocialTwitterSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M9.403 17.689a8.117 8.117 0 0 0 8.172-8.172 7.64 7.64 0 0 0-.008-.372A5.844 5.844 0 0 0 19 7.658a5.734 5.734 0 0 1-1.65.452 2.882 2.882 0 0 0 1.263-1.589 5.756 5.756 0 0 1-1.823.698 2.875 2.875 0 0 0-4.895 2.619 8.155 8.155 0 0 1-5.92-3 2.875 2.875 0 0 0 .889 3.834 2.851 2.851 0 0 1-1.301-.36l-.001.037a2.874 2.874 0 0 0 2.304 2.816 2.868 2.868 0 0 1-1.297.05 2.876 2.876 0 0 0 2.684 1.994 5.764 5.764 0 0 1-3.568 1.23 5.847 5.847 0 0 1-.685-.04 8.132 8.132 0 0 0 4.403 1.29" })
    ]
  }
);
const IconSocialTwitter = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSocialTwitterSvg, ...iconProps });
};
const IconSocialYouTubeSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M22 12a26.362 26.362 0 0 1-.418 4.845 2.513 2.513 0 0 1-1.768 1.78c-1.56.42-7.814.42-7.814.42s-6.254 0-7.814-.42a2.513 2.513 0 0 1-1.768-1.78A26.362 26.362 0 0 1 2 12a26.362 26.362 0 0 1 .418-4.845 2.513 2.513 0 0 1 1.768-1.78c1.56-.42 7.814-.42 7.814-.42s6.254 0 7.814.42a2.513 2.513 0 0 1 1.768 1.78A26.362 26.362 0 0 1 22 12ZM9.955 14.974 15.182 12 9.955 9.026Z" })
    ]
  }
);
const IconSocialYouTube = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSocialYouTubeSvg, ...iconProps });
};
const IconStarSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M23 9c-.1-.4-.4-.6-.8-.7l-6.4-.9-2.9-5.8c-.3-.7-1.5-.7-1.8 0L8.2 7.3l-6.3 1c-.4 0-.7.3-.9.7-.1.4 0 .8.3 1l4.6 4.5-1.1 6.4c-.1.4.1.8.4 1 .2 0 .4.1.6.1.2 0 .3 0 .5-.1l5.7-3 5.7 3c.3.2.7.1 1.1-.1.3-.2.5-.6.4-1l-1.1-6.4 4.6-4.5c.3-.2.4-.6.3-.9zm-6.7 4.4c-.2.2-.3.6-.3.9l.8 4.9-4.4-2.3c-.3-.2-.6-.2-.9 0l-4.4 2.3.9-4.9c0-.3-.1-.7-.3-.9L4.1 10 9 9.3c.3 0 .6-.3.8-.5L12 4.3l2.2 4.4c.1.3.4.5.8.5l4.9.7-3.6 3.5z" })
    ]
  }
);
const IconStarActiveSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M23 9c-.1-.4-.4-.6-.8-.7l-6.4-.9-2.9-5.8c-.3-.5-.9-.7-1.4-.4-.2.1-.3.2-.4.4L8.2 7.3l-6.3 1c-.6.1-1 .6-.9 1.1 0 .2.1.4.3.6l4.6 4.5-1.1 6.4c-.1.5.3 1.1.8 1.2.2 0 .4 0 .6-.1l5.7-3 5.7 3c.5.3 1.1.1 1.3-.4.1-.2.1-.4.1-.6l-1.1-6.4 4.6-4.5c.5-.4.6-.8.5-1.1z" })
    ]
  }
);
const IconStar = ({ active = false, ...props }) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: active ? IconStarActiveSvg : IconStarSvg, ...iconProps });
};
const IconStatisticsSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 20H4a1 1 0 0 1 0-2h16a1 1 0 0 1 0 2ZM4 16a1 1 0 0 1-.707-1.707l5-5a1 1 0 0 1 1.414 0L12 11.586l7.293-7.293a1 1 0 0 1 1.414 1.414l-8 8a1 1 0 0 1-1.414 0L9 11.414l-4.293 4.293A.997.997 0 0 1 4 16Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 20H4a1 1 0 0 1 0-2h16a1 1 0 0 1 0 2ZM4 16a1 1 0 0 1-.707-1.707l5-5a1 1 0 0 1 1.414 0L12 11.586l7.293-7.293a1 1 0 0 1 1.414 1.414l-8 8a1 1 0 0 1-1.414 0L9 11.414l-4.293 4.293A.997.997 0 0 1 4 16Z" })
    ]
  }
);
const IconStatistics = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconStatisticsSvg, ...iconProps });
};
const IconSubCategorySvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m18.7 14.3-3-3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l1.3 1.3H8c-.6 0-1-.4-1-1V6c0-.6-.4-1-1-1s-1 .4-1 1v7c0 1.7 1.3 3 3 3h7.6l-1.3 1.3c-.4.4-.4 1 0 1.4.2.2.5.3.7.3s.5-.1.7-.3l3-3c.4-.4.4-1 0-1.4z" })
    ]
  }
);
const IconSubCategory = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconSubCategorySvg, ...iconProps });
};
const IconTagSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M7.4 6.1c-.3-.1-.5-.1-.8 0-.1 0-.2.1-.3.2-.1.1-.2.2-.2.3-.1.1-.1.3-.1.4 0 .1 0 .3.1.4.1.1.1.2.2.3.2.2.4.3.7.3.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7 0-.3-.1-.5-.3-.7-.1-.1-.2-.2-.3-.2z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m22.1 10.9-8.6-8.6c-.2-.2-.4-.3-.7-.3h-8c-1.7 0-3 1.3-3 3v8c0 .3.1.5.3.7l8.6 8.6c.6.6 1.4.9 2.1.9.8 0 1.5-.3 2.1-.9l7.1-7.1.1-.1c1.2-1.2 1.2-3.1 0-4.2zm-1.3 2.7s-.1.1 0 0l-7.3 7.3c-.4.4-1 .4-1.4 0l-8.3-8.3V5c0-.6.4-1 1-1h7.6l8.3 8.3c.4.4.4.9.1 1.3z" })
    ]
  }
);
const IconTag = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconTagSvg, ...iconProps });
};
const IconThumbSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20.847 9.122A2.986 2.986 0 0 0 18.507 8h-4.223A7.098 7.098 0 0 0 15 5a3.1 3.1 0 0 0-2.235-3.318A3.364 3.364 0 0 0 9.08 3.606L6.77 9H3a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h3.796A16.498 16.498 0 0 0 13 21a10.607 10.607 0 0 0 5.855-1.628 2.986 2.986 0 0 0 1.277-1.855l1.304-5.867a2.988 2.988 0 0 0-.59-2.528ZM4 11h2v7H4Zm14.179 6.084a.996.996 0 0 1-.425.62A8.592 8.592 0 0 1 13 19a16.217 16.217 0 0 1-5-.685v-7.11l2.895-6.758a1.348 1.348 0 0 1 1.41-.818C12.933 3.776 13 4.637 13 5a5.93 5.93 0 0 1-1.262 3.353A1 1 0 0 0 12.5 10h6.007a1 1 0 0 1 .975 1.217Z" })
    ]
  }
);
const IconThumb = ({ direction = "up", ...props }) => {
  const { className, ...iconProps } = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: IconThumbSvg,
      className: [
        styles_lib_components_icons_IconThumb_IconThumb_css_cjs.root,
        className,
        {
          [styles_lib_components_icons_IconThumb_IconThumb_css_cjs.down]: direction === "down"
        }
      ],
      ...iconProps
    }
  );
};
const IconTickSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M19.7 6.3c-.4-.4-1-.4-1.4 0L9 15.6l-3.3-3.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l4 4c.2.2.4.3.7.3s.5-.1.7-.3l10-10c.4-.4.4-1 0-1.4z" })
    ]
  }
);
const IconTick = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconTickSvg, ...iconProps });
};
const IconTimeSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M16.4 13.1 13 11.4V6c0-.6-.4-1-1-1s-1 .4-1 1v6c0 .4.2.7.6.9l4 2c.1.1.2.1.4.1.4 0 .7-.2.9-.6.2-.4 0-1-.5-1.3z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M12 1C5.9 1 1 5.9 1 12s4.9 11 11 11 11-4.9 11-11S18.1 1 12 1zm0 20c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9z" })
    ]
  }
);
const IconTime = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconTimeSvg, ...iconProps });
};
const IconTipSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M9 18.957a1 1 0 0 1-1-1V16a8.96 8.96 0 0 0-1.485-2.633l-.277-.391a7 7 0 1 1 11.524 0l-.277.391A8.96 8.96 0 0 0 16 16v1.932a1 1 0 0 1-2 0V16c0-1.095.878-2.419 1.856-3.793l.261-.368a5 5 0 1 0-8.234 0l.26.368C9.124 13.581 10 14.905 10 16v1.957a1 1 0 0 1-1 1Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M13.286 22h-2.572A2.761 2.761 0 0 1 8 19.2V17a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v2.2a2.761 2.761 0 0 1-2.714 2.8ZM10 18v1.2a.761.761 0 0 0 .714.8h2.572a.761.761 0 0 0 .714-.8V18Zm13-8h-2a1 1 0 0 1 0-2h2a1 1 0 0 1 0 2Zm-1.475 5.5a.994.994 0 0 1-.499-.134l-1.732-1a1 1 0 1 1 1-1.732l1.732 1a1 1 0 0 1-.5 1.866Zm-1.73-10a1 1 0 0 1-.501-1.866l1.732-1a1 1 0 1 1 1 1.732l-1.732 1a.994.994 0 0 1-.5.134ZM3 10H1a1 1 0 0 1 0-2h2a1 1 0 0 1 0 2Zm-.525 5.5a1 1 0 0 1-.501-1.866l1.732-1a1 1 0 1 1 1 1.732l-1.732 1a.994.994 0 0 1-.5.134Zm1.73-10a.994.994 0 0 1-.499-.134l-1.732-1a1 1 0 0 1 1-1.732l1.732 1a1 1 0 0 1-.5 1.866ZM15 10a1 1 0 0 1-1-1 2.003 2.003 0 0 0-2-2 1 1 0 0 1 0-2 4.004 4.004 0 0 1 4 4 1 1 0 0 1-1 1Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M14 21a2 2 0 0 1-4 0" })
    ]
  }
);
const IconTip = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconTipSvg, ...iconProps });
};
const IconUploadSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M7.7 9.7 11 6.4V14c0 .6.4 1 1 1s1-.4 1-1V6.4l3.3 3.3c.2.2.4.3.7.3s.5-.1.7-.3c.4-.4.4-1 0-1.4l-5-5c-.4-.4-1-.4-1.4 0l-5 5c-.4.4-.4 1 0 1.4s1 .4 1.4 0zM19 16c-.6 0-1 .4-1 1v1c0 .6-.5 1-1.1 1H7.1c-.6 0-1-.5-1.1-1v-1c0-.6-.4-1-1-1s-1 .4-1 1v1c0 1.7 1.4 3 3 3h9.9c1.7 0 3.1-1.3 3.1-3v-1c0-.6-.4-1-1-1z" })
    ]
  }
);
const IconUpload = (props) => {
  const iconProps = ToastContext.useIcon(props, {
    verticalCorrection: {
      uppercase: "none",
      lowercase: "up"
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconUploadSvg, ...iconProps });
};
const IconVideoSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m18.4 11.1-12-6c-.3-.1-.6-.1-.9 0-.3.2-.5.6-.5.9v12c0 .3.2.7.5.9.1.1.3.1.5.1s.3 0 .4-.1l12-6c.3-.2.6-.5.6-.9s-.2-.7-.6-.9zM7 16.4V7.6l8.8 4.4L7 16.4z" })
    ]
  }
);
const IconVideo = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconVideoSvg, ...iconProps });
};
const IconVisibilitySvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M21.912 11.59C21.791 11.32 18.867 5 12 5s-9.791 6.32-9.912 6.59a1.001 1.001 0 0 0 0 .82C2.209 12.68 5.133 19 12 19s9.791-6.32 9.912-6.59a1.001 1.001 0 0 0 0-.82ZM12 17c-4.708 0-7.173-3.728-7.877-5C4.827 10.728 7.292 7 12 7c4.71 0 7.175 3.73 7.877 5-.704 1.272-3.169 5-7.877 5Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 12, cy: 12, r: 2.5 })
    ]
  }
);
const IconVisibilityHiddenSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M5.571 14.015A11.133 11.133 0 0 1 4.123 12C4.827 10.728 7.292 7 12 7c.192 0 .374.015.558.027l1.768-1.767A10.41 10.41 0 0 0 12 5c-6.867 0-9.791 6.32-9.912 6.59a1.001 1.001 0 0 0 0 .82 12.68 12.68 0 0 0 2.072 3.016Zm16.341-2.425a12.842 12.842 0 0 0-3.64-4.448l2.435-2.435a1 1 0 0 0-1.414-1.414l-6.384 6.384-3.232 3.232-6.384 6.384a1 1 0 1 0 1.414 1.414l2.76-2.76A10.023 10.023 0 0 0 12 19c6.867 0 9.791-6.32 9.912-6.59a1.001 1.001 0 0 0 0-.82ZM12 17a8.097 8.097 0 0 1-3.008-.578l2.099-2.099a2.488 2.488 0 0 0 3.232-3.232l2.515-2.515A10.792 10.792 0 0 1 19.877 12c-.704 1.272-3.169 5-7.877 5Z" })
    ]
  }
);
const IconVisibility = ({ hidden, ...props }) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: hidden ? IconVisibilityHiddenSvg : IconVisibilitySvg,
      ...iconProps
    }
  );
};
const IconWorkExperienceSvg = ({
  title,
  titleId,
  ...props
}) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M20 6h-3V5a3.003 3.003 0 0 0-3-3h-4a3.003 3.003 0 0 0-3 3v1H4a3.003 3.003 0 0 0-3 3v10a3.003 3.003 0 0 0 3 3h16a3.003 3.003 0 0 0 3-3V9a3.003 3.003 0 0 0-3-3ZM9 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v1H9Zm6 3v12H9V8ZM3 19V9a1 1 0 0 1 1-1h3v12H4a1 1 0 0 1-1-1Zm18 0a1 1 0 0 1-1 1h-3V8h3a1 1 0 0 1 1 1Z" })
    ]
  }
);
const IconWorkExperience = (props) => {
  const iconProps = ToastContext.useIcon(props, {
    verticalCorrection: {
      uppercase: "up",
      lowercase: "up"
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconWorkExperienceSvg, ...iconProps });
};
const IconZoomInSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m21.707 20.293-3.682-3.682a9.022 9.022 0 1 0-1.414 1.414l3.682 3.682a1 1 0 0 0 1.414-1.414ZM4 11a7 7 0 1 1 11.962 4.93c-.006.006-.013.008-.019.013s-.007.013-.012.02A6.995 6.995 0 0 1 4 11Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M14 10h-2V8a1 1 0 0 0-2 0v2H8a1 1 0 0 0 0 2h2v2a1 1 0 0 0 2 0v-2h2a1 1 0 0 0 0-2Z" })
    ]
  }
);
const IconZoomIn = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconZoomInSvg, ...iconProps });
};
const IconZoomOutSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "m21.707 20.293-3.682-3.682a9.022 9.022 0 1 0-1.414 1.414l3.682 3.682a1 1 0 0 0 1.414-1.414ZM4 11a7 7 0 1 1 11.962 4.93c-.006.006-.013.008-.019.013s-.007.013-.012.02A6.995 6.995 0 0 1 4 11Z" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M14 10H8a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2Z" })
    ]
  }
);
const IconZoomOut = (props) => {
  const iconProps = ToastContext.useIcon(props);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: IconZoomOutSvg, ...iconProps });
};
const useDisclosure = ({
  id,
  expanded: expandedProp,
  onToggle
}) => {
  const [expandedFallback, setExpandedFallback] = React.useState(false);
  const expanded = expandedProp ?? expandedFallback;
  return {
    buttonProps: {
      "aria-controls": id,
      "aria-expanded": expanded,
      onClick: () => {
        const newValue = !expanded;
        if (expandedProp === void 0) {
          setExpandedFallback(newValue);
        }
        if (typeof onToggle === "function") {
          onToggle(newValue);
        }
      }
    },
    contentProps: {
      id
    },
    expanded
  };
};
const itemSpaceForSize = {
  xsmall: "small",
  small: "medium",
  standard: "medium",
  large: "large"
};
const AccordionItem = ({
  id,
  label,
  children,
  badge,
  size: sizeProp,
  tone: toneProp,
  weight: weightProp,
  icon: icon2,
  data,
  ...restProps
}) => {
  const accordionContext = React.useContext(AccordionContext);
  assert__default.default(
    !(accordionContext && sizeProp),
    "Size cannot be set on AccordionItem when inside Accordion. Size should be set on Accordion instead."
  );
  assert__default.default(
    !(accordionContext && toneProp),
    "Tone cannot be set on AccordionItem when inside Accordion. Tone should be set on Accordion instead."
  );
  assert__default.default(
    !(accordionContext && weightProp),
    "Weight cannot be set on AccordionItem when inside Accordion. Weight should be set on Accordion instead."
  );
  assert__default.default(
    toneProp === void 0 || validTones$1.includes(toneProp),
    `The 'tone' prop should be one of the following: ${validTones$1.map((x) => `"${x}"`).join(", ")}`
  );
  assert__default.default(
    // @ts-expect-error
    !badge || badge.type.__isBadge__,
    `AccordionItem badge prop can only be an instance of Badge. e.g. <AccordionItem badge={<Badge>New</Badge>}>`
  );
  assert__default.default(
    !badge || badge.props.bleedY === void 0,
    "Badge elements cannot set the 'bleedY' prop when passed to an AccordionItem component"
  );
  assert__default.default(
    !icon2 || icon2.props.size === void 0 && icon2.props.tone === void 0,
    "Icons cannot set the 'size' or 'tone' prop when passed to an AccordionItem component"
  );
  const size = (accordionContext == null ? void 0 : accordionContext.size) ?? sizeProp ?? "large";
  const tone = (accordionContext == null ? void 0 : accordionContext.tone) ?? toneProp ?? "neutral";
  const weight = (accordionContext == null ? void 0 : accordionContext.weight) ?? weightProp ?? "medium";
  const itemSpace = itemSpaceForSize[size] ?? "none";
  assert__default.default(
    typeof label === "undefined" || typeof label === "string",
    "Label must be a string"
  );
  const { expanded, buttonProps, contentProps } = useDisclosure({
    id,
    ...restProps.expanded !== void 0 ? {
      onToggle: restProps.onToggle,
      expanded: restProps.expanded
    } : {
      onToggle: restProps.onToggle
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }), children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { position: "relative", display: "flex", children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ToastContext.Box,
        {
          component: "button",
          type: "button",
          cursor: "pointer",
          className: [styles_lib_components_Accordion_AccordionItem_css_cjs.button, ToastContext.virtualTouchable()],
          outline: "none",
          width: "full",
          textAlign: "left",
          ...buttonProps,
          children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "span", position: "relative", children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Columns, { component: "span", space: itemSpace, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Inline, { component: "span", space: "small", alignY: "center", children: [
              /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { size, weight, tone, icon: icon2, children: label }),
              badge ? React.cloneElement(badge, { bleedY: true }) : null
            ] }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { width: "content", children: /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Text,
              {
                size,
                weight,
                tone: tone === "neutral" ? "secondary" : tone,
                children: /* @__PURE__ */ jsxRuntime.jsx(IconChevron, { direction: expanded ? "up" : "down" })
              }
            ) })
          ] }) })
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ToastContext.Overlay,
        {
          boxShadow: "outlineFocus",
          borderRadius: "standard",
          transition: "fast",
          className: [styles_lib_components_Accordion_AccordionItem_css_cjs.focusRing, styles_lib_components_private_hideFocusRings_hideFocusRings_css_cjs.hideFocusRingsClassName]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        paddingTop: itemSpace,
        display: expanded ? "block" : "none",
        ...contentProps,
        children
      }
    )
  ] });
};
const Actions = ({ size, data, children }) => {
  const contextValue = React.useMemo(() => ({ size }), [size]);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.ActionsContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Inline, { collapseBelow: "tablet", space: "xsmall", data, children }) });
};
const borderRadius$3 = "large";
const backgroundForTone = {
  promote: "promoteLight",
  info: "infoLight",
  positive: "positiveLight",
  caution: "cautionLight",
  critical: "criticalLight"
};
const borderForTone = {
  promote: "borderPromoteLight",
  info: "borderInfoLight",
  positive: "borderPositiveLight",
  caution: "borderCautionLight",
  critical: "borderCriticalLight"
};
const icons$1 = {
  positive: ToastContext.IconPositive,
  info: IconInfo,
  promote: IconPromote,
  caution: IconCaution,
  critical: ToastContext.IconCritical
};
const Alert = ({
  tone = "info",
  children,
  id,
  closeLabel = "Close",
  data,
  onClose,
  ...restProps
}) => {
  const isLegacyTheme = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.useBraidTheme().legacy;
  const parentBackground = ToastContext.useBackground();
  const Icon = icons$1[tone];
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      id,
      background: backgroundForTone[tone],
      paddingY: "medium",
      paddingX: "gutter",
      borderRadius: borderRadius$3,
      position: "relative",
      overflow: "hidden",
      role: "alert",
      "aria-live": "polite",
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Columns, { space: "small", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { width: "content", children: /* @__PURE__ */ jsxRuntime.jsx(Icon, { tone }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { className: styles_lib_css_textAlignedToIcon_css_cjs.textAlignedToIcon.standard, children }) }),
          onClose ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { width: "content", children: /* @__PURE__ */ jsxRuntime.jsxs(
            ToastContext.Box,
            {
              component: "button",
              "aria-label": closeLabel,
              borderRadius: "full",
              cursor: "pointer",
              position: "relative",
              onClick: onClose,
              outline: "none",
              transition: "touchable",
              transform: { active: "touchable" },
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              className: [
                styles_lib_components_Alert_Alert_css_cjs.closeButton,
                ToastContext.iconContainerSize(),
                ToastContext.virtualTouchable()
              ],
              children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Overlay,
                  {
                    component: "span",
                    boxShadow: "outlineFocus",
                    transition: "fast",
                    onlyVisibleForKeyboardNavigation: true,
                    borderRadius: "full",
                    className: styles_lib_components_Alert_Alert_css_cjs.closeButtonFocus
                  }
                ),
                /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Overlay,
                  {
                    component: "span",
                    background: "surface",
                    transition: "fast",
                    borderRadius: "full",
                    className: styles_lib_components_Alert_Alert_css_cjs.closeButtonHover
                  }
                ),
                /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Box,
                  {
                    component: "span",
                    display: "block",
                    zIndex: 1,
                    position: "relative",
                    children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconClear, { size: "fill", tone })
                  }
                )
              ]
            }
          ) }) : null
        ] }),
        isLegacyTheme && parentBackground.lightMode !== "surface" && /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            borderRadius: borderRadius$3,
            boxShadow: { lightMode: borderForTone[tone] },
            visible: true
          }
        )
      ]
    }
  );
};
const Strong = ({ children, data, id, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(
  "strong",
  {
    className: styles_lib_css_typography_css_cjs.fontWeight.strong,
    id,
    ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
    children
  }
);
const HiddenVisually = ({
  id,
  data,
  children,
  ...restProps
}) => {
  const inText = Boolean(React.useContext(ToastContext.TextContext));
  const inHeading = Boolean(React.useContext(ToastContext.HeadingContext));
  const component = inText || inHeading ? "span" : "div";
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component,
      id,
      position: "absolute",
      overflow: "hidden",
      className: styles_lib_components_HiddenVisually_HiddenVisually_css_cjs.root,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children
    }
  );
};
let announcementCounter = 0;
const containerPrefix = "braid-announcement-container";
const Announcement = ({ children }) => {
  const [announcementElement, setElement] = React.useState(null);
  const className = [
    styles_lib_css_atoms_atoms_cjs.atoms({
      reset: "div",
      position: "absolute",
      overflow: "hidden"
    }),
    styles_lib_components_HiddenVisually_HiddenVisually_css_cjs.root
  ].join(" ");
  React.useEffect(() => {
    const announcementContainerId = `${containerPrefix}-${announcementCounter++}`;
    const element = document.createElement("div");
    element.setAttribute("id", announcementContainerId);
    element.setAttribute("class", className);
    element.setAttribute("aria-live", "polite");
    element.setAttribute("aria-atomic", "true");
    document.body.appendChild(element);
    setElement(element);
    return () => {
      document.body.removeChild(element);
    };
  }, [className]);
  if (!announcementElement) {
    return null;
  }
  return reactDom.createPortal(children, announcementElement);
};
const Secondary = ({
  children,
  data,
  id,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  "span",
  {
    className: styles_lib_css_typography_css_cjs.tone.secondary,
    id,
    ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
    children
  }
);
const FieldLabel = ({
  id,
  htmlFor,
  label,
  disabled,
  secondaryLabel,
  tertiaryLabel,
  description,
  descriptionId,
  data
}) => {
  if (!label && !description) {
    return null;
  }
  const labelEl = /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Text, { tone: disabled ? "secondary" : void 0, children: [
    /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: label }),
    secondaryLabel ? /* @__PURE__ */ jsxRuntime.jsxs(Secondary, { children: [
      " (",
      secondaryLabel,
      ")"
    ] }) : null
  ] });
  return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Stack, { space: "xsmall", data, children: [
    label ? /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { component: "span", display: "flex", justifyContent: "spaceBetween", children: [
      htmlFor === false ? labelEl : /* @__PURE__ */ jsxRuntime.jsx("label", { id, htmlFor, children: labelEl }),
      tertiaryLabel ? /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Text, { children: [
        " ",
        tertiaryLabel
      ] }) : null
    ] }) : null,
    description ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingTop: label ? "xxsmall" : void 0, paddingBottom: "xxsmall", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { tone: "secondary", id: descriptionId, children: description }) }) : null
  ] });
};
const tones$1 = ["neutral", "critical", "positive", "caution"];
const icon = {
  critical: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconCritical, { tone: "critical" }),
  positive: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconPositive, { tone: "positive" }),
  caution: /* @__PURE__ */ jsxRuntime.jsx(IconCaution, { tone: "caution" })
};
const FieldMessage = ({
  id,
  tone = "neutral",
  message,
  secondaryMessage,
  reserveMessageSpace = true,
  disabled,
  data,
  ...restProps
}) => {
  if (tones$1.indexOf(tone) === -1) {
    throw new Error(`Invalid tone: ${tone}`);
  }
  if (!message && !secondaryMessage && !reserveMessageSpace) {
    return null;
  }
  const showMessage = !disabled && message;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      id,
      display: "flex",
      justifyContent: "flexEnd",
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { flexGrow: 1, userSelect: showMessage ? void 0 : "none", children: /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Text,
          {
            size: "small",
            tone: tone === "neutral" ? "secondary" : tone,
            icon: showMessage && tone !== "neutral" ? icon[tone] : void 0,
            children: showMessage ? message : " "
          }
        ) }),
        secondaryMessage && !disabled ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingLeft: "xsmall", flexGrow: 0, children: secondaryMessage }) : null
      ]
    }
  );
};
const mergeIds = (...ids) => {
  const validIds = ids.filter(Boolean);
  if (validIds.length === 0) {
    return void 0;
  }
  return validIds.join(" ");
};
const Field = ({
  id,
  value,
  labelId,
  name,
  disabled,
  autoComplete,
  children,
  description,
  message,
  secondaryMessage,
  reserveMessageSpace = false,
  tone,
  "aria-describedby": ariaDescribedBy,
  data,
  secondaryIcon,
  alwaysShowSecondaryIcon = false,
  autoFocus,
  icon: icon2,
  prefix,
  required,
  ...restProps
}) => {
  assert__default.default(
    prefix === void 0 || typeof prefix === "string",
    "Prefix must be a string"
  );
  const messageId = `${id}-message`;
  const descriptionId = description ? `${id}-description` : void 0;
  const fieldBackground = disabled ? { lightMode: "neutralSoft", darkMode: "neutral" } : { lightMode: "surface" };
  const hasValue = typeof value === "string" ? value.length > 0 : value != null;
  const hasVisualLabelOrDescription = "label" in restProps || description;
  const showSecondaryIcon = alwaysShowSecondaryIcon || secondaryIcon && hasValue;
  const { lightMode } = ToastContext.useBackgroundLightness();
  const overlays = /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.FieldOverlay,
      {
        variant: disabled ? "disabled" : "default",
        visible: tone !== "critical" || disabled,
        className: {
          [styles_lib_components_private_Field_Field_css_cjs.hideBorderOnDarkBackgroundInLightMode]: lightMode === "dark"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.FieldOverlay,
      {
        variant: "critical",
        visible: tone === "critical" && !disabled
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.FieldOverlay, { variant: "focus", className: styles_lib_components_private_Field_Field_css_cjs.focusOverlay }),
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.FieldOverlay, { variant: "formAccent", className: styles_lib_components_private_Field_Field_css_cjs.hoverOverlay })
  ] });
  const fieldPadding = "small";
  return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Stack, { space: "xsmall", children: [
    hasVisualLabelOrDescription ? /* @__PURE__ */ jsxRuntime.jsx(
      FieldLabel,
      {
        id: labelId,
        htmlFor: id,
        label: "label" in restProps ? restProps.label : void 0,
        disabled,
        secondaryLabel: "secondaryLabel" in restProps ? restProps.secondaryLabel : void 0,
        tertiaryLabel: "tertiaryLabel" in restProps ? restProps.tertiaryLabel : void 0,
        description,
        descriptionId
      }
    ) : null,
    /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        position: "relative",
        background: fieldBackground,
        borderRadius: "standard",
        display: "flex",
        className: showSecondaryIcon ? styles_lib_components_private_Field_Field_css_cjs.secondaryIconSpace : void 0,
        children: children(
          overlays,
          {
            id,
            name,
            background: fieldBackground,
            width: "full",
            paddingLeft: fieldPadding,
            paddingRight: showSecondaryIcon ? void 0 : fieldPadding,
            borderRadius: "standard",
            outline: "none",
            "aria-describedby": mergeIds(
              ariaDescribedBy,
              message || secondaryMessage ? messageId : void 0,
              descriptionId
            ),
            "aria-required": required,
            ..."aria-label" in restProps ? { "aria-label": restProps["aria-label"] } : {},
            ..."aria-labelledby" in restProps ? { "aria-labelledby": restProps["aria-labelledby"] } : {},
            disabled,
            autoComplete,
            autoFocus,
            ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
            className: clsx__default.default(
              styles_lib_components_private_Field_Field_css_cjs.field,
              styles_lib_components_private_Field_Field_css_cjs.placeholderColor,
              ToastContext.textStyles({
                tone: hasValue && !disabled ? "neutral" : "secondary",
                size: "standard",
                baseline: false
              }),
              styles_lib_css_typography_css_cjs.touchableText.standard,
              icon2 && !prefix ? styles_lib_components_private_Field_Field_css_cjs.iconSpace : null
            )
          },
          icon2 ? /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              position: "absolute",
              height: "touchable",
              width: "touchable",
              pointerEvents: "none",
              top: 0,
              left: 0,
              children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { baseline: false, tone: prefix ? "secondary" : void 0, children: icon2 })
            }
          ) : null,
          secondaryIcon ? /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              component: "span",
              position: "absolute",
              width: "touchable",
              height: "touchable",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              top: 0,
              right: 0,
              children: secondaryIcon
            }
          ) : null,
          prefix ? /* @__PURE__ */ jsxRuntime.jsxs(
            ToastContext.Box,
            {
              component: "label",
              htmlFor: id,
              display: "flex",
              alignItems: "center",
              paddingLeft: icon2 ? void 0 : fieldPadding,
              height: "touchable",
              flexShrink: 0,
              className: icon2 ? styles_lib_components_private_Field_Field_css_cjs.iconSpace : null,
              children: [
                /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { tone: "secondary", baseline: false, children: prefix }),
                /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { padding: fieldPadding, paddingRight: "none", height: "full", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { height: "full", className: styles_lib_components_private_Field_Field_css_cjs.verticalDivider }) })
              ]
            }
          ) : null
        )
      }
    ),
    message || secondaryMessage || reserveMessageSpace ? /* @__PURE__ */ jsxRuntime.jsx(
      FieldMessage,
      {
        id: messageId,
        tone,
        disabled,
        message,
        secondaryMessage,
        reserveMessageSpace
      }
    ) : null
  ] });
};
function getNextIndex(moveAmount, current, total) {
  const maxIndex = total - 1;
  if (current === null) {
    return moveAmount > 0 ? 0 : maxIndex;
  }
  const nextIndex = moveAmount + current;
  if (nextIndex > maxIndex) {
    return 0;
  }
  if (nextIndex < 0) {
    return maxIndex;
  }
  return nextIndex;
}
function normalizeKey({ key, keyCode }) {
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
    return `Arrow${key}`;
  }
  if (keyCode === 27) {
    return "Escape";
  }
  return key;
}
const FieldButtonIcon = React.forwardRef(
  ({ label, onClick, onMouseDown, ...restProps }, forwardedRef) => {
    const handleMouseDown = React.useCallback(
      (event) => {
        if (typeof onMouseDown !== "function") {
          return;
        }
        if (!onClick) {
          event.preventDefault();
        }
        onMouseDown(event);
      },
      [onClick, onMouseDown]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.ButtonIcon,
      {
        ref: forwardedRef,
        label,
        tone: "secondary",
        variant: "transparent",
        onClick,
        onMouseDown: handleMouseDown,
        tabIndex: -1,
        ...restProps
      }
    );
  }
);
const ClearField = ({
  hide = false,
  onClear,
  label = "Clear",
  id,
  inputRef
}) => {
  const clearHandler = React.useCallback(
    (event) => {
      if (typeof onClear !== "function" || event.button !== 0) {
        return;
      }
      onClear();
      if (inputRef && typeof inputRef === "object" && inputRef.current) {
        inputRef.current.focus();
      }
    },
    [onClear, inputRef]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: "span",
      height: "touchable",
      width: "touchable",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "fast",
      pointerEvents: hide ? "none" : void 0,
      opacity: hide ? 0 : void 0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        FieldButtonIcon,
        {
          id: `${id}-clear`,
          label,
          icon: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconClear, {}),
          onMouseDown: clearHandler
        }
      )
    }
  );
};
const easeModifier = (t) => t > 0.5 ? 4 * Math.pow(t - 1, 3) + 1 : 4 * Math.pow(t, 3);
const getExpectedTime = (distance, duration, speed, minDuration) => {
  const calculatedDuration = distance / speed;
  const normalizedDuration = minDuration > calculatedDuration ? minDuration : calculatedDuration;
  return duration !== null ? duration : normalizedDuration;
};
const getScrollPosition = (scrollContainer, direction) => scrollContainer[direction === "horizontal" ? "scrollLeft" : "scrollTop"];
const getScrollOffset = (scrollContainer, targetElement, direction) => {
  if (scrollContainer === window.document.documentElement) {
    const scrollPosition = getScrollPosition(scrollContainer, direction);
    const positionOnScreen = targetElement.getBoundingClientRect()[direction === "horizontal" ? "left" : "top"];
    return positionOnScreen + scrollPosition;
  }
  let totalOffset = 0;
  let currentElement = targetElement;
  const offsetKey = direction === "horizontal" ? "offsetLeft" : "offsetTop";
  while (scrollContainer.contains(currentElement) || currentElement === scrollContainer) {
    totalOffset += currentElement[offsetKey];
    const { offsetParent } = currentElement;
    if (!(offsetParent instanceof HTMLElement)) {
      break;
    }
    currentElement = offsetParent;
  }
  return totalOffset;
};
const scrollTo = (scrollContainer, direction, to) => {
  scrollContainer[direction === "horizontal" ? "scrollLeft" : "scrollTop"] = to;
};
const getPossibleScroll = (scrollContainer, direction) => scrollContainer[direction === "horizontal" ? "scrollWidth" : "scrollHeight"] - (scrollContainer === window.document.documentElement ? 0 : scrollContainer[direction === "horizontal" ? "offsetWidth" : "offsetHeight"]);
const limitNumberToRange = (number, min, max) => {
  if (number < min) {
    return min;
  }
  if (number > max) {
    return max;
  }
  return number;
};
const scroll = (scrollContainer, direction, to, { duration = null, speed = 2, minDuration = 0 }, callback) => {
  const startTime = Date.now();
  const initial = getScrollPosition(scrollContainer, direction);
  const possibleScroll = getPossibleScroll(scrollContainer, direction);
  const targetScrollPosition = limitNumberToRange(to, 0, possibleScroll);
  const total = Math.abs(targetScrollPosition - initial);
  const expectedTime = getExpectedTime(total, duration, speed, minDuration);
  const scrollForwards = targetScrollPosition > initial;
  const step = () => {
    requestAnimationFrame(() => {
      const timePassed = Date.now() - startTime;
      const progress = timePassed / expectedTime;
      const distance = easeModifier(progress) * total;
      const newPosition = Math.floor(
        scrollForwards ? initial + distance : initial - distance
      );
      const isComplete = scrollForwards ? newPosition >= targetScrollPosition : newPosition <= targetScrollPosition;
      if (isComplete) {
        scrollTo(scrollContainer, direction, targetScrollPosition);
        if (callback) {
          callback();
        }
      } else {
        scrollTo(scrollContainer, direction, newPosition);
        step();
      }
    });
  };
  if (targetScrollPosition !== initial) {
    step();
  } else if (callback) {
    callback();
  }
};
const smoothScroll = (element, {
  scrollContainer = window.document.documentElement,
  direction = "vertical",
  offset = 0,
  position = "start",
  ...scrollOptions
} = {}) => new Promise((resolve) => {
  const scrollOffset = getScrollOffset(scrollContainer, element, direction);
  const scrollPosition = position === "end" ? scrollOffset - scrollContainer.offsetWidth + element.offsetWidth + offset : scrollOffset - offset;
  scroll(scrollContainer, direction, scrollPosition, scrollOptions, resolve);
});
const smoothScrollIntoView = (element, options) => {
  const {
    scrollContainer = window.document.documentElement,
    direction = "vertical",
    offset = 0
  } = options;
  const containerWidth = scrollContainer.offsetWidth;
  const scrollOffset = getScrollOffset(scrollContainer, element, direction);
  const positionOnScreen = scrollOffset - getScrollPosition(scrollContainer, direction);
  if (positionOnScreen < offset) {
    smoothScroll(element, { ...options, position: "start" });
  } else if (positionOnScreen > containerWidth - element.offsetWidth - offset) {
    smoothScroll(element, { ...options, position: "end" });
  }
};
function useScrollIntoView(element, scrollContainer) {
  React.useEffect(() => {
    if (scrollContainer && element) {
      const itemOffsetRelativeToContainer = element.offsetParent === scrollContainer ? element.offsetTop : element.offsetTop - scrollContainer.offsetTop;
      let { scrollTop } = scrollContainer;
      if (itemOffsetRelativeToContainer < scrollTop) {
        scrollTop = itemOffsetRelativeToContainer;
      } else if (itemOffsetRelativeToContainer + element.offsetHeight > scrollTop + scrollContainer.offsetHeight) {
        scrollTop = itemOffsetRelativeToContainer + element.offsetHeight - scrollContainer.offsetHeight;
      }
      if (scrollTop !== scrollContainer.scrollTop) {
        scrollContainer.scrollTop = scrollTop;
      }
    }
  }, [scrollContainer, element]);
}
const getItemId = (id, index) => `${id}-item-${index}`;
const createAccessbilityProps = ({
  id,
  highlightedIndex,
  isOpen
}) => {
  const menuId = `${id}-menu`;
  const labelId = `${id}-label`;
  const assistiveDescriptionId = `${id}-aria-description`;
  return {
    labelProps: {
      id: labelId
    },
    inputProps: {
      id,
      role: "combobox",
      "aria-haspopup": "listbox",
      "aria-owns": isOpen ? menuId : void 0,
      // backwards compatibility for screenreaders implementing ARIA 1.0
      "aria-controls": menuId,
      "aria-expanded": isOpen,
      "aria-labelledby": labelId,
      "aria-autocomplete": "list",
      "aria-activedescendant": typeof highlightedIndex === "number" ? getItemId(id, highlightedIndex) : void 0,
      "aria-describedby": assistiveDescriptionId,
      autoComplete: "off",
      // https://stackoverflow.com/questions/47775041/disable-autofill-in-chrome-63/47822599
      spellCheck: false
    },
    assistiveDescriptionProps: {
      id: assistiveDescriptionId
    },
    menuProps: {
      id: menuId,
      role: "listbox"
    },
    getItemProps: ({
      index,
      label,
      description,
      groupHeading
    }) => ({
      id: getItemId(id, index),
      role: "option",
      "aria-selected": index === highlightedIndex,
      "aria-label": `${label}${description ? ` - ${description}` : ""}${groupHeading ? ` (${groupHeading})` : ""}`
    })
  };
};
const autosuggest = {
  assistiveDescription: "Suggestions will appear below the field as you type",
  suggestionInstructions: "Use up and down arrow keys to navigate. Press enter to select",
  suggestionsAvailableAnnouncement: (suggestionCount) => `${suggestionCount} suggestion${suggestionCount === 1 ? "" : "s"} available`,
  noSuggestionsAvailableAnnouncement: "No suggestions available",
  suggestionAutoSelectedAnnouncement: (suggestion) => `Suggestion ${suggestion} is automatically selected`
};
const INPUT_FOCUS = 0;
const INPUT_BLUR = 1;
const INPUT_CHANGE = 2;
const INPUT_ARROW_UP = 3;
const INPUT_ARROW_DOWN = 4;
const INPUT_ESCAPE = 5;
const INPUT_ENTER = 6;
const SUGGESTION_MOUSE_CLICK = 7;
const SUGGESTION_MOUSE_ENTER = 8;
const HAS_SUGGESTIONS_CHANGED = 9;
function SuggestionItem({
  suggestion,
  highlighted,
  selected,
  onHover,
  id,
  ...restProps
}) {
  const { highlights = [], onClear, clearLabel } = suggestion;
  const label = suggestion.label ?? suggestion.text;
  const suggestionParts = parseHighlights__default.default(
    label,
    highlights.map(({ start, end }) => [start, end])
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: "li",
      cursor: "pointer",
      onMouseDown: (event) => {
        event.preventDefault();
      },
      onMouseMove: onHover,
      onTouchStart: onHover,
      id,
      ...restProps,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        ToastContext.Box,
        {
          component: "span",
          display: "flex",
          justifyContent: "spaceBetween",
          background: highlighted ? "formAccentSoft" : void 0,
          paddingX: "small",
          paddingRight: onClear ? "none" : void 0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { className: styles_lib_css_typography_css_cjs.touchableText.standard, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { baseline: false, children: suggestionParts.map(
                ({ highlight, text }, index) => selected || highlight ? /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: text }, index) : /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: text }, index)
              ) }),
              suggestion.description ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { size: "small", tone: "secondary", baseline: false, children: suggestion.description }) : null
            ] }),
            typeof onClear === "function" ? /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                width: "touchable",
                height: "touchable",
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.ButtonIcon,
                  {
                    id: `${id}-clear`,
                    icon: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconClear, {}),
                    tone: "secondary",
                    tabIndex: -1,
                    label: clearLabel || "Clear suggestion",
                    onClick: (event) => {
                      event.preventDefault();
                      event.stopPropagation();
                      onClear(valueFromSuggestion(suggestion));
                    }
                  }
                )
              }
            ) : null
          ]
        }
      )
    }
  );
}
function GroupHeading({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      paddingX: "small",
      className: [
        styles_lib_components_Autosuggest_Autosuggest_css_cjs.groupHeading,
        styles_lib_css_typography_css_cjs.touchableText.xsmall,
        ToastContext.textStyles({
          size: "xsmall",
          baseline: false,
          weight: "strong",
          tone: "formAccent"
        })
      ],
      "data-testid": process.env.NODE_ENV !== "production" ? `group-heading-${children}` : void 0,
      children
    }
  );
}
function normaliseSuggestions(suggestions) {
  let index = 0;
  const normalisedSuggestions = [];
  const groupHeadingIndexes = /* @__PURE__ */ new Map();
  const groupHeadingForSuggestion = /* @__PURE__ */ new Map();
  for (const item of suggestions) {
    if ("suggestions" in item) {
      groupHeadingIndexes.set(index, item.label);
      item.suggestions.forEach((suggestion) => {
        groupHeadingForSuggestion.set(suggestion, item.label);
      });
      index = normalisedSuggestions.push(...item.suggestions);
    } else {
      index = normalisedSuggestions.push(item);
    }
  }
  return {
    normalisedSuggestions,
    groupHeadingIndexes,
    groupHeadingForSuggestion
  };
}
function valueFromSuggestion(suggestion) {
  return "value" in suggestion ? {
    text: suggestion.text,
    value: suggestion.value
  } : { text: suggestion.text };
}
const noop = () => {
};
const fallbackValue = { text: "" };
const fallbackSuggestions = [];
function normaliseNoSuggestionMessage(noSuggestionsMessage, suggestionProp) {
  if (noSuggestionsMessage) {
    return typeof noSuggestionsMessage === "string" ? { description: noSuggestionsMessage } : noSuggestionsMessage;
  }
  if ("message" in suggestionProp) {
    const message = suggestionProp.message;
    if (process.env.NODE_ENV !== "production") {
      console.warn(
        dedent__default.default`
          Passing \`message\` to \`suggestions\` is deprecated and will be removed in a future version. Use "noSuggestionsMessage" instead. See the documentation for usage: https://seek-oss.github.io/braid-design-system/components/Autosuggest#messaging-when-no-suggestions-are-available
             <Autosuggest
            %c-   suggestions={{ message: '${message}' }}
            %c+   noSuggestionsMessage="${message}"
             %c/>
        `,
        "color: red",
        "color: green",
        "color: inherit"
      );
    }
    return { description: message };
  }
}
const Autosuggest = React.forwardRef(function({
  id,
  value = fallbackValue,
  suggestions: suggestionsProp = fallbackSuggestions,
  noSuggestionsMessage: noSuggestionsMessageProp,
  onChange = noop,
  automaticSelection = false,
  showMobileBackdrop = false,
  scrollToTopOnMobile = true,
  hideSuggestionsOnSelection = true,
  onFocus = noop,
  onBlur = noop,
  placeholder,
  type = "text",
  clearLabel,
  onClear,
  translations = autosuggest,
  ...restProps
}, forwardedRef) {
  const suggestionsPropValue = typeof suggestionsProp === "function" ? suggestionsProp(value) : suggestionsProp;
  const suggestions = Array.isArray(suggestionsPropValue) ? suggestionsPropValue : [];
  const noSuggestionsMessage = normaliseNoSuggestionMessage(
    noSuggestionsMessageProp,
    suggestionsPropValue
  );
  const hasItems = suggestions.length > 0 || Boolean(noSuggestionsMessage);
  const defaultRef = React.useRef(null);
  const inputRef = forwardedRef || defaultRef;
  const fireChange = React.useCallback(
    (suggestion) => onChange(valueFromSuggestion(suggestion)),
    [onChange]
  );
  const rootRef = React.useRef(null);
  const menuRef = React.useRef(null);
  const justPressedArrowRef = React.useRef(false);
  const {
    normalisedSuggestions,
    groupHeadingIndexes,
    groupHeadingForSuggestion
  } = normaliseSuggestions(suggestions);
  const suggestionCount = normalisedSuggestions.length;
  const hasSuggestions = suggestionCount > 0;
  const reducer2 = (state, action) => {
    switch (action.type) {
      case INPUT_ARROW_DOWN: {
        if (hasSuggestions) {
          const nextIndex = getNextIndex(
            1,
            state.highlightedIndex,
            suggestionCount
          );
          return {
            ...state,
            showSuggestionsIfAvailable: true,
            previewValue: normalisedSuggestions[nextIndex],
            highlightedIndex: nextIndex
          };
        }
      }
      case INPUT_ARROW_UP: {
        if (hasSuggestions) {
          const nextIndex = getNextIndex(
            -1,
            state.highlightedIndex,
            suggestionCount
          );
          return {
            ...state,
            showSuggestionsIfAvailable: true,
            previewValue: normalisedSuggestions[nextIndex],
            highlightedIndex: nextIndex
          };
        }
      }
      case INPUT_CHANGE: {
        return {
          ...state,
          showSuggestionsIfAvailable: true,
          inputChangedSinceFocus: true,
          previewValue: null,
          highlightedIndex: hasSuggestions && automaticSelection && value.text.length > 0 ? 0 : null
        };
      }
      case INPUT_FOCUS: {
        return {
          ...state,
          showSuggestionsIfAvailable: true,
          inputChangedSinceFocus: false,
          isFocused: true
        };
      }
      case INPUT_BLUR: {
        return {
          ...state,
          showSuggestionsIfAvailable: false,
          previewValue: null,
          highlightedIndex: null,
          isFocused: false
        };
      }
      case INPUT_ESCAPE: {
        if (value.text) {
          return {
            ...state,
            showSuggestionsIfAvailable: false,
            previewValue: null,
            highlightedIndex: null
          };
        } else if (hasItems) {
          return {
            ...state,
            showSuggestionsIfAvailable: !state.showSuggestionsIfAvailable,
            previewValue: null
          };
        }
        return state;
      }
      case INPUT_ENTER:
      case SUGGESTION_MOUSE_CLICK: {
        return {
          ...state,
          showSuggestionsIfAvailable: !hideSuggestionsOnSelection,
          previewValue: null,
          highlightedIndex: null
        };
      }
      case SUGGESTION_MOUSE_ENTER: {
        return {
          ...state,
          highlightedIndex: action.value
        };
      }
      case HAS_SUGGESTIONS_CHANGED: {
        return automaticSelection ? {
          ...state,
          highlightedIndex: hasSuggestions && value.text.length > 0 ? 0 : null
        } : state;
      }
      default: {
        console.error(new Error(`Invalid Autosuggest action: ${action}`));
        return state;
      }
    }
  };
  const [
    {
      showSuggestionsIfAvailable,
      inputChangedSinceFocus,
      previewValue,
      highlightedIndex,
      isFocused
    },
    dispatch
  ] = React.useReducer(reducer2, {
    showSuggestionsIfAvailable: false,
    inputChangedSinceFocus: false,
    previewValue: null,
    highlightedIndex: null,
    isFocused: false
  });
  const isOpen = showSuggestionsIfAvailable && hasItems;
  const highlightedItem = typeof highlightedIndex === "number" ? document.getElementById(getItemId(id, highlightedIndex)) : null;
  useScrollIntoView(highlightedItem, menuRef.current);
  React.useEffect(() => {
    dispatch({
      type: HAS_SUGGESTIONS_CHANGED
    });
  }, [hasSuggestions]);
  const isMobile2 = ToastContext.useResponsiveValue()({
    mobile: true,
    tablet: false
  });
  React.useEffect(() => {
    if (menuRef.current && isOpen && !isMobile2) {
      const { bottom: menuBottom } = menuRef.current.getBoundingClientRect();
      const viewportHeight = document.documentElement.clientHeight;
      if (menuBottom > viewportHeight) {
        menuRef.current.scrollIntoView(false);
      }
    }
  }, [isOpen, isMobile2, suggestionCount]);
  const inputProps = {
    value: previewValue ? previewValue.text : value.text,
    type: type === "search" ? type : "text",
    placeholder: !restProps.disabled ? placeholder : void 0,
    onChange: (e) => {
      const inputValue = e.target.value;
      dispatch({ type: INPUT_CHANGE });
      fireChange({ text: inputValue });
    },
    onFocus: () => {
      if (rootRef.current && scrollToTopOnMobile && isMobile2) {
        smoothScroll(rootRef.current);
      }
      dispatch({ type: INPUT_FOCUS });
      onFocus();
    },
    onBlur: () => {
      if (justPressedArrowRef.current === true) {
        return;
      }
      if (previewValue) {
        fireChange(previewValue);
      } else if (isOpen && automaticSelection && inputChangedSinceFocus && value.text.length > 0 && suggestionCount > 0) {
        fireChange(normalisedSuggestions[0]);
      }
      dispatch({ type: INPUT_BLUR });
      onBlur();
    },
    onKeyDown: (event) => {
      const targetKey = normalizeKey(event);
      if (/^Arrow(Up|Down$)/.test(targetKey)) {
        justPressedArrowRef.current = true;
        setTimeout(() => {
          justPressedArrowRef.current = false;
        }, 150);
      }
      switch (targetKey) {
        case "ArrowDown": {
          event.preventDefault();
          dispatch({ type: INPUT_ARROW_DOWN });
          return;
        }
        case "ArrowUp": {
          event.preventDefault();
          dispatch({ type: INPUT_ARROW_UP });
          return;
        }
        case "Escape": {
          event.preventDefault();
          if (previewValue === null && value.text) {
            fireChange({ text: "" });
          }
          dispatch({ type: INPUT_ESCAPE });
          return;
        }
        case "Enter": {
          if (typeof highlightedIndex === "number") {
            event.preventDefault();
            fireChange(normalisedSuggestions[highlightedIndex]);
          }
          dispatch({ type: INPUT_ENTER });
          return;
        }
        default: {
          return;
        }
      }
    }
  };
  const a11y = createAccessbilityProps({
    id,
    isOpen,
    highlightedIndex
  });
  const clearable = Boolean(
    typeof onClear !== "undefined" && !restProps.disabled && typeof value !== "undefined" && value.text.length > 0
  );
  const announcements = [];
  const hasAutomaticSelection = automaticSelection && previewValue === null && highlightedIndex === 0;
  if (isFocused && isOpen && (highlightedIndex === null || hasAutomaticSelection)) {
    if (hasSuggestions) {
      announcements.push(
        translations.suggestionsAvailableAnnouncement(suggestionCount)
      );
      if (hasAutomaticSelection) {
        announcements.push(
          translations.suggestionAutoSelectedAnnouncement(
            normalisedSuggestions[0].text
          )
        );
      }
      announcements.push(translations.suggestionInstructions);
    } else if (noSuggestionsMessage) {
      if (noSuggestionsMessage.title) {
        announcements.push(noSuggestionsMessage.title);
      }
      announcements.push(noSuggestionsMessage.description);
    } else {
      announcements.push(translations.noSuggestionsAvailableAnnouncement);
    }
  }
  return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
    showMobileBackdrop ? /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        position: "fixed",
        zIndex: "dropdownBackdrop",
        transition: "fast",
        display: ["block", "none"],
        pointerEvents: isOpen ? void 0 : "none",
        top: 0,
        left: 0,
        opacity: !isOpen ? 0 : void 0,
        className: [
          styles_lib_components_Autosuggest_Autosuggest_css_cjs.backdrop,
          isOpen ? styles_lib_components_Autosuggest_Autosuggest_css_cjs.backdropVisible : void 0
        ]
      }
    ) : null,
    /* @__PURE__ */ jsxRuntime.jsxs(
      ToastContext.Box,
      {
        ...showMobileBackdrop && isOpen ? {
          position: "relative",
          zIndex: "dropdown"
        } : null,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { position: "relative", ref: rootRef, children: /* @__PURE__ */ jsxRuntime.jsx(
            Field,
            {
              ...restProps,
              id,
              labelId: a11y.labelProps.id,
              value: value.text,
              prefix: void 0,
              secondaryIcon: onClear ? /* @__PURE__ */ jsxRuntime.jsx(
                ClearField,
                {
                  id: `${id}-clearfield`,
                  hide: !clearable,
                  onClear,
                  label: clearLabel,
                  inputRef
                }
              ) : null,
              children: (overlays, fieldProps, icon2, secondaryIcon) => /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { width: "full", children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Box,
                  {
                    component: "input",
                    ...fieldProps,
                    ...a11y.inputProps,
                    ...inputProps,
                    position: "relative",
                    ref: inputRef
                  }
                ),
                icon2,
                /* @__PURE__ */ jsxRuntime.jsx(reactRemoveScroll.RemoveScroll, { ref: menuRef, enabled: isOpen, forwardProps: true, children: /* @__PURE__ */ jsxRuntime.jsxs(
                  ToastContext.Box,
                  {
                    component: "ul",
                    display: isOpen ? "block" : "none",
                    position: "absolute",
                    zIndex: "dropdown",
                    background: !hasSuggestions && noSuggestionsMessage ? { lightMode: "neutralSoft", darkMode: "neutral" } : "surface",
                    borderRadius: "standard",
                    boxShadow: "medium",
                    width: "full",
                    marginTop: "xxsmall",
                    paddingY: "xxsmall",
                    className: styles_lib_components_Autosuggest_Autosuggest_css_cjs.menu,
                    ...a11y.menuProps,
                    children: [
                      isOpen && !hasSuggestions && noSuggestionsMessage ? /* @__PURE__ */ jsxRuntime.jsxs(
                        ToastContext.Box,
                        {
                          component: "li",
                          paddingX: "small",
                          className: styles_lib_css_typography_css_cjs.touchableText.standard,
                          children: [
                            noSuggestionsMessage.title ? /* @__PURE__ */ jsxRuntime.jsx(
                              ToastContext.Text,
                              {
                                tone: "secondary",
                                weight: "medium",
                                baseline: false,
                                children: noSuggestionsMessage.title
                              }
                            ) : null,
                            /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { tone: "secondary", baseline: false, children: noSuggestionsMessage.description })
                          ]
                        }
                      ) : null,
                      isOpen && hasSuggestions ? normalisedSuggestions.map((suggestion, index) => {
                        const { text } = suggestion;
                        const groupHeading = groupHeadingIndexes.get(index);
                        return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
                          groupHeading ? /* @__PURE__ */ jsxRuntime.jsx(GroupHeading, { children: groupHeading }) : null,
                          /* @__PURE__ */ jsxRuntime.jsx(
                            SuggestionItem,
                            {
                              suggestion,
                              highlighted: highlightedIndex === index,
                              selected: value === suggestion,
                              onClick: () => {
                                fireChange(suggestion);
                                dispatch({ type: SUGGESTION_MOUSE_CLICK });
                              },
                              onHover: () => {
                                dispatch({
                                  type: SUGGESTION_MOUSE_ENTER,
                                  value: index
                                });
                              },
                              ...a11y.getItemProps({
                                index,
                                label: suggestion.label ?? suggestion.text,
                                description: suggestion.description,
                                groupHeading: groupHeadingForSuggestion.get(suggestion)
                              })
                            }
                          )
                        ] }, index + text);
                      }) : null
                    ]
                  }
                ) }),
                overlays,
                secondaryIcon
              ] })
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(HiddenVisually, { ...a11y.assistiveDescriptionProps, children: translations.assistiveDescription }),
          /* @__PURE__ */ jsxRuntime.jsx(Announcement, { children: announcements.join(". ") })
        ]
      }
    )
  ] });
});
Autosuggest.displayName = "Autosuggest";
function matchSuggestion(suggestion, query) {
  const groupMatches = matchHighlights__default.default(
    suggestion.label ?? suggestion.text,
    query
  );
  return !groupMatches.length ? null : {
    ...suggestion,
    highlights: groupMatches.map(([start, end]) => ({ start, end }))
  };
}
function filterSuggestions(...args) {
  assert__default.default(
    [1, 2].includes(args.length),
    `Invalid number of arguments passed to "filterSuggestions". Expected 1 or 2, got ${args.length}`
  );
  if (args.length === 1) {
    return (inputValue) => filter(args[0], inputValue);
  } else if (args.length === 2) {
    return filter(args[0], args[1]);
  }
  function filter(suggestions, inputValue) {
    assert__default.default(
      typeof inputValue === "string" || typeof inputValue === "object" && inputValue !== null && "text" in inputValue,
      'The second argument to "filterSuggestions" must be a string or an Autosuggest value object, e.g. { text: "Hello world" }'
    );
    const query = (typeof inputValue === "string" ? inputValue : inputValue.text).trim();
    if (query === "") {
      return suggestions;
    }
    const filteredSuggestions = [];
    suggestions.forEach((suggestion) => {
      if ("suggestions" in suggestion) {
        const filteredGroupSuggestions = [];
        suggestion.suggestions.forEach((groupSuggestion) => {
          const filteredSuggestion = matchSuggestion(groupSuggestion, query);
          if (filteredSuggestion) {
            filteredGroupSuggestions.push(filteredSuggestion);
          }
        });
        if (filteredGroupSuggestions.length) {
          filteredSuggestions.push({
            ...suggestion,
            suggestions: filteredGroupSuggestions
          });
        }
      } else {
        const filteredSuggestion = matchSuggestion(suggestion, query);
        if (filteredSuggestion) {
          filteredSuggestions.push(filteredSuggestion);
        }
      }
    });
    return filteredSuggestions;
  }
}
const validTones = [
  "promote",
  "info",
  "neutral",
  "positive",
  "caution",
  "critical"
];
const lightModeBackgroundForTone = {
  positive: "positiveLight",
  critical: "criticalLight",
  info: "infoLight",
  promote: "promoteLight",
  neutral: "neutralLight",
  caution: "cautionLight"
};
const verticalPadding = "xxsmall";
const Badge = React.forwardRef(
  ({
    tone = "info",
    weight = "regular",
    bleedY = false,
    title,
    children,
    id,
    data,
    tabIndex,
    "aria-describedby": ariaDescribedBy,
    ...restProps
  }, ref) => {
    assert__default.default(
      validTones.indexOf(tone) >= 0,
      `Badge tone of "${tone}" is not valid.`
    );
    assert__default.default(
      React.Children.toArray(children).every(
        (child) => ["string", "number"].includes(typeof child)
      ),
      "Badge may only contain strings or numbers"
    );
    const content = /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        component: "span",
        display: "flex",
        cursor: "default",
        ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "span",
            id,
            ref,
            tabIndex,
            "aria-describedby": ariaDescribedBy,
            title: title ?? (!ariaDescribedBy ? children : void 0),
            background: weight === "strong" ? tone : lightModeBackgroundForTone[tone],
            paddingY: verticalPadding,
            paddingX: "xsmall",
            borderRadius: "standard",
            overflow: "hidden",
            children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { size: "xsmall", weight: "medium", maxLines: 1, children })
          }
        )
      }
    );
    return bleedY ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Bleed, { component: "span", vertical: verticalPadding, children: content }) : content;
  }
);
Badge.displayName = "Badge";
Badge.__isBadge__ = true;
const ColoredBoxRenderer = ({
  background,
  boxShadow,
  children,
  className
}) => {
  const { backgroundContext, classList } = ToastContext.useColoredBoxClasses({
    background,
    boxShadow
  });
  const element = children(clsx__default.default(className, classList));
  return backgroundContext ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.BackgroundProvider, { value: backgroundContext, children: element }) : element;
};
const BoxRenderer = ({
  children,
  component = "div",
  className,
  background,
  boxShadow,
  ...props
}) => {
  const classes = clsx__default.default(className, styles_lib_css_atoms_atoms_cjs.atoms({ reset: component, ...props }));
  return background || boxShadow ? /* @__PURE__ */ jsxRuntime.jsx(
    ColoredBoxRenderer,
    {
      background,
      boxShadow,
      className: classes,
      children
    }
  ) : children(classes);
};
const ButtonLink = React.forwardRef(
  ({
    children,
    size,
    tone,
    variant,
    bleedY,
    bleed,
    icon: icon2,
    iconPosition,
    loading,
    data,
    ...restProps
  }, ref) => {
    const LinkComponent = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.useLinkComponent(ref);
    if (process.env.NODE_ENV !== "production") {
      if (typeof bleedY !== "undefined") {
        console.warn(
          dedent__default.default`
            The "bleedY" prop has been deprecated and will be removed in a future version. Use "bleed" instead.
               <Button
              %c-   bleedY
              %c+   bleed
               %c/>
          `,
          "color: red",
          "color: green",
          "color: inherit"
        );
      }
    }
    return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.ButtonContainer, { bleed, variant, children: /* @__PURE__ */ jsxRuntime.jsxs(
      ToastContext.Box,
      {
        component: LinkComponent,
        ref,
        ...restProps,
        ...ToastContext.buildDataAttributes({ data, validateRestProps: false }),
        ...ToastContext.useButtonStyles({
          variant,
          tone,
          size,
          bleed: bleed || bleedY,
          loading
        }),
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToastContext.ButtonOverlays, { variant, tone }),
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.ButtonText,
            {
              variant,
              tone,
              size,
              loading,
              icon: icon2,
              iconPosition,
              bleed,
              children
            }
          )
        ]
      }
    ) });
  }
);
ButtonLink.displayName = "ButtonLink";
const Keyline = ({ tone, borderRadius: borderRadius2 }) => {
  const backgroundLightness = ToastContext.useBackgroundLightness();
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: "span",
      position: "absolute",
      top: 0,
      bottom: 0,
      left: 0,
      overflow: "hidden",
      borderRadius: borderRadius2,
      className: [styles_lib_components_private_Keyline_Keyline_css_cjs.noRadiusOnRight, styles_lib_components_private_Keyline_Keyline_css_cjs.largestWidth],
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ToastContext.Box,
        {
          component: "span",
          height: "full",
          display: "inlineBlock",
          className: [
            styles_lib_components_private_Keyline_Keyline_css_cjs.width,
            styles_lib_components_private_Keyline_Keyline_css_cjs.tone[tone],
            styles_lib_components_private_Keyline_Keyline_css_cjs.lightMode[backgroundLightness.lightMode],
            styles_lib_components_private_Keyline_Keyline_css_cjs.darkMode[backgroundLightness.darkMode]
          ]
        }
      )
    }
  );
};
const validCardComponents = [
  "div",
  "article",
  "aside",
  "details",
  "main",
  "section"
];
const borderRadius$2 = "large";
const Card = ({
  children,
  component = "div",
  tone,
  data,
  height,
  ...restProps
}) => {
  assert__default.default(
    validCardComponents.includes(component),
    `Invalid Card component: '${component}'. Should be one of [${validCardComponents.map((c) => `'${c}'`).join(", ")}]`
  );
  const isLegacyTheme = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.useBraidTheme().legacy;
  let resolvedRounding;
  if ("rounded" in restProps) {
    resolvedRounding = borderRadius$2;
  } else if ("roundedAbove" in restProps) {
    const [roundedOnMobile, roundedOnTablet, roundedOnDesktop, roundedOnWide] = ToastContext.resolveResponsiveRangeProps({ above: restProps.roundedAbove });
    resolvedRounding = ToastContext.optimizeResponsiveArray([
      roundedOnMobile ? borderRadius$2 : "none",
      roundedOnTablet ? borderRadius$2 : "none",
      roundedOnDesktop ? borderRadius$2 : "none",
      roundedOnWide ? borderRadius$2 : "none"
    ]);
  }
  const roundingForTheme = !isLegacyTheme ? borderRadius$2 : resolvedRounding;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      component,
      position: "relative",
      background: "surface",
      padding: "gutter",
      borderRadius: roundingForTheme,
      boxShadow: !isLegacyTheme ? "borderNeutralLight" : void 0,
      height: height === "full" ? height : void 0,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        tone ? /* @__PURE__ */ jsxRuntime.jsx(Keyline, { tone, borderRadius: roundingForTheme }) : null,
        children
      ]
    }
  );
};
const tones = ["neutral", "critical"];
const Indicator = ({
  type,
  checked,
  hover = false,
  disabled = false
}) => {
  const isCheckbox = type === "checkbox";
  const iconTone = (() => {
    if (disabled) {
      return "secondary";
    }
    if (hover) {
      return "formAccent";
    }
  })();
  return isCheckbox ? /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      height: "full",
      transition: "fast",
      position: "relative",
      className: styles_lib_components_private_InlineField_InlineField_css_cjs.checkboxIndicator,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            position: "absolute",
            inset: 0,
            transition: "fast",
            opacity: checked !== "mixed" ? 0 : void 0,
            children: /* @__PURE__ */ jsxRuntime.jsx(IconMinus, { size: "fill", tone: iconTone })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            position: "absolute",
            inset: 0,
            transition: "fast",
            opacity: checked !== true ? 0 : void 0,
            children: /* @__PURE__ */ jsxRuntime.jsx(IconTick, { size: "fill", tone: iconTone })
          }
        )
      ]
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      background: disabled ? { lightMode: "neutralLight", darkMode: "surfaceDark" } : "formAccent",
      transition: "fast",
      width: "full",
      height: "full",
      borderRadius: "full",
      className: styles_lib_components_private_InlineField_InlineField_css_cjs.radioIndicator
    }
  );
};
const StyledInput = React.forwardRef(
  ({
    id,
    name,
    value,
    checked,
    data,
    onChange,
    type,
    tone = "neutral",
    disabled = false,
    required,
    tabIndex,
    size = "standard",
    "aria-describedby": ariaDescribedBy,
    "aria-labelledby": ariaLabelledBy,
    "aria-label": ariaLabel,
    ...restProps
  }, forwardedRef) => {
    const defaultRef = React.useRef(null);
    const ref = forwardedRef || defaultRef;
    const indeterminateRef = React.useRef(false);
    if (tones.indexOf(tone) === -1) {
      throw new Error(`Invalid tone: ${tone}`);
    }
    const isCheckbox = type === "checkbox";
    const fieldBorderRadius = isCheckbox ? "standard" : "full";
    const accentBackground = disabled ? "neutralLight" : "formAccent";
    const isMixed = isCheckbox && checked === "mixed";
    const fieldBackground = disabled ? { lightMode: "neutralSoft", darkMode: "neutral" } : { lightMode: "surface" };
    const defaultBorder = checked ? "formAccent" : "default";
    React.useEffect(() => {
      if (ref && typeof ref === "object" && ref.current && isCheckbox) {
        ref.current.indeterminate = isMixed;
        indeterminateRef.current = isMixed;
      }
    }, [ref, isMixed, isCheckbox]);
    const { lightMode } = ToastContext.useBackgroundLightness();
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ToastContext.Box,
        {
          component: "input",
          type,
          id,
          name,
          value,
          onChange: isMixed ? (e) => {
            if (ref && typeof ref === "object" && ref.current) {
              ref.current.indeterminate = indeterminateRef.current;
            }
            if (typeof onChange === "function") {
              onChange(e);
            }
          } : onChange,
          checked: checked === "mixed" ? false : checked,
          position: "absolute",
          zIndex: 1,
          className: [
            styles_lib_components_private_InlineField_InlineField_css_cjs.realField,
            styles_lib_components_private_InlineField_InlineField_css_cjs.sizeVars[size],
            isMixed ? styles_lib_components_private_InlineField_InlineField_css_cjs.isMixed : void 0
          ],
          cursor: !disabled ? "pointer" : void 0,
          opacity: 0,
          "aria-describedby": ariaDescribedBy,
          "aria-labelledby": ariaLabelledBy,
          "aria-label": ariaLabel,
          "aria-checked": isMixed ? "mixed" : checked,
          "aria-required": required,
          disabled,
          ref,
          tabIndex,
          ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps })
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsxs(
        ToastContext.Box,
        {
          flexShrink: 0,
          position: "relative",
          className: [styles_lib_components_private_InlineField_InlineField_css_cjs.fakeField, styles_lib_components_private_InlineField_InlineField_css_cjs.sizeVars[size]],
          background: fieldBackground,
          borderRadius: fieldBorderRadius,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.FieldOverlay,
              {
                variant: disabled ? "disabled" : defaultBorder,
                borderRadius: fieldBorderRadius,
                visible: tone !== "critical" || disabled,
                className: {
                  [styles_lib_components_private_InlineField_InlineField_css_cjs.hideBorderOnDarkBackgroundInLightMode]: lightMode === "dark"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.FieldOverlay,
              {
                variant: "critical",
                borderRadius: fieldBorderRadius,
                visible: tone === "critical" && !disabled
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.FieldOverlay,
              {
                variant: tone === "critical" && isCheckbox ? tone : void 0,
                background: isCheckbox ? accentBackground : void 0,
                borderRadius: fieldBorderRadius,
                className: styles_lib_components_private_InlineField_InlineField_css_cjs.selected,
                children: /* @__PURE__ */ jsxRuntime.jsx(Indicator, { type, disabled, checked })
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.FieldOverlay,
              {
                variant: "focus",
                borderRadius: fieldBorderRadius,
                className: styles_lib_components_private_InlineField_InlineField_css_cjs.focusOverlay
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.FieldOverlay,
              {
                variant: "formAccent",
                borderRadius: fieldBorderRadius,
                className: styles_lib_components_private_InlineField_InlineField_css_cjs.hoverOverlay,
                children: /* @__PURE__ */ jsxRuntime.jsx(Indicator, { type, hover: true, checked: true })
              }
            )
          ]
        }
      )
    ] });
  }
);
const InlineField = React.forwardRef(
  ({
    id,
    name,
    value,
    checked,
    data,
    onChange,
    label,
    type,
    children,
    description,
    badge,
    message,
    reserveMessageSpace = false,
    tone = "neutral",
    disabled = false,
    required,
    inList = false,
    tabIndex,
    size = "standard",
    "aria-describedby": ariaDescribedBy,
    ...restProps
  }, forwardedRef) => {
    const messageId = `${id}-message`;
    const descriptionId = `${id}-description`;
    const hasMessage = message || reserveMessageSpace;
    if (process.env.NODE_ENV !== "production") {
      if (badge && badge.props.bleedY !== void 0) {
        console.warn(
          `Badge elements cannot set the \`bleedY\` prop when passed to a ${type.charAt(0).toUpperCase()}${type.slice(1)} component`
        );
      }
    }
    return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { position: "relative", children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { display: "flex", children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          StyledInput,
          {
            ...restProps,
            type,
            id,
            checked,
            name,
            value,
            data,
            onChange,
            disabled,
            tone,
            tabIndex,
            required,
            "aria-describedby": mergeIds(
              ariaDescribedBy,
              message ? messageId : void 0,
              description ? descriptionId : void 0
            ),
            size,
            ref: forwardedRef
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { paddingLeft: "small", flexGrow: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { className: [styles_lib_components_private_InlineField_InlineField_css_cjs.sizeVars[size], styles_lib_components_private_InlineField_InlineField_css_cjs.labelOffset], children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Inline, { space: "small", alignY: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                component: "label",
                htmlFor: id,
                userSelect: "none",
                display: "block",
                cursor: !disabled ? "pointer" : void 0,
                className: ToastContext.virtualTouchable(),
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Text,
                  {
                    weight: checked && !inList ? "strong" : void 0,
                    tone: disabled ? "secondary" : void 0,
                    size,
                    children: label
                  }
                )
              }
            ),
            badge ? React.cloneElement(badge, { bleedY: true }) : null
          ] }) }),
          description ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingTop: "small", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { tone: "secondary", size, id: descriptionId, children: description }) }) : null,
          children ? /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              position: "relative",
              display: "none",
              paddingTop: "small",
              className: styles_lib_components_private_InlineField_InlineField_css_cjs.children,
              children
            }
          ) : null
        ] })
      ] }),
      hasMessage ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingTop: description ? "small" : "xsmall", children: /* @__PURE__ */ jsxRuntime.jsx(
        FieldMessage,
        {
          id: messageId,
          tone,
          disabled,
          message,
          reserveMessageSpace
        }
      ) }) : null
    ] });
  }
);
const resolveCheckedGroup = (values) => values.some((value) => value !== values[0]) ? "mixed" : values[0] ?? false;
const Checkbox = React.forwardRef(
  ({ checked, ...restProps }, ref) => {
    const calculatedChecked = Array.isArray(checked) ? resolveCheckedGroup(checked) : checked;
    return /* @__PURE__ */ jsxRuntime.jsx(
      InlineField,
      {
        ...restProps,
        checked: calculatedChecked,
        type: "checkbox",
        ref
      }
    );
  }
);
Checkbox.displayName = "Checkbox";
const CheckboxStandalone = React.forwardRef(({ checked, ...restProps }, ref) => {
  const calculatedChecked = Array.isArray(checked) ? resolveCheckedGroup(checked) : checked;
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { position: "relative", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.TextContext.Provider, { value: null, children: /* @__PURE__ */ jsxRuntime.jsx(
    StyledInput,
    {
      ...restProps,
      checked: calculatedChecked,
      type: "checkbox",
      ref
    }
  ) }) });
});
const defaultParent = typeof document !== "undefined" ? document.body : null;
let counterMap = /* @__PURE__ */ new WeakMap();
let uncontrolledNodes = /* @__PURE__ */ new WeakMap();
let markerMap = {};
let lockCount = 0;
const ariaHideOthers = (originalTarget, {
  parentNode = defaultParent,
  markerName = "data-aria-hidden",
  delay = 0
} = {}) => {
  const targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const walk = (parent) => {
    if (!parent || targets.indexOf(parent) >= 0) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node) => {
      if (targets.some((target) => node.contains(target))) {
        walk(node);
      } else if (node.nodeName !== "SCRIPT" && node.nodeName !== "STYLE") {
        const attr = node.getAttribute("aria-hidden");
        const alreadyHidden = attr !== null && attr !== "false";
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute("aria-hidden", "true");
        }
      }
    });
  };
  const timeout = delay ? setTimeout(() => walk(parentNode), delay) : (walk(parentNode), null);
  lockCount++;
  return () => {
    if (timeout) {
      clearTimeout(timeout);
    }
    hiddenNodes.forEach((node) => {
      const counterValue = (counterMap.get(node) ?? 1) - 1;
      const markerValue = (markerCounter.get(node) ?? 1) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute("aria-hidden");
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
const resolveDefaultComponent = {
  "1": "h1",
  "2": "h2",
  "3": "h3",
  "4": "h4"
};
const Heading = ({
  level,
  weight,
  component,
  ...typographyProps
}) => /* @__PURE__ */ jsxRuntime.jsx(ToastContext.HeadingContext.Provider, { value: true, children: /* @__PURE__ */ jsxRuntime.jsx(
  ToastContext.Typography,
  {
    ...typographyProps,
    component: component || resolveDefaultComponent[level],
    className: [
      styles_lib_css_typography_css_cjs.fontFamily,
      styles_lib_css_typography_css_cjs.headingWeight[weight || "regular"],
      styles_lib_css_typography_css_cjs.heading[level],
      styles_lib_css_typography_css_cjs.tone.neutral
    ]
  }
) });
const validPageBlockComponents = [
  "div",
  "article",
  "aside",
  "main",
  "section",
  "nav"
];
const gutters = { mobile: "xsmall", tablet: "gutter" };
const PageBlock = ({
  children,
  width = "large",
  component: componentProp,
  data,
  ...restProps
}) => {
  const component = componentProp && validPageBlockComponents.includes(componentProp) ? componentProp : "div";
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component,
      paddingX: gutters,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.ContentBlock, { width, children })
    }
  );
};
const modalPadding = { mobile: "gutter", tablet: "large" };
const ModalContentHeader = React.forwardRef(
  ({ title, headingLevel, description, descriptionId, center }, ref) => /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Stack,
    {
      space: headingLevel === "2" ? { mobile: "small", tablet: "medium" } : "small",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(Heading, { level: headingLevel, align: center ? "center" : void 0, children: /* @__PURE__ */ jsxRuntime.jsxs(
          ToastContext.Box,
          {
            ref,
            component: "span",
            tabIndex: -1,
            outline: "none",
            position: "relative",
            className: styles_lib_components_private_Modal_Modal_css_cjs.headingRoot,
            children: [
              title,
              /* @__PURE__ */ jsxRuntime.jsx(
                ToastContext.Overlay,
                {
                  boxShadow: "outlineFocus",
                  borderRadius: "standard",
                  transition: "fast",
                  className: styles_lib_components_private_Modal_Modal_css_cjs.headingFocus,
                  onlyVisibleForKeyboardNavigation: true
                }
              )
            ]
          }
        ) }),
        description ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { id: descriptionId, children: description }) : null
      ]
    }
  )
);
const ModalContent = ({
  id,
  children,
  description,
  onClose,
  width,
  closeLabel = "Close",
  illustration,
  title,
  headingRef: headingRefProp,
  modalRef: modalRefProp,
  scrollLock = true,
  position,
  headingLevel,
  data,
  ...restProps
}) => {
  const defaultModalRef = React.useRef(null);
  const modalRef = modalRefProp || defaultModalRef;
  const defaultHeadingRef = React.useRef(null);
  const headingRef = headingRefProp || defaultHeadingRef;
  const descriptionId = `${id}_desc`;
  const handleEscape = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === "Escape") {
      event.stopPropagation();
      onClose();
    }
  };
  const justifyContent = { left: "flexStart", center: "center", right: "flexEnd" }[position];
  const modalRadius = position === "center" ? "xlarge" : void 0;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      role: "dialog",
      "aria-label": title,
      "aria-describedby": description ? descriptionId : void 0,
      "aria-modal": "true",
      id,
      onKeyDown: handleEscape,
      position: "relative",
      width: "full",
      height: "full",
      display: "flex",
      alignItems: "center",
      justifyContent,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        ToastContext.Box,
        {
          position: "relative",
          display: "flex",
          alignItems: "center",
          justifyContent,
          height: position === "right" || position === "left" ? "full" : void 0,
          overflow: position !== "center" ? "hidden" : void 0,
          boxShadow: "large",
          borderRadius: modalRadius,
          width: width !== "content" ? "full" : void 0,
          maxWidth: width !== "content" ? width : void 0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(reactRemoveScroll.RemoveScroll, { ref: modalRef, forwardProps: true, enabled: scrollLock, children: /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                background: "surface",
                borderRadius: modalRadius,
                overflow: "auto",
                position: "relative",
                width: width !== "content" ? "full" : void 0,
                height: position === "right" || position === "left" ? "full" : void 0,
                paddingY: modalPadding,
                paddingX: position !== "center" ? gutters : modalPadding,
                className: [
                  styles_lib_components_private_Modal_Modal_css_cjs.pointerEventsAll,
                  position === "center" && styles_lib_components_private_Modal_Modal_css_cjs.maxSize[position]
                ],
                ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
                children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Stack, { space: "large", children: [
                  illustration ? /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Stack, { space: "medium", align: "center", children: [
                    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingX: "gutter", children: illustration }),
                    /* @__PURE__ */ jsxRuntime.jsx(
                      ModalContentHeader,
                      {
                        title,
                        headingLevel,
                        description,
                        descriptionId,
                        center: Boolean(illustration),
                        ref: headingRef
                      }
                    )
                  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Columns, { space: "none", children: [
                    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { children: /* @__PURE__ */ jsxRuntime.jsx(
                      ModalContentHeader,
                      {
                        title,
                        headingLevel,
                        description,
                        descriptionId,
                        center: Boolean(illustration),
                        ref: headingRef
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { width: "content", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { width: "touchable" }) })
                  ] }),
                  /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children })
                ] })
              }
            ) }),
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                position: "absolute",
                zIndex: "sticky",
                top: 0,
                pointerEvents: "none",
                width: "full",
                display: "flex",
                justifyContent: "flexEnd",
                paddingTop: modalPadding,
                paddingRight: position !== "center" ? gutters : modalPadding,
                className: position === "center" && styles_lib_components_private_Modal_Modal_css_cjs.maxSize[position],
                children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Bleed, { space: "xsmall", children: /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Box,
                  {
                    position: "relative",
                    background: "surface",
                    borderRadius: "full",
                    padding: "xsmall",
                    className: [styles_lib_components_private_Modal_Modal_css_cjs.closeIconOffset, styles_lib_components_private_Modal_Modal_css_cjs.pointerEventsAll],
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      ToastContext.ButtonIcon,
                      {
                        id: `${id}-close`,
                        label: closeLabel,
                        icon: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconClear, {}),
                        tone: "secondary",
                        variant: "transparent",
                        size: "large",
                        onClick: onClose
                      }
                    )
                  }
                ) })
              }
            )
          ]
        }
      )
    }
  );
};
const AllowCloseContext = React.createContext(true);
const ModalPortal = ({ children }) => {
  const [modalElement, setElement] = React.useState(null);
  React.useEffect(() => {
    const modalContainerId = "braid-modal-container";
    let element = document.getElementById(modalContainerId);
    if (!element) {
      element = document.createElement("div");
      element.setAttribute("id", modalContainerId);
      element.setAttribute("class", styles_lib_components_private_Modal_Modal_css_cjs.fixedStackingContext);
      document.body.appendChild(element);
    }
    setElement(element);
  }, []);
  if (!modalElement) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.BraidPortal, { container: modalElement, children });
};
const OPEN_MODAL = 1;
const CLOSE_MODAL = 2;
const ANIMATION_COMPLETE = 3;
const INITIAL = 1;
const OPEN = 2;
const OPENING = 3;
const CLOSED = 4;
const CLOSING = 5;
const reducer = (prevState, action) => {
  switch (action) {
    case OPEN_MODAL: {
      switch (prevState) {
        case INITIAL:
        case CLOSING:
        case CLOSED: {
          return OPENING;
        }
      }
    }
    case CLOSE_MODAL: {
      switch (prevState) {
        case OPEN:
        case OPENING: {
          return CLOSING;
        }
      }
    }
    case ANIMATION_COMPLETE: {
      switch (prevState) {
        case CLOSING: {
          return CLOSED;
        }
        case OPENING: {
          return OPEN;
        }
      }
    }
  }
  return prevState;
};
const ANIMATION_DURATION = 300;
const Modal = ({
  id,
  open,
  children,
  description,
  onClose,
  width,
  closeLabel,
  illustration,
  title,
  headingLevel,
  position,
  ...restProps
}) => {
  const [trapActive, setTrapActive] = React.useState(true);
  const [state, dispatch] = React.useReducer(reducer, INITIAL);
  const allowClose = React.useContext(AllowCloseContext);
  const shouldFocus = typeof document !== "undefined" && typeof document.hasFocus === "function" && document.hasFocus();
  const openRef = React.useRef(open);
  const modalRef = React.useRef(null);
  const headingRef = React.useRef(null);
  const closeHandlerRef = React.useRef(onClose);
  const initiateClose = () => {
    if (allowClose) {
      const result = closeHandlerRef.current(false);
      if (result === false) {
        return result;
      }
      if (openRef.current) {
        dispatch(CLOSE_MODAL);
      }
    }
  };
  React.useEffect(() => {
    openRef.current = open;
    dispatch(open ? OPEN_MODAL : CLOSE_MODAL);
  }, [open]);
  const closing = state === CLOSING;
  React.useEffect(() => {
    if (closing) {
      const timer = setTimeout(() => {
        dispatch(ANIMATION_COMPLETE);
      }, ANIMATION_DURATION);
      return () => clearTimeout(timer);
    }
  }, [closing]);
  const shouldAriaHideOthers = state === OPEN || state === CLOSING;
  React.useEffect(() => {
    if (shouldAriaHideOthers && modalRef.current) {
      return ariaHideOthers(modalRef.current, { delay: ANIMATION_DURATION });
    }
  }, [shouldAriaHideOthers]);
  React.useEffect(() => {
    if (typeof onClose === "function") {
      closeHandlerRef.current = onClose;
    }
  }, [onClose]);
  React.useEffect(() => {
    const event = trapActive ? "blur" : "focus";
    const handleEvent = () => setTrapActive(!trapActive);
    window.addEventListener(event, handleEvent);
    return () => {
      window.removeEventListener(event, handleEvent);
    };
  }, [trapActive]);
  return state === OPENING || state === OPEN || state === CLOSING ? /* @__PURE__ */ jsxRuntime.jsx(ModalPortal, { children: /* @__PURE__ */ jsxRuntime.jsxs(
    FocusLock__default.default,
    {
      className: styles_lib_components_private_Modal_Modal_css_cjs.resetStackingContext,
      disabled: !trapActive,
      autoFocus: false,
      onActivation: () => {
        if (state === OPEN) {
          return;
        }
        if (headingRef.current && shouldFocus) {
          headingRef.current.focus();
        }
        dispatch(ANIMATION_COMPLETE);
      },
      returnFocus: true,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            onClick: state === OPEN ? initiateClose : void 0,
            position: "fixed",
            inset: 0,
            zIndex: "modalBackdrop",
            transition: position === "center" ? "fast" : void 0,
            opacity: state !== OPEN ? 0 : void 0,
            pointerEvents: state === CLOSING ? "none" : void 0,
            className: [
              styles_lib_components_private_Modal_Modal_css_cjs.backdrop,
              position === "left" || position === "right" && styles_lib_components_private_Modal_Modal_css_cjs.horiztontalTransition
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            position: "fixed",
            inset: 0,
            zIndex: "modal",
            pointerEvents: "none",
            transition: "fast",
            opacity: state !== OPEN ? 0 : void 0,
            paddingLeft: position === "right" ? ["none", "xlarge"] : void 0,
            paddingRight: position === "left" ? ["none", "xlarge"] : void 0,
            padding: position === "center" ? styles_lib_components_private_Modal_ModalExternalGutter_cjs.externalGutter : void 0,
            className: [
              styles_lib_components_private_Modal_Modal_css_cjs.modalContainer,
              (position === "left" || position === "right") && styles_lib_components_private_Modal_Modal_css_cjs.horiztontalTransition,
              state === OPENING && styles_lib_components_private_Modal_Modal_css_cjs.entrance[position],
              state === CLOSING && position in styles_lib_components_private_Modal_Modal_css_cjs.exit && styles_lib_components_private_Modal_Modal_css_cjs.exit[position]
            ],
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ModalContent,
              {
                id,
                description,
                onClose: initiateClose,
                width,
                closeLabel,
                illustration,
                title,
                headingLevel,
                headingRef,
                modalRef,
                position,
                scrollLock: !(state === CLOSING),
                ...restProps,
                children
              }
            )
          }
        )
      ]
    }
  ) }) : null;
};
const defaultWidth$1 = "small";
const modalStyle$1 = {
  position: "center",
  headingLevel: "3"
};
const Dialog = ({ width = defaultWidth$1, ...restProps }) => /* @__PURE__ */ jsxRuntime.jsx(Modal, { width, ...restProps, ...modalStyle$1 });
const Disclosure = ({
  id,
  expandLabel,
  collapseLabel = expandLabel,
  space = "medium",
  children,
  data,
  weight,
  ...restProps
}) => {
  assert__default.default(
    typeof expandLabel === "undefined" || typeof expandLabel === "string",
    "'expandLabel' must be a string"
  );
  assert__default.default(
    typeof collapseLabel === "undefined" || typeof collapseLabel === "string",
    "'collapseLabel' must be a string"
  );
  const textContext = React.useContext(ToastContext.TextContext);
  const headingContext = React.useContext(ToastContext.HeadingContext);
  const isInline = Boolean(textContext || headingContext);
  const { expanded, buttonProps, contentProps } = useDisclosure({
    id,
    ...restProps.expanded !== void 0 ? {
      onToggle: restProps.onToggle,
      expanded: restProps.expanded
    } : {
      onToggle: restProps.onToggle
    }
  });
  const trigger = /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.TextLinkButton, { hitArea: "large", weight, ...buttonProps, children: [
    expanded ? collapseLabel : expandLabel,
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.AvoidWidowIcon, { iconPosition: "trailing", children: /* @__PURE__ */ jsxRuntime.jsx(IconChevron, { direction: expanded ? "up" : "down", alignY: "lowercase" }) })
  ] });
  const component = isInline ? "span" : "div";
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      component,
      display: isInline ? "inline" : void 0,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component,
            display: isInline ? "inline" : void 0,
            userSelect: "none",
            children: isInline ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
              " ",
              trigger
            ] }) : /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { children: trigger })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component,
            paddingTop: space,
            display: expanded ? "block" : "none",
            ...contentProps,
            children
          }
        )
      ]
    }
  );
};
const validWidths = ["small", "medium", "large"];
const validPositions = ["left", "right"];
const defaultWidth = "medium";
const defaultPosition = "right";
const modalStyle = {
  headingLevel: "2",
  illustration: void 0
};
const Drawer = ({
  width = defaultWidth,
  position = defaultPosition,
  ...restProps
}) => {
  assert__default.default(validWidths.indexOf(width) >= 0, `Invalid width: ${width}`);
  assert__default.default(
    validPositions.indexOf(position) >= 0,
    `Invalid position: ${position}`
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Modal, { width, position, ...restProps, ...modalStyle });
};
const Dropdown = React.forwardRef(
  (props, ref) => {
    const {
      children,
      value,
      onChange,
      onBlur,
      onFocus,
      placeholder,
      disabled,
      ...restProps
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(
      Field,
      {
        ...restProps,
        disabled,
        labelId: void 0,
        prefix: void 0,
        secondaryMessage: null,
        value,
        children: (overlays, { className, paddingRight, ...fieldProps }, icon2) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
          icon2,
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              component: "select",
              value,
              defaultValue: typeof value === "undefined" ? "" : void 0,
              onChange,
              onBlur,
              onFocus,
              placeholder,
              className: [styles_lib_components_Dropdown_Dropdown_css_cjs.field, className],
              ...fieldProps,
              ref,
              children: /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
                !value || placeholder ? /* @__PURE__ */ jsxRuntime.jsx("option", { value: "", disabled: true, children: disabled ? "" : placeholder }) : null,
                children
              ] })
            }
          ),
          overlays,
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              position: "absolute",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              pointerEvents: "none",
              height: "touchable",
              width: "touchable",
              top: 0,
              right: 0,
              children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { baseline: false, children: /* @__PURE__ */ jsxRuntime.jsx(IconChevron, { tone: disabled ? "secondary" : void 0 }) })
            }
          )
        ] })
      }
    );
  }
);
Dropdown.displayName = "Dropdown";
const Link = React.forwardRef(
  ({ href, className, data, ...restProps }, ref) => {
    const LinkComponent = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.useLinkComponent(ref);
    return /* @__PURE__ */ jsxRuntime.jsx(
      LinkComponent,
      {
        ref,
        href,
        className: clsx__default.default(styles_lib_css_atoms_atoms_cjs.atoms({ reset: "a" }), className),
        ...restProps,
        ...ToastContext.buildDataAttributes({ data, validateRestProps: false })
      }
    );
  }
);
Link.displayName = "Link";
function numberToAlpha(inputNumber) {
  let returnValue = "";
  let counter = inputNumber;
  while (counter > 0) {
    const t = (counter - 1) % 26;
    returnValue = String.fromCharCode(97 + t) + returnValue;
    counter = (counter - t) / 26 | 0;
  }
  return returnValue;
}
const romanNumerals = {
  m: 1e3,
  cm: 900,
  d: 500,
  cd: 400,
  c: 100,
  xc: 90,
  l: 50,
  xl: 40,
  x: 10,
  ix: 9,
  v: 5,
  iv: 4,
  i: 1
};
function numberToRomanNumerals(inputNumber) {
  let returnValue = "";
  let counter = inputNumber;
  Object.keys(romanNumerals).forEach(
    (romanNumeral) => {
      const value = romanNumerals[romanNumeral];
      while (counter >= value) {
        returnValue += romanNumeral;
        counter -= value;
      }
    }
  );
  return returnValue;
}
const CharacterBullet = ({ length = 1, children }) => /* @__PURE__ */ jsxRuntime.jsxs(
  ToastContext.Box,
  {
    display: "inlineBlock",
    className: [
      styles_lib_components_List_List_css_cjs.minCharacterWidth[length - 1] ?? styles_lib_components_List_List_css_cjs.minCharacterWidth[styles_lib_components_List_List_css_cjs.minCharacterWidth.length - 1],
      styles_lib_components_List_List_css_cjs.trimGutter
    ],
    children: [
      children,
      "."
    ]
  }
);
const List = ({
  children,
  size: sizeProp,
  tone: toneProp,
  space = "medium",
  type = "bullet",
  start = 1,
  data,
  ...restProps
}) => {
  const { size, tone } = ToastContext.useDefaultTextProps({
    size: sizeProp,
    tone: toneProp
  });
  const listItems = ToastContext.flattenChildren(children);
  const lastNumberLength = type === "number" ? (listItems.length + (start - 1)).toString().length : -1;
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.DefaultTextPropsProvider, { size, tone, children: /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Stack,
    {
      component: /^(bullet|icon)$/.test(type) ? "ul" : "ol",
      space,
      data,
      children: React.Children.map(listItems, (listItem, index) => {
        const resolvedIndex = index + (start - 1);
        return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { display: "flex", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { component: "div", size, tone, children: /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              display: "flex",
              alignItems: /^(bullet|icon)$/.test(type) ? "center" : void 0,
              className: styles_lib_css_lineHeightContainer_css_cjs.lineHeightContainer[size],
              userSelect: "none",
              "aria-hidden": true,
              children: (() => {
                if (type === "number") {
                  return /* @__PURE__ */ jsxRuntime.jsx(CharacterBullet, { length: lastNumberLength, children: resolvedIndex + 1 });
                }
                if (type === "alpha") {
                  return /* @__PURE__ */ jsxRuntime.jsx(CharacterBullet, { children: numberToAlpha(resolvedIndex + 1) });
                }
                if (type === "roman") {
                  return /* @__PURE__ */ jsxRuntime.jsx(CharacterBullet, { length: 2, children: numberToRomanNumerals(resolvedIndex + 1) });
                }
                if (type === "icon" && "icon" in restProps) {
                  return restProps.icon;
                }
                return /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Box,
                  {
                    borderRadius: "full",
                    className: [styles_lib_components_List_List_css_cjs.currentColor, styles_lib_components_List_List_css_cjs.size[size]]
                  }
                );
              })()
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              minWidth: 0,
              width: "full",
              paddingLeft: size === "xsmall" ? "xsmall" : "small",
              children: listItem
            }
          )
        ] });
      })
    }
  ) });
};
const Loader = ({
  size = "standard",
  "aria-label": ariaLabel = "Loading",
  delayVisibility = false,
  data,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  ToastContext.Box,
  {
    display: "flex",
    alignItems: "center",
    className: [
      styles_lib_components_Loader_Loader_css_cjs.rootSize[size],
      delayVisibility ? styles_lib_components_Loader_Loader_css_cjs.delay : void 0
    ],
    "aria-label": ariaLabel,
    role: "alert",
    "aria-live": "assertive",
    ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
    children: /* @__PURE__ */ jsxRuntime.jsxs(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        className: [
          styles_lib_css_atoms_atoms_cjs.atoms({ reset: "svg" }),
          styles_lib_components_Loader_Loader_css_cjs.size[size],
          styles_lib_components_Loader_Loader_css_cjs.currentColor,
          styles_lib_css_typography_css_cjs.tone.neutral
        ].join(" "),
        viewBox: "0 0 302 134",
        "aria-hidden": true,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx("circle", { className: styles_lib_components_Loader_Loader_css_cjs.circle, cy: "67", cx: "40", r: "40" }),
          /* @__PURE__ */ jsxRuntime.jsx("circle", { className: styles_lib_components_Loader_Loader_css_cjs.circle, cy: "67", cx: "150", r: "40" }),
          /* @__PURE__ */ jsxRuntime.jsx("circle", { className: styles_lib_components_Loader_Loader_css_cjs.circle, cy: "67", cx: "260", r: "40" })
        ]
      }
    )
  }
);
const MenuRendererContext = React.createContext(
  null
);
const MenuItemDivider = () => {
  assert__default.default(
    React.useContext(MenuRendererContext),
    "MenuItemDivider must be rendered within a menu component. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/MenuItemDivider"
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingY: "xxsmall", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Divider, {}) });
};
MenuItemDivider.__isMenuItem__ = true;
const actionTypes = {
  MENU_TRIGGER_UP: 0,
  MENU_ITEM_UP: 1,
  MENU_TRIGGER_DOWN: 2,
  MENU_ITEM_DOWN: 3,
  MENU_ITEM_ESCAPE: 4,
  MENU_ITEM_TAB: 5,
  MENU_ITEM_ENTER: 6,
  MENU_ITEM_SPACE: 7,
  MENU_ITEM_CLICK: 8,
  MENU_ITEM_HOVER: 9,
  MENU_TRIGGER_ENTER: 10,
  MENU_TRIGGER_SPACE: 11,
  MENU_TRIGGER_CLICK: 12,
  MENU_TRIGGER_TAB: 13,
  MENU_TRIGGER_ESCAPE: 14,
  BACKDROP_CLICK: 15
};
const MenuRendererItemContext = React.createContext(null);
const {
  MENU_TRIGGER_UP,
  MENU_ITEM_UP: MENU_ITEM_UP$1,
  MENU_TRIGGER_DOWN,
  MENU_ITEM_DOWN: MENU_ITEM_DOWN$1,
  MENU_ITEM_ESCAPE: MENU_ITEM_ESCAPE$1,
  MENU_ITEM_TAB: MENU_ITEM_TAB$1,
  MENU_ITEM_ENTER: MENU_ITEM_ENTER$1,
  MENU_ITEM_SPACE: MENU_ITEM_SPACE$1,
  MENU_ITEM_CLICK: MENU_ITEM_CLICK$1,
  MENU_ITEM_HOVER: MENU_ITEM_HOVER$1,
  MENU_TRIGGER_ENTER,
  MENU_TRIGGER_SPACE,
  MENU_TRIGGER_CLICK,
  MENU_TRIGGER_TAB,
  MENU_TRIGGER_ESCAPE,
  BACKDROP_CLICK
} = actionTypes;
const CLOSED_INDEX = -1;
const CLOSE_REASON_EXIT = { reason: "exit" };
const initialState = {
  open: false,
  highlightIndex: CLOSED_INDEX,
  closeReason: CLOSE_REASON_EXIT
};
const MenuRenderer = ({
  onOpen,
  onClose,
  trigger,
  width = "content",
  align = "left",
  offsetSpace = "none",
  reserveIconSpace = false,
  placement = "bottom",
  children,
  data,
  ...restProps
}) => {
  const buttonRef = React.useRef(null);
  const lastOpen = React.useRef(false);
  const items = ToastContext.flattenChildren(children);
  const itemCount = items.filter((item) => !isDivider(item)).length;
  assert__default.default(
    items.every(
      (item) => typeof item === "object" && "type" in item && // @ts-expect-error
      item.type.__isMenuItem__
    ),
    "All child nodes within a menu component must be a MenuItem, MenuItemLink, MenuItemCheckbox or MenuItemDivider: https://seek-oss.github.io/braid-design-system/components/MenuRenderer"
  );
  const [{ open, highlightIndex, closeReason }, dispatch] = React.useReducer(
    (state, action) => {
      switch (action.type) {
        case MENU_TRIGGER_UP:
        case MENU_ITEM_UP$1: {
          return {
            ...state,
            open: true,
            closeReason: CLOSE_REASON_EXIT,
            highlightIndex: getNextIndex(-1, state.highlightIndex, itemCount)
          };
        }
        case MENU_TRIGGER_DOWN:
        case MENU_ITEM_DOWN$1: {
          return {
            ...state,
            open: true,
            closeReason: CLOSE_REASON_EXIT,
            highlightIndex: getNextIndex(1, state.highlightIndex, itemCount)
          };
        }
        case BACKDROP_CLICK:
        case MENU_TRIGGER_ESCAPE:
        case MENU_TRIGGER_TAB:
        case MENU_ITEM_ESCAPE$1:
        case MENU_ITEM_TAB$1: {
          return {
            ...state,
            open: false,
            closeReason: CLOSE_REASON_EXIT,
            highlightIndex: CLOSED_INDEX
          };
        }
        case MENU_ITEM_ENTER$1:
        case MENU_ITEM_SPACE$1:
        case MENU_ITEM_CLICK$1: {
          if ("formElement" in action && action.formElement) {
            return state;
          }
          return {
            ...state,
            open: false,
            closeReason: {
              reason: "selection",
              index: action.index,
              id: action.id
            },
            highlightIndex: CLOSED_INDEX
          };
        }
        case MENU_ITEM_HOVER$1: {
          return { ...state, highlightIndex: action.value };
        }
        case MENU_TRIGGER_ENTER:
        case MENU_TRIGGER_SPACE: {
          const nextOpen = !state.open;
          return {
            ...state,
            open: nextOpen,
            closeReason: CLOSE_REASON_EXIT,
            highlightIndex: nextOpen ? 0 : CLOSED_INDEX
          };
        }
        case MENU_TRIGGER_CLICK: {
          const nextOpen = !state.open;
          return {
            ...state,
            open: nextOpen,
            closeReason: CLOSE_REASON_EXIT
          };
        }
        default:
          return state;
      }
    },
    initialState
  );
  React.useEffect(() => {
    if (lastOpen.current === open) {
      return;
    }
    if (open && typeof onOpen === "function") {
      onOpen();
    } else if (!open && typeof onClose === "function") {
      onClose(closeReason);
    }
    lastOpen.current = open;
  }, [onOpen, onClose, open, closeReason]);
  const focusTrigger = () => {
    if (buttonRef && buttonRef.current) {
      buttonRef.current.focus();
    }
  };
  const onTriggerKeyUp = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === " " && /firefox|iceweasel|fxios/i.test(navigator.userAgent)) {
      return;
    }
    const action = {
      ArrowDown: { type: MENU_TRIGGER_DOWN },
      ArrowUp: { type: MENU_TRIGGER_UP },
      Enter: { type: MENU_TRIGGER_ENTER },
      " ": { type: MENU_TRIGGER_SPACE },
      Escape: { type: MENU_TRIGGER_ESCAPE }
    };
    if (action[targetKey]) {
      dispatch(action[targetKey]);
    }
  };
  const onTriggerKeyDown = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === "Tab") {
      dispatch({ type: MENU_ITEM_TAB$1 });
    }
    const isArrowPress = targetKey.indexOf("Arrow") === 0;
    const isActionKeyPress = targetKey === "Enter" || targetKey === " ";
    if (isArrowPress || isActionKeyPress) {
      event.preventDefault();
    }
  };
  const triggerProps = {
    "aria-haspopup": true,
    "aria-expanded": open,
    role: "button",
    tabIndex: 0,
    ref: buttonRef,
    onKeyUp: onTriggerKeyUp,
    onKeyDown: onTriggerKeyDown,
    onClick: (event) => {
      event.stopPropagation();
      event.preventDefault();
      dispatch({ type: MENU_TRIGGER_CLICK });
    }
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }), children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { position: "relative", children: [
      trigger(triggerProps, { open }),
      /* @__PURE__ */ jsxRuntime.jsx(
        Menu,
        {
          open,
          align,
          width,
          placement,
          offsetSpace,
          highlightIndex,
          reserveIconSpace,
          focusTrigger,
          dispatch,
          children: items
        }
      )
    ] }),
    open ? /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        onClick: (event) => {
          event.stopPropagation();
          event.preventDefault();
          dispatch({ type: BACKDROP_CLICK });
        },
        position: "fixed",
        zIndex: "dropdownBackdrop",
        top: 0,
        left: 0,
        className: styles_lib_components_MenuRenderer_MenuRenderer_css_cjs.backdrop
      }
    ) : null
  ] });
};
const isDivider = (node) => typeof node === "object" && node !== null && "type" in node && node.type === MenuItemDivider;
const borderRadius$1 = "large";
function Menu({
  offsetSpace,
  align,
  width,
  placement,
  children,
  open,
  dispatch,
  focusTrigger,
  highlightIndex,
  reserveIconSpace,
  position = "absolute"
}) {
  let dividerCount = 0;
  return /* @__PURE__ */ jsxRuntime.jsx(MenuRendererContext.Provider, { value: { reserveIconSpace }, children: /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      role: "menu",
      position,
      zIndex: "dropdown",
      boxShadow: placement === "top" ? "small" : "medium",
      borderRadius: borderRadius$1,
      background: "surface",
      marginTop: placement === "bottom" ? offsetSpace : void 0,
      marginBottom: placement === "top" ? offsetSpace : void 0,
      transition: "fast",
      right: align === "right" ? 0 : void 0,
      opacity: !open ? 0 : void 0,
      overflow: "hidden",
      className: [
        !open && styles_lib_components_MenuRenderer_MenuRenderer_css_cjs.menuIsClosed,
        width !== "content" && styles_lib_components_MenuRenderer_MenuRenderer_css_cjs.width[width],
        placement === "top" && styles_lib_components_MenuRenderer_MenuRenderer_css_cjs.placementBottom
      ],
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { paddingY: "xxsmall", children: React.Children.map(children, (item, i) => {
          if (isDivider(item)) {
            dividerCount++;
            return item;
          }
          const menuItemIndex = i - dividerCount;
          return /* @__PURE__ */ jsxRuntime.jsx(
            MenuRendererItemContext.Provider,
            {
              value: {
                isHighlighted: menuItemIndex === highlightIndex,
                index: menuItemIndex,
                dispatch,
                focusTrigger
              },
              children: item
            },
            menuItemIndex
          );
        }) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            boxShadow: "borderNeutralLight",
            borderRadius: borderRadius$1,
            visible: true
          }
        )
      ]
    }
  ) });
}
const {
  MENU_ITEM_UP,
  MENU_ITEM_DOWN,
  MENU_ITEM_ESCAPE,
  MENU_ITEM_TAB,
  MENU_ITEM_ENTER,
  MENU_ITEM_SPACE,
  MENU_ITEM_CLICK,
  MENU_ITEM_HOVER
} = actionTypes;
const menuItemChildrenSize = "standard";
const menuItemPaddingSize = "small";
function useMenuItem({
  displayName = "MenuItem",
  formElement = false,
  tone,
  onClick,
  data,
  id,
  ...restProps
}) {
  const menuRendererItemContext = React.useContext(MenuRendererItemContext);
  assert__default.default(
    menuRendererItemContext !== null,
    `${displayName} must be rendered as an immediate child of a menu. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/MenuItem`
  );
  if (menuRendererItemContext === null) {
    throw new Error(`${displayName} element rendered outside menu context`);
  }
  const { isHighlighted, index, dispatch, focusTrigger } = menuRendererItemContext;
  const menuItemRef = React.useRef(null);
  React.useEffect(() => {
    var _a;
    if (isHighlighted) {
      (_a = menuItemRef.current) == null ? void 0 : _a.focus();
    }
  }, [isHighlighted]);
  const onKeyDown = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === "Tab") {
      dispatch({ type: MENU_ITEM_TAB });
    }
    const isArrowPress = targetKey.indexOf("Arrow") === 0;
    const isActionKeyPress = targetKey === "Enter" || targetKey === " ";
    if (isArrowPress || isActionKeyPress) {
      event.preventDefault();
    }
  };
  const onKeyUp = (event) => {
    var _a;
    const targetKey = normalizeKey(event);
    const closeActionKeys = ["Enter", " ", "Escape"];
    const action = {
      ArrowDown: { type: MENU_ITEM_DOWN },
      ArrowUp: { type: MENU_ITEM_UP },
      Enter: { type: MENU_ITEM_ENTER, formElement, index, id },
      " ": { type: MENU_ITEM_SPACE, formElement, index, id },
      Escape: { type: MENU_ITEM_ESCAPE }
    };
    if (action[targetKey]) {
      dispatch(action[targetKey]);
    }
    if (targetKey === "Enter" || targetKey === " ") {
      (_a = menuItemRef.current) == null ? void 0 : _a.click();
    }
    if (!formElement && closeActionKeys.indexOf(targetKey) > -1 || formElement && targetKey === "Escape") {
      focusTrigger();
    }
  };
  const hoverBackground = tone === "critical" ? "criticalLight" : "formAccentSoft";
  return {
    MenuItemChildren,
    menuItemProps: {
      role: "menuitem",
      tabIndex: -1,
      ref: menuItemRef,
      id,
      onKeyUp,
      onKeyDown,
      onMouseEnter: () => dispatch({ type: MENU_ITEM_HOVER, value: index }),
      onClick: (event) => {
        event.stopPropagation();
        dispatch({ type: MENU_ITEM_CLICK, formElement, index, id });
        if (typeof onClick === "function") {
          onClick();
        }
      },
      background: isHighlighted ? hoverBackground : void 0,
      className: [
        styles_lib_components_MenuItem_useMenuItem_css_cjs.menuItem,
        styles_lib_css_typography_css_cjs.touchableText[menuItemChildrenSize],
        styles_lib_css_atoms_atoms_cjs.atoms({
          display: "block",
          width: "full",
          paddingX: menuItemPaddingSize,
          cursor: "pointer",
          textAlign: "left",
          outline: "none"
        })
      ],
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps })
    }
  };
}
function MenuItemChildren({
  icon: icon2,
  tone,
  children,
  badge,
  formElement = false
}) {
  const menuRendererContext = React.useContext(MenuRendererContext);
  assert__default.default(
    menuRendererContext !== null,
    `MenuItem must be rendered as an immediate child of a menu. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/MenuItem`
  );
  assert__default.default(
    // @ts-expect-error
    !badge || badge.type.__isBadge__,
    `MenuItem badge prop can only be an instance of Badge. e.g. <MenuItem badge={<Badge>New</Badge>}>`
  );
  let leftSlot = null;
  if (!formElement) {
    if (icon2) {
      leftSlot = /* @__PURE__ */ jsxRuntime.jsx(
        ToastContext.Text,
        {
          size: menuItemChildrenSize,
          baseline: false,
          tone: tone === "critical" ? tone : void 0,
          children: icon2
        }
      );
    } else if (menuRendererContext.reserveIconSpace) {
      leftSlot = /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "span", display: "block", className: ToastContext.iconSize() });
    }
  }
  return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { component: "span", display: "flex", alignItems: "center", minWidth: 0, children: [
    leftSlot ? /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        component: "span",
        paddingRight: menuItemPaddingSize,
        flexShrink: 0,
        minWidth: 0,
        children: leftSlot
      }
    ) : null,
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "span", minWidth: 0, children: /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Text,
      {
        size: menuItemChildrenSize,
        baseline: false,
        tone: tone === "critical" ? tone : void 0,
        maxLines: 1,
        children
      }
    ) }),
    badge ? /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        component: "span",
        paddingLeft: menuItemPaddingSize,
        flexShrink: 0,
        minWidth: 0,
        children: badge
      }
    ) : null
  ] });
}
const MenuItem = ({
  children,
  onClick,
  data,
  tone,
  badge,
  icon: icon2,
  id
}) => {
  const { menuItemProps, MenuItemChildren: MenuItemChildren2 } = useMenuItem({
    tone,
    onClick,
    data,
    id
  });
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { ...menuItemProps, component: "button", type: "button", children: /* @__PURE__ */ jsxRuntime.jsx(MenuItemChildren2, { tone, icon: icon2, badge, children }) });
};
MenuItem.__isMenuItem__ = true;
const MenuItemCheckbox = ({
  children,
  onChange,
  checked,
  data,
  badge,
  id
}) => {
  const { menuItemProps, MenuItemChildren: MenuItemChildren2 } = useMenuItem({
    onClick: () => onChange(!checked),
    formElement: true,
    data,
    id
  });
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      ...menuItemProps,
      "aria-checked": checked,
      role: "menuitemcheckbox",
      component: "button",
      type: "button",
      display: "flex",
      alignItems: "center",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "span",
            borderRadius: "standard",
            boxShadow: "borderField",
            position: "relative",
            background: { lightMode: "surface" },
            marginRight: "small",
            flexShrink: 0,
            className: styles_lib_components_MenuItemCheckbox_MenuItemCheckbox_css_cjs.checkboxSize,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                component: "span",
                position: "absolute",
                inset: 0,
                background: "formAccent",
                borderRadius: "standard",
                transition: "fast",
                opacity: checked ? void 0 : 0,
                children: /* @__PURE__ */ jsxRuntime.jsx(IconTick, { size: "fill" })
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          MenuItemChildren2,
          {
            tone: void 0,
            icon: void 0,
            badge,
            formElement: true,
            children
          }
        )
      ]
    }
  );
};
MenuItemCheckbox.__isMenuItem__ = true;
const MenuItemLink = ({
  href,
  target,
  rel,
  onClick,
  tone,
  data,
  children,
  badge,
  icon: icon2,
  id
}) => {
  const { menuItemProps, MenuItemChildren: MenuItemChildren2 } = useMenuItem({
    displayName: "MenuItemLink",
    onClick,
    tone,
    data,
    id
  });
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: Link,
      ...menuItemProps,
      href,
      target,
      rel,
      children: /* @__PURE__ */ jsxRuntime.jsx(MenuItemChildren2, { tone, icon: icon2, badge, children })
    }
  );
};
MenuItemLink.__isMenuItem__ = true;
const OverflowMenu = ({
  label,
  children,
  id,
  ...menuProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  MenuRenderer,
  {
    trigger: (triggerProps) => /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        display: "flex",
        justifyContent: "flexEnd",
        className: styles_lib_components_OverflowMenu_OverflowMenu_css_cjs.triggerOffset,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.ButtonIcon,
          {
            id,
            icon: /* @__PURE__ */ jsxRuntime.jsx(IconOverflow, {}),
            variant: "transparent",
            label,
            ...triggerProps
          }
        )
      }
    ),
    align: "right",
    offsetSpace: "small",
    ...menuProps,
    children
  }
);
const FieldGroup = ({
  id,
  disabled,
  children,
  secondaryLabel,
  tertiaryLabel,
  description,
  message,
  reserveMessageSpace = false,
  tone,
  required,
  role,
  space = "xsmall",
  data,
  ...restProps
}) => {
  const labelId = `${id}-label`;
  const messageId = `${id}-message`;
  const descriptionId = description ? `${id}-description` : void 0;
  let ariaLabelledBy;
  let ariaLabel;
  if ("label" in restProps && restProps.label) {
    ariaLabelledBy = labelId;
  } else if ("aria-labelledby" in restProps && restProps["aria-labelledby"]) {
    ariaLabelledBy = restProps["aria-labelledby"];
  } else if ("aria-label" in restProps && restProps["aria-label"]) {
    ariaLabel = restProps["aria-label"];
  }
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: "fieldset",
      disabled,
      id,
      role,
      "aria-labelledby": ariaLabelledBy,
      "aria-label": ariaLabel,
      "aria-required": required,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Stack, { space, children: [
        "label" in restProps && restProps.label || description ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "legend", id: labelId, children: /* @__PURE__ */ jsxRuntime.jsx(
          FieldLabel,
          {
            htmlFor: false,
            label: "label" in restProps ? restProps.label : void 0,
            secondaryLabel,
            tertiaryLabel,
            disabled,
            description,
            descriptionId
          }
        ) }) : null,
        children({
          disabled,
          "aria-describedby": mergeIds(
            message ? messageId : void 0,
            descriptionId
          )
        }),
        message || reserveMessageSpace ? /* @__PURE__ */ jsxRuntime.jsx(
          FieldMessage,
          {
            id: messageId,
            tone,
            disabled,
            message,
            reserveMessageSpace
          }
        ) : null
      ] })
    }
  );
};
const defaultMonthNames = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const getMonths = (monthNames) => monthNames.map((monthName, i) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: i + 1, children: monthName }, i));
const getYears = (min, max, ascending) => [...new Array(max - min + 1)].map((_v, i) => {
  const yearStr = String(ascending ? i + min : max - i);
  return /* @__PURE__ */ jsxRuntime.jsx("option", { value: yearStr, children: yearStr }, yearStr);
});
const currYear = (/* @__PURE__ */ new Date()).getFullYear();
const renderNativeInput = isMobile.isMobile({ tablet: true });
const customValueToString = ({ month, year }) => month && year ? `${year}-${month < 10 ? "0" : ""}${month}` : void 0;
const stringToCustomValue = (value) => {
  const [year, month] = value.split("-");
  return {
    month: parseInt(month, 10),
    year: parseInt(year, 10)
  };
};
const makeChangeHandler = (onChange, value, fieldType) => (event) => {
  if (typeof onChange === "function") {
    onChange(
      {
        month: {
          year: value && value.year ? value.year : void 0,
          month: parseInt(event.target.value, 10) || void 0
        },
        year: {
          month: value && value.month ? value.month : void 0,
          year: parseInt(event.target.value, 10) || void 0
        },
        native: stringToCustomValue(event.target.value)
      }[fieldType]
    );
  }
};
const MonthPicker = ({
  id,
  value,
  onChange,
  onBlur,
  onFocus,
  tone,
  disabled,
  minYear = currYear - 100,
  maxYear = currYear,
  ascendingYears = false,
  monthLabel = "Month",
  yearLabel = "Year",
  monthNames = defaultMonthNames,
  ...restProps
}) => {
  assert__default.default(monthNames.length === 12, "monthNames array must contain 12 items");
  const currentValue = {
    month: value && value.month ? value.month : void 0,
    year: value && value.year ? value.year : void 0
  };
  const monthRef = React.createRef();
  const yearRef = React.createRef();
  const monthId = `${id}-month`;
  const yearId = `${id}-year`;
  const blurHandler = onBlur ? (event) => {
    const fireIfExternal = (element) => {
      if (element !== monthRef.current && element !== yearRef.current) {
        onBlur();
      }
    };
    if (event.relatedTarget !== null) {
      fireIfExternal(event.relatedTarget);
    } else {
      setTimeout(() => {
        fireIfExternal(document.activeElement);
      });
    }
  } : void 0;
  const focusHandler = onFocus ? (event) => {
    if (event.relatedTarget !== monthRef.current && event.relatedTarget !== yearRef.current) {
      onFocus();
    }
  } : void 0;
  const nativeField = /* @__PURE__ */ jsxRuntime.jsx(
    Field,
    {
      id,
      tone,
      disabled,
      value: customValueToString(currentValue),
      ...restProps,
      icon: void 0,
      prefix: void 0,
      labelId: void 0,
      name: void 0,
      autoComplete: void 0,
      secondaryMessage: null,
      children: (overlays, { className, ...fieldProps }) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "input",
            type: "month",
            value: customValueToString(currentValue),
            onChange: onChange && makeChangeHandler(onChange, value, "native"),
            onBlur,
            onFocus,
            ...fieldProps,
            height: "touchable",
            className: [className, styles_lib_components_MonthPicker_MonthPicker_css_cjs.nativeInput]
          }
        ),
        overlays
      ] })
    }
  );
  const customFieldGroup = /* @__PURE__ */ jsxRuntime.jsx(FieldGroup, { id, tone, disabled, ...restProps, children: (fieldGroupProps) => /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Columns, { space: "small", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Dropdown,
      {
        id: monthId,
        value: currentValue.month || "",
        onChange: makeChangeHandler(onChange, value, "month"),
        onBlur: blurHandler,
        onFocus: focusHandler,
        tone,
        placeholder: monthLabel,
        "aria-label": monthLabel,
        ...fieldGroupProps,
        ref: monthRef,
        children: getMonths(monthNames)
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Dropdown,
      {
        id: yearId,
        value: currentValue.year || "",
        onChange: makeChangeHandler(onChange, value, "year"),
        onBlur: blurHandler,
        onFocus: focusHandler,
        tone,
        placeholder: yearLabel,
        "aria-label": yearLabel,
        ...fieldGroupProps,
        ref: yearRef,
        children: getYears(minYear, maxYear, ascendingYears)
      }
    ) })
  ] }) });
  return renderNativeInput ? nativeField : customFieldGroup;
};
MonthPicker.displayName = "MonthPicker";
const icons = {
  positive: ToastContext.IconPositive,
  info: IconInfo,
  promote: IconPromote,
  critical: ToastContext.IconCritical
};
const Notice = ({
  tone = "info",
  data,
  children,
  ...restProps
}) => {
  const Icon = icons[tone];
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      role: "alert",
      "aria-live": "polite",
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.DefaultTextPropsProvider, { tone, children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Columns, { space: "xsmall", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { width: "content", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(Icon, {}) }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Column, { children })
      ] }) })
    }
  );
};
const PageContext = React.createContext(false);
const Page$1 = ({
  children,
  footer,
  footerPosition,
  data,
  ...restProps
}) => {
  assert__default.default(
    !React.useContext(PageContext),
    "Page components should not be nested within each other"
  );
  return /* @__PURE__ */ jsxRuntime.jsx(PageContext.Provider, { value: true, children: /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      display: "flex",
      flexDirection: "column",
      className: styles_lib_components_Page_Page_css_cjs.fullHeight,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            flexGrow: footerPosition !== "belowFold" ? 1 : void 0,
            className: footerPosition === "belowFold" ? styles_lib_components_Page_Page_css_cjs.fullHeight : void 0,
            paddingBottom: "xxxlarge",
            children
          }
        ),
        footer
      ]
    }
  ) });
};
const paginate = ({
  page,
  total,
  maxPages
}) => {
  const half = (maxPages - 1) / 2;
  const smallerHalf = Math.floor(half);
  const largerHalf = Math.ceil(half);
  const pageCount = Math.min(maxPages, total);
  let minPage = page - smallerHalf;
  if (page - smallerHalf <= 1) {
    minPage = 1;
  } else if (page + largerHalf >= total) {
    minPage = Math.max(1, total - maxPages + 1);
  }
  return Array.from(Array(pageCount).keys()).map((p) => p + minPage);
};
const borderRadius = "standard";
const PageNav = ({
  label,
  direction
}) => {
  const isPrevious = direction === "prev";
  const isNext = direction === "next";
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      component: "span",
      className: styles_lib_components_Pagination_Pagination_css_cjs.hover,
      position: "relative",
      display: "flex",
      alignItems: "center",
      height: "touchable",
      paddingLeft: isNext ? "small" : "xsmall",
      paddingRight: isPrevious ? "small" : "xsmall",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            component: "span",
            background: "formAccentSoft",
            borderRadius,
            transition: "fast",
            className: styles_lib_components_Pagination_Pagination_css_cjs.background
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "span", zIndex: 1, userSelect: "none", children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Text, { children: [
          isPrevious ? /* @__PURE__ */ jsxRuntime.jsx(IconChevron, { direction: "left" }) : null,
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              display: isPrevious ? ["none", "inline"] : void 0,
              component: "span",
              marginLeft: isPrevious ? "xsmall" : void 0,
              marginRight: isNext ? "xsmall" : void 0,
              children: label
            }
          ),
          isNext ? /* @__PURE__ */ jsxRuntime.jsx(IconChevron, { direction: "right" }) : null
        ] }) })
      ]
    }
  );
};
const tabletButtonSpacing = "xxsmall";
const Page = ({ number, current }) => {
  const parentBackground = ToastContext.useBackground();
  const isLegacyTheme = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.useBraidTheme().legacy;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      component: "span",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      height: "touchable",
      width: "touchable",
      position: "relative",
      className: styles_lib_components_Pagination_Pagination_css_cjs.hover,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            component: "span",
            background: current ? "formAccent" : "formAccentSoft",
            transition: current ? void 0 : "fast",
            borderRadius,
            className: [styles_lib_components_Pagination_Pagination_css_cjs.background, current ? styles_lib_components_Pagination_Pagination_css_cjs.current : void 0]
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            component: "span",
            borderRadius,
            boxShadow: "borderFormAccent",
            className: {
              [styles_lib_components_Pagination_Pagination_css_cjs.lightModeCurrentKeyline]: isLegacyTheme && parentBackground.lightMode !== "surface" && current,
              [styles_lib_components_Pagination_Pagination_css_cjs.darkModeCurrentKeyline]: current
            }
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "span", zIndex: 1, userSelect: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Text,
          {
            baseline: false,
            align: "center",
            weight: current ? "medium" : void 0,
            tone: current ? "formAccent" : void 0,
            children: number
          }
        ) })
      ]
    }
  );
};
const defaultPageLimit = 7;
const Pagination = ({
  page,
  total,
  linkProps,
  label,
  pageLabel = (p) => `Go to page ${p}`,
  nextLabel = "Next",
  previousLabel = "Previous",
  pageLimit = defaultPageLimit,
  data,
  ...restProps
}) => {
  assert__default.default(total >= 1, `\`total\` must be at least 1`);
  assert__default.default(page >= 1 && page <= total, `\`page\` must be between 1 and ${total}`);
  assert__default.default(
    pageLimit >= 1 && pageLimit <= defaultPageLimit,
    `\`pageLimit\` must be between 1 and ${defaultPageLimit}`
  );
  const pages = paginate({ page, total, maxPages: pageLimit });
  const showPrevious = page > 1;
  const showNext = page < total;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component: "nav",
      "aria-label": label,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { component: "ul", display: "flex", justifyContent: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "li",
            paddingRight: {
              mobile: "medium",
              tablet: pageLimit > 2 ? tabletButtonSpacing : void 0
            },
            transition: "fast",
            opacity: !showPrevious ? 0 : void 0,
            pointerEvents: !showPrevious ? "none" : void 0,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              Link,
              {
                ...linkProps({ page: page - 1, type: "previous" }),
                rel: "prev",
                "aria-label": previousLabel,
                title: previousLabel,
                "aria-hidden": !showPrevious,
                tabIndex: !showPrevious ? -1 : void 0,
                children: /* @__PURE__ */ jsxRuntime.jsx(PageNav, { label: previousLabel, direction: "prev" })
              }
            )
          }
        ),
        pages.map((pageNumber, index) => {
          const current = page === pageNumber;
          const isNotLast = pages.length - 1 !== index;
          return /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              component: "li",
              display: !current ? { mobile: "none", tablet: "block" } : void 0,
              paddingRight: pageLimit > 2 && isNotLast ? {
                tablet: tabletButtonSpacing
              } : void 0,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                Link,
                {
                  ...linkProps({ page: pageNumber, type: "pageNumber" }),
                  "aria-label": pageLabel(pageNumber),
                  "aria-current": current ? "page" : void 0,
                  title: pageLabel(pageNumber),
                  children: /* @__PURE__ */ jsxRuntime.jsx(Page, { number: pageNumber, current })
                }
              )
            },
            pageNumber
          );
        }),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "li",
            paddingLeft: {
              mobile: "medium",
              tablet: pageLimit > 2 ? tabletButtonSpacing : void 0
            },
            transition: "fast",
            opacity: !showNext ? 0 : void 0,
            pointerEvents: !showNext ? "none" : void 0,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              Link,
              {
                ...linkProps({ page: page + 1, type: "next" }),
                rel: "next",
                "aria-label": nextLabel,
                title: nextLabel,
                "aria-hidden": !showNext,
                tabIndex: !showNext ? -1 : void 0,
                children: /* @__PURE__ */ jsxRuntime.jsx(PageNav, { label: nextLabel, direction: "next" })
              }
            )
          }
        )
      ] })
    }
  );
};
const PasswordField = React.forwardRef(
  ({
    value,
    onChange,
    onBlur,
    onFocus,
    placeholder,
    disabled,
    onVisibilityToggle,
    visibilityToggleLabel = "Toggle password visibility",
    id,
    ...restProps
  }, forwardedRef) => {
    const defaultRef = React.useRef(null);
    const inputRef = forwardedRef || defaultRef;
    const [visible, setVisibile] = React.useState(false);
    const visibilityHandler = React.useCallback(
      (event) => {
        if (event.button !== 0) {
          return;
        }
        const newState = !visible;
        setVisibile(newState);
        if (typeof onVisibilityToggle === "function") {
          onVisibilityToggle(newState);
        }
        if (inputRef && typeof inputRef === "object" && inputRef.current) {
          inputRef.current.focus();
        }
      },
      [visible, onVisibilityToggle, inputRef]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      Field,
      {
        ...restProps,
        id,
        value,
        icon: void 0,
        prefix: void 0,
        labelId: void 0,
        disabled,
        secondaryMessage: null,
        alwaysShowSecondaryIcon: !disabled,
        secondaryIcon: disabled ? null : /* @__PURE__ */ jsxRuntime.jsx(
          FieldButtonIcon,
          {
            id: `${id}-toggle`,
            label: visibilityToggleLabel,
            onMouseDown: visibilityHandler,
            icon: /* @__PURE__ */ jsxRuntime.jsx(IconVisibility, { hidden: visible })
          }
        ),
        children: (overlays, fieldProps, _, secondaryIcon) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              component: "input",
              type: visible ? "text" : "password",
              value,
              onChange,
              onFocus,
              onBlur,
              placeholder: !disabled ? placeholder : void 0,
              ...fieldProps,
              ref: inputRef
            }
          ),
          overlays,
          secondaryIcon
        ] })
      }
    );
  }
);
PasswordField.displayName = "PasswordField";
const RadioGroupContext = React.createContext(
  null
);
const RadioItemContext = React.createContext(null);
const Radio = React.forwardRef((props, ref) => {
  const radioGroupContext = React.useContext(RadioGroupContext);
  assert__default.default(
    radioGroupContext === null,
    'The "Radio" component has been deprecated. Use a "RadioItem" instead.'
  );
  if (process.env.NODE_ENV !== "production") {
    console.warn(
      dedent__default.default`
        The "Radio" component has been deprecated and will be removed in a future version. Use "RadioGroup" with "RadioItem" instead.
        %c
        - <Radio name="count" label="One" value="1" onChange={...} />
        - <Radio name="count" label="Two" value="2" onChange={...} checked />
        - <Radio name="count" label="Three" value="3" onChange={...}  />
        %c
        + <RadioGroup name="count" value="2" onChange={...}>
        +   <RadioItem label="One" value="1" />
        +   <RadioItem label="Two" value="2" />
        +   <RadioItem label="Three" value="3" />
        + </RadioGroup>
      `,
      "color: red",
      "color: green"
    );
  }
  return /* @__PURE__ */ jsxRuntime.jsx(
    InlineField,
    {
      ...props,
      inList: false,
      type: "radio",
      message: null,
      reserveMessageSpace: false,
      required: void 0,
      size: void 0,
      ref
    }
  );
});
Radio.displayName = "Radio";
const RadioItem = React.forwardRef(
  (props, ref) => {
    const radioGroupContext = React.useContext(RadioGroupContext);
    const radioItemContext = React.useContext(RadioItemContext);
    assert__default.default(
      radioGroupContext !== null && radioItemContext !== null,
      "All `RadioItem` buttons must be within a `RadioGroup`."
    );
    assert__default.default(
      typeof props.value !== "undefined" && props.value !== "",
      "All `RadioItem` buttons must have an associated `value`"
    );
    const checked = radioGroupContext.value === props.value;
    const isFirstRadioWithNoCheckedValueInGroup = radioItemContext === 0 && !Boolean(radioGroupContext.value);
    const tababble = checked || isFirstRadioWithNoCheckedValueInGroup;
    return /* @__PURE__ */ jsxRuntime.jsx(
      InlineField,
      {
        ...props,
        id: `${radioGroupContext.id}_${radioItemContext}`,
        name: radioGroupContext.name,
        checked,
        onChange: radioGroupContext.onChange,
        tone: radioGroupContext.tone === "critical" || radioGroupContext.tone === "neutral" ? radioGroupContext.tone : void 0,
        size: radioGroupContext.size,
        disabled: radioGroupContext.disabled || props.disabled,
        "aria-describedby": radioGroupContext["aria-describedby"],
        tabIndex: tababble ? 0 : -1,
        inList: true,
        type: "radio",
        message: null,
        reserveMessageSpace: false,
        required: void 0,
        ref
      }
    );
  }
);
RadioItem.displayName = "RadioItem";
const stackSpaceForSize = {
  small: "small",
  standard: "medium"
};
const RadioGroup = ({
  children,
  id,
  value,
  name,
  onChange,
  disabled,
  tone,
  size,
  ...props
}) => {
  const items = ToastContext.flattenChildren(children);
  const labelSpace = props.description ? "xxsmall" : "xsmall";
  assert__default.default(
    items.every(
      (item) => typeof item === "object" && "type" in item && item.type === RadioItem
    ),
    "All child nodes within a RadioGroup must be a RadioItem: https://seek-oss.github.io/braid-design-system/components/RadioGroup"
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    FieldGroup,
    {
      id,
      ...props,
      disabled,
      tone,
      space: "small",
      role: "radiogroup",
      children: (fieldGroupProps) => /* @__PURE__ */ jsxRuntime.jsx(
        RadioGroupContext.Provider,
        {
          value: {
            id,
            value,
            name: name || id,
            onChange,
            disabled,
            tone,
            size,
            ...fieldGroupProps
          },
          children: /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              paddingTop: "label" in props ? labelSpace : void 0,
              paddingBottom: props.message || props.reserveMessageSpace ? "xsmall" : void 0,
              children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Stack, { space: stackSpaceForSize[size || "standard"], children: items.map((item, i) => /* @__PURE__ */ jsxRuntime.jsx(RadioItemContext.Provider, { value: i, children: item }, i)) })
            }
          )
        }
      )
    }
  );
};
RadioGroup.displayName = "RadioGroup";
const IconStarHalfSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    focusable: "false",
    fill: "currentColor",
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsxRuntime.jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M22.951 8.954a1 1 0 0 0-.806-.68l-6.391-.935-2.858-5.782a1.042 1.042 0 0 0-1.793 0L8.246 7.339l-6.39.934a1 1 0 0 0-.553 1.706l4.623 4.498-1.091 6.354a1 1 0 0 0 1.45 1.054L12 18.883l5.715 3.002a1 1 0 0 0 1.45-1.054l-1.09-6.354 4.622-4.497a1.002 1.002 0 0 0 .254-1.026Zm-6.648 4.456a1 1 0 0 0-.288.886l.837 4.877-4.387-2.305a.99.99 0 0 0-.465-.115V4.257l2.193 4.44a1 1 0 0 0 .752.545l4.905.717Z" })
    ]
  }
);
const getPercent = (rating, position) => Math.round(Math.min(Math.max(rating - position, 0), 1) * 100);
const RatingStar = ({ percent, ...restProps }) => {
  const currentBg = ToastContext.useBackground();
  const { className, ...iconProps } = ToastContext.useIcon(restProps);
  let component = IconStarSvg;
  if (percent >= 25 && percent < 75) {
    component = IconStarHalfSvg;
  }
  if (percent >= 75) {
    component = IconStarActiveSvg;
  }
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      component,
      ...iconProps,
      className: [
        className,
        {
          [styles_lib_components_Rating_Rating_css_cjs.lightModeStarColor]: currentBg.lightMode === "body" || currentBg.lightMode === "surface"
        },
        {
          [styles_lib_components_Rating_Rating_css_cjs.darkModeStarColor]: currentBg.darkMode === "body" || currentBg.darkMode === "surface"
        }
      ]
    }
  );
};
const ratingArr = [...Array(5)];
const Rating = ({
  rating,
  size = "standard",
  showTextRating,
  variant: variantProp,
  "aria-label": ariaLabel,
  data
}) => {
  assert__default.default(
    !rating || rating >= 0 && rating <= 5,
    "Rating must be between 0 and 5"
  );
  if (process.env.NODE_ENV !== "production") {
    if (typeof showTextRating !== "undefined") {
      console.warn(
        dedent__default.default`
          The "showTextRating" prop has been deprecated and will be removed in a future version. Use \`variant="starsOnly"\` instead.
             <Rating
            %c-   showTextRating={false}
            %c+   variant="starsOnly"
             %c/>
        `,
        "color: red",
        "color: green",
        "color: inherit"
      );
    }
  }
  const variant = variantProp || "full";
  const resolvedVariant = showTextRating === false && !variantProp ? "starsOnly" : variant;
  return /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Text, { size, data, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        display: "inlineBlock",
        "aria-label": ariaLabel || `${rating.toFixed(1)} out of ${ratingArr.length}`,
        children: resolvedVariant === "minimal" ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { display: "inlineBlock", "aria-hidden": true, children: /* @__PURE__ */ jsxRuntime.jsx(RatingStar, { percent: 100 }) }) : ratingArr.map((_, position) => /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            display: "inlineBlock",
            "aria-hidden": true,
            className: {
              [styles_lib_components_Rating_Rating_css_cjs.starSpacing]: position !== ratingArr.length - 1
            },
            children: /* @__PURE__ */ jsxRuntime.jsx(RatingStar, { percent: getPercent(rating, position) })
          },
          position
        ))
      }
    ),
    resolvedVariant !== "starsOnly" && /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "span", className: styles_lib_components_Rating_Rating_css_cjs.textSpacing, "aria-hidden": true, children: rating.toFixed(1) })
  ] });
};
const StepContext = React.createContext({
  stepNumber: 0,
  isLast: false
});
const NAV_RIGHT = 0;
const NAV_DOWN = 1;
const NAV_LEFT = 2;
const NAV_UP = 3;
const NAV_HOME = 4;
const NAV_END = 5;
const NAV_TAB = 6;
const NAV_CLICKED = 7;
const NAV_FOCUSED = 8;
const NAV_BLURRED = 9;
const StepperContext = React.createContext(null);
const getNextStep = (moveAmount, current, maxStep) => {
  if (current === null) {
    return moveAmount > 0 ? 1 : maxStep;
  }
  const nextStep = moveAmount + current;
  if (nextStep > maxStep) {
    return 1;
  }
  if (nextStep < 1) {
    return maxStep;
  }
  return nextStep;
};
const StepperContextProvider = ({
  children,
  activeStep,
  stepCount: stepCountProp,
  progress,
  isLinear,
  align,
  tone = "formAccent",
  onStepClick
}) => {
  const stepCount = isLinear ? progress : stepCountProp;
  const [stepperState, dispatch] = React.useReducer(
    (state, action) => {
      switch (action.type) {
        case NAV_UP:
        case NAV_LEFT: {
          return {
            ...state,
            focusedStep: getNextStep(-1, state.focusedStep, stepCount)
          };
        }
        case NAV_DOWN:
        case NAV_RIGHT: {
          return {
            ...state,
            focusedStep: getNextStep(1, state.focusedStep, stepCount)
          };
        }
        case NAV_HOME: {
          return {
            ...state,
            focusedStep: 1
          };
        }
        case NAV_END: {
          return {
            ...state,
            focusedStep: stepCount
          };
        }
        case NAV_BLURRED:
        case NAV_TAB: {
          return {
            ...state,
            focusedStep: null
          };
        }
        case NAV_CLICKED: {
          return {
            ...state,
            focusedStep: action.value
          };
        }
        case NAV_FOCUSED: {
          return {
            ...state,
            focusedStep: state.focusedStep === null ? activeStep : state.focusedStep
          };
        }
        default:
          return state;
      }
    },
    {
      focusedStep: null,
      activeStep,
      isLinear,
      tone,
      align,
      progress,
      onStepClick
    }
  );
  const onKeyUp = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === "Tab") {
      return;
    }
    const action = {
      ArrowRight: { type: NAV_RIGHT },
      ArrowLeft: { type: NAV_LEFT },
      ArrowUp: { type: NAV_UP },
      ArrowDown: { type: NAV_DOWN },
      Home: { type: NAV_HOME },
      End: { type: NAV_END }
    };
    if (action[targetKey]) {
      dispatch(action[targetKey]);
    }
  };
  const onKeyDown = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === "Tab") {
      dispatch({ type: NAV_TAB });
      return;
    }
    const isNavigationKeyPress = targetKey.indexOf("Arrow") === 0 || ["Home", "End"].includes(targetKey);
    if (isNavigationKeyPress) {
      event.preventDefault();
    }
  };
  const onFocus = () => dispatch({
    type: NAV_FOCUSED
  });
  const onBlur = () => dispatch({
    type: NAV_BLURRED
  });
  const onClick = (index) => dispatch({
    type: NAV_CLICKED,
    value: index
  });
  return /* @__PURE__ */ jsxRuntime.jsx(
    StepperContext.Provider,
    {
      value: {
        ...stepperState,
        activeStep,
        isLinear,
        align,
        tone,
        progress,
        onStepClick,
        ...typeof onStepClick === "function" ? {
          onKeyUp,
          onKeyDown,
          onClick,
          onFocus,
          onBlur
        } : {}
      },
      children
    }
  );
};
const StepIndicator = ({ complete, started, active }) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    focusable: "false",
    viewBox: "0 0 24 24",
    className: clsx__default.default(
      styles_lib_components_Stepper_Stepper_css_cjs.indicator,
      complete || active || started ? styles_lib_components_Stepper_Stepper_css_cjs.highlight : void 0,
      complete && !active ? styles_lib_components_Stepper_Stepper_css_cjs.complete : void 0,
      active ? styles_lib_components_Stepper_Stepper_css_cjs.active : void 0
    ),
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        "circle",
        {
          fill: "none",
          stroke: "currentColor",
          strokeWidth: 4,
          cx: 12,
          cy: 12,
          r: 10
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: 12, cy: 12, r: 5, className: styles_lib_components_Stepper_Stepper_css_cjs.inner }),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M 18.26 7.64 C 17.94 7.32 17.46 7.32 17.14 7.64 L 9.7 15.08 L 7.06 12.44 C 6.74 12.12 6.26 12.12 5.94 12.44 S 5.62 13.24 5.94 13.56 L 9.14 16.76 C 9.3 16.92 9.46 17 9.7 17 S 10.1 16.92 10.26 16.76 L 18.26 8.76 C 18.58 8.44 18.58 7.96 18.26 7.64 Z",
          className: styles_lib_components_Stepper_Stepper_css_cjs.tick
        }
      )
    ]
  }
);
const Step = ({ complete = false, id, children }) => {
  const stepRef = React.useRef(null);
  const { stepNumber, isLast } = React.useContext(StepContext);
  const stepperContext = React.useContext(StepperContext);
  assert__default.default(
    stepperContext !== null,
    "A Step must be rendered as a child of a Stepper. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/Stepper"
  );
  const {
    focusedStep,
    activeStep,
    tone,
    align,
    progress,
    isLinear,
    onKeyUp,
    onKeyDown,
    onClick,
    onFocus,
    onBlur,
    onStepClick
  } = stepperContext;
  const active = activeStep === stepNumber;
  const focused = focusedStep === stepNumber;
  const linearStepBeforeProgress = isLinear && stepNumber < progress;
  const completed = complete || linearStepBeforeProgress;
  const started = active || complete || isLinear && stepNumber <= progress;
  const keyboardAccessible = focused || active && focusedStep === null;
  const interactable = typeof onStepClick === "function" && !active && (!isLinear || stepNumber <= progress);
  React.useEffect(() => {
    if (stepRef.current && focused) {
      stepRef.current.focus();
    }
  }, [focused]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      component: "button",
      ref: stepRef,
      position: "relative",
      outline: "none",
      display: "flex",
      justifyContent: { tablet: align === "center" ? "center" : void 0 },
      width: "full",
      cursor: interactable ? "pointer" : void 0,
      pointerEvents: !interactable && !active ? "none" : void 0,
      "aria-current": active ? "step" : void 0,
      className: [styles_lib_components_Stepper_Stepper_css_cjs.step, styles_lib_components_Stepper_Stepper_css_cjs.tone[tone]],
      onClick: interactable ? () => {
        if (onClick) {
          onClick(stepNumber);
        }
        if (onStepClick) {
          onStepClick({ id, stepNumber });
        }
      } : void 0,
      onKeyUp,
      onKeyDown,
      onFocus,
      onBlur: keyboardAccessible ? onBlur : void 0,
      tabIndex: keyboardAccessible ? 0 : -1,
      children: [
        !isLast ? /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "span",
            position: "absolute",
            overflow: "hidden",
            borderRadius: "full",
            className: [
              styles_lib_components_Stepper_Stepper_css_cjs.progressTrack,
              align === "center" ? styles_lib_components_Stepper_Stepper_css_cjs.progressTrackCentered : void 0
            ],
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                component: "span",
                position: "absolute",
                top: 0,
                bottom: 0,
                left: 0,
                width: "full",
                className: [
                  styles_lib_components_Stepper_Stepper_css_cjs.progressLine,
                  !linearStepBeforeProgress ? styles_lib_components_Stepper_Stepper_css_cjs.progressUnfilled : void 0
                ]
              }
            )
          }
        ) : null,
        /* @__PURE__ */ jsxRuntime.jsxs(
          ToastContext.Stack,
          {
            component: "span",
            space: "medium",
            align: {
              mobile: "left",
              tablet: align === "center" ? "center" : void 0
            },
            children: [
              /* @__PURE__ */ jsxRuntime.jsxs(
                ToastContext.Box,
                {
                  component: "span",
                  display: "block",
                  position: "relative",
                  transition: "fast",
                  className: styles_lib_components_Stepper_Stepper_css_cjs.indicatorContainer,
                  "aria-hidden": true,
                  children: [
                    /* @__PURE__ */ jsxRuntime.jsx(
                      ToastContext.FieldOverlay,
                      {
                        variant: "focus",
                        borderRadius: "full",
                        onlyVisibleForKeyboardNavigation: true,
                        className: styles_lib_components_Stepper_Stepper_css_cjs.focusOverlay
                      }
                    ),
                    /* @__PURE__ */ jsxRuntime.jsx(
                      StepIndicator,
                      {
                        complete: completed,
                        active,
                        started
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Hidden, { component: "span", below: "tablet", children: /* @__PURE__ */ jsxRuntime.jsx(
                ToastContext.Box,
                {
                  component: "span",
                  display: "block",
                  paddingX: align === "center" ? "xsmall" : void 0,
                  paddingRight: align === "left" && !isLast ? "xsmall" : void 0,
                  userSelect: "none",
                  children: /* @__PURE__ */ jsxRuntime.jsx(
                    ToastContext.Text,
                    {
                      align: align === "center" ? "center" : void 0,
                      weight: started ? "strong" : void 0,
                      tone: !started ? "secondary" : void 0,
                      children
                    }
                  )
                }
              ) })
            ]
          }
        )
      ]
    }
  );
};
Step.__isStep__ = true;
const resolveActiveStep = (mode, progress, activeStep) => {
  if (mode === "linear" && (typeof activeStep === "undefined" || activeStep > progress)) {
    return progress;
  }
  return activeStep || 0;
};
const Stepper = ({
  activeStep,
  label,
  mode = "linear",
  tone,
  children,
  data,
  align = "center",
  id,
  onStepClick,
  ...restProps
}) => {
  const steps = ToastContext.flattenChildren(children);
  const stepCount = steps.length;
  const isLinear = mode === "linear";
  const progress = "progress" in restProps ? restProps.progress : 0;
  const activeStepNumber = resolveActiveStep(mode, progress, activeStep);
  let stepName = "";
  const stepItems = React.Children.map(steps, (child, index) => {
    const stepNumber = index + 1;
    const isLast = stepNumber === stepCount;
    assert__default.default(
      !child || child.type.__isStep__,
      "Only Step elements can be direct children of a Stepper. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/Stepper"
    );
    if (stepNumber === activeStepNumber && typeof child === "object") {
      stepName = child.props.children;
    }
    return /* @__PURE__ */ jsxRuntime.jsx(
      StepContext.Provider,
      {
        value: {
          stepNumber,
          isLast
        },
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "li",
            className: [
              !isLast ? styles_lib_components_Stepper_Stepper_css_cjs.stretch : void 0,
              isLast && align === "center" ? styles_lib_components_Stepper_Stepper_css_cjs.stretchLastAboveTablet : void 0
            ],
            children: child
          }
        )
      }
    );
  });
  return /* @__PURE__ */ jsxRuntime.jsx(
    StepperContextProvider,
    {
      activeStep: activeStepNumber,
      tone,
      align,
      progress,
      stepCount: stepItems.length,
      isLinear,
      onStepClick,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        ToastContext.Box,
        {
          component: "nav",
          position: "relative",
          "aria-label": label,
          id,
          ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                component: "ol",
                display: "flex",
                paddingBottom: { mobile: "medium", tablet: "none" },
                justifyContent: {
                  mobile: "spaceBetween",
                  tablet: align === "center" ? "center" : void 0
                },
                children: stepItems
              }
            ),
            isLinear ? /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                component: "span",
                position: "absolute",
                pointerEvents: "none",
                className: styles_lib_components_Stepper_Stepper_css_cjs.progressTrack,
                role: "progressbar",
                "aria-valuemin": 0,
                "aria-valuemax": stepCount - 1,
                "aria-valuenow": progress > 0 ? progress - 1 : void 0,
                "aria-valuetext": progress > 0 ? label : void 0,
                style: {
                  left: `${(100 - (stepCount - 1) / stepCount * 100) / 2}%`,
                  width: `${(progress - 1) / stepCount * 100}%`
                }
              }
            ) : null,
            /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Hidden, { above: "mobile", children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { weight: "strong", children: stepName }) })
          ]
        }
      )
    }
  );
};
const TAB_BUTTON_RIGHT = 0;
const TAB_BUTTON_LEFT = 1;
const TAB_BUTTON_HOME = 2;
const TAB_BUTTON_END = 3;
const TAB_BUTTON_TAB = 4;
const TAB_BUTTON_ENTER = 5;
const TAB_BUTTON_SPACE = 6;
const TAB_BUTTON_CLICK = 7;
const TAB_LIST_UPDATED = 8;
const TAB_LIST_FOCUSED = 9;
const TAB_PANELS_UPDATED = 10;
const TAB_BUTTON_REGISTER = 11;
const getTabLabelId = (uniqueId, index) => `${uniqueId}_${index + 1}_label`;
const getPanelId = (uniqueId, index) => `${uniqueId}_${index + 1}_panel`;
const tabA11y = ({ uniqueId }) => ({
  tabListProps: ({ label }) => ({
    role: "tablist",
    "aria-orientation": "horizontal",
    "aria-label": label
  }),
  tabProps: ({ tabIndex, isSelected }) => ({
    role: "tab",
    tabIndex: isSelected ? void 0 : -1,
    "aria-selected": isSelected,
    "aria-controls": getPanelId(uniqueId, tabIndex),
    id: `${uniqueId}_${tabIndex + 1}`
  }),
  tabLabelProps: ({ tabIndex }) => ({
    id: getTabLabelId(uniqueId, tabIndex)
  }),
  tabPanelProps: ({ panelIndex, isSelected }) => ({
    role: "tabpanel",
    "aria-labelledby": getTabLabelId(uniqueId, panelIndex),
    "aria-hidden": isSelected ? void 0 : true,
    id: getPanelId(uniqueId, panelIndex),
    tabIndex: isSelected ? 0 : void 0
  })
});
const TabsContext = React.createContext(null);
const TabsProvider = ({
  children,
  onChange,
  id,
  selectedItem
}) => {
  const [tabsState, dispatch] = React.useReducer(
    (state, action) => {
      switch (action.type) {
        case TAB_BUTTON_LEFT: {
          return {
            ...state,
            focusedTabIndex: getNextIndex(
              -1,
              state.focusedTabIndex,
              state.tabItems.length
            )
          };
        }
        case TAB_BUTTON_RIGHT: {
          return {
            ...state,
            focusedTabIndex: getNextIndex(
              1,
              state.focusedTabIndex,
              state.tabItems.length
            )
          };
        }
        case TAB_BUTTON_HOME: {
          return {
            ...state,
            focusedTabIndex: 0
          };
        }
        case TAB_BUTTON_END: {
          return {
            ...state,
            focusedTabIndex: state.tabItems.length - 1
          };
        }
        case TAB_BUTTON_TAB: {
          return {
            ...state,
            focusedTabIndex: null
          };
        }
        case TAB_BUTTON_ENTER:
        case TAB_BUTTON_SPACE:
        case TAB_BUTTON_CLICK: {
          return {
            ...state,
            focusedTabIndex: action.value,
            selectedIndex: action.value
          };
        }
        case TAB_BUTTON_REGISTER: {
          return {
            ...state,
            tabButtonElements: {
              ...state.tabButtonElements,
              [action.tabListItemIndex.toString()]: action.tabEl
            }
          };
        }
        case TAB_LIST_FOCUSED: {
          return {
            ...state,
            focusedTabIndex: action.value || 0
          };
        }
        case TAB_LIST_UPDATED: {
          return {
            ...state,
            tabItems: action.tabItems,
            selectedIndex: 0
          };
        }
        case TAB_PANELS_UPDATED: {
          return {
            ...state,
            panels: action.panels
          };
        }
        default:
          return state;
      }
    },
    {
      selectedIndex: 0,
      focusedTabIndex: null,
      tabItems: [],
      panels: [],
      tabButtonElements: {}
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TabsContext.Provider,
    {
      value: {
        ...tabsState,
        selectedIndex: typeof selectedItem !== "undefined" ? tabsState.tabItems.indexOf(selectedItem) : tabsState.selectedIndex,
        selectedItem,
        dispatch,
        a11y: tabA11y({ uniqueId: id }),
        onChange
      },
      children
    }
  );
};
const TabListContext = React.createContext(null);
const paddingX = "small";
const Tab = ({
  children,
  data,
  badge,
  icon: icon2,
  item,
  ...restProps
}) => {
  const tabsContext = React.useContext(TabsContext);
  const tabListContext = React.useContext(TabListContext);
  const tabRef = React.useRef(null);
  assert__default.default(
    tabListContext !== null,
    "A Tab must be rendered as a child of Tabs. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/Tab"
  );
  assert__default.default(
    // @ts-expect-error
    !badge || badge.type.__isBadge__,
    `Tab badge prop can only be an instance of Badge. e.g. <Tab badge={<Badge>New</Badge>}>`
  );
  assert__default.default(
    !badge || badge.props.bleedY === void 0,
    "Badge elements cannot set the 'bleedY' prop when passed to a Tab component"
  );
  assert__default.default(
    !icon2 || icon2.props.size === void 0 && icon2.props.tone === void 0,
    "Icons cannot set the 'size' or 'tone' prop when passed to a Tab component"
  );
  if (!tabListContext) {
    throw new Error("Tab rendered outside Tabs context");
  }
  if (!tabsContext) {
    throw new Error("Tab rendered outside TabsProvider");
  }
  const {
    focusedTabIndex,
    selectedIndex,
    selectedItem,
    dispatch,
    a11y,
    onChange
  } = tabsContext;
  const { tabListItemIndex, scrollContainer, isLast } = tabListContext;
  const isSelected = selectedIndex > -1 ? selectedIndex === tabListItemIndex : selectedItem === item;
  const isFocused = focusedTabIndex === tabListItemIndex;
  const { grid, space } = ToastContext.useSpace();
  React.useEffect(() => {
    if (tabRef.current && isFocused) {
      tabRef.current.focus();
    }
  }, [isFocused]);
  const firstRenderRef = React.useRef(true);
  const isMobile2 = ToastContext.useResponsiveValue()({
    mobile: true,
    tablet: false
  });
  React.useEffect(() => {
    if (!tabRef.current || !scrollContainer) {
      return;
    }
    if (isSelected || isFocused) {
      if (isMobile2) {
        smoothScroll(tabRef.current, {
          scrollContainer,
          direction: "horizontal",
          offset: space[paddingX] * grid * 3,
          ...firstRenderRef.current ? { duration: 0 } : { speed: 0.7 }
        });
      } else {
        smoothScrollIntoView(tabRef.current, {
          scrollContainer,
          direction: "horizontal",
          offset: space[paddingX] * grid * 6,
          ...firstRenderRef.current ? { duration: 0 } : { speed: 0.7 }
        });
      }
    }
    firstRenderRef.current = false;
  }, [isSelected, isFocused, scrollContainer, space, grid, isMobile2]);
  React.useEffect(() => {
    if (tabRef.current) {
      dispatch({
        type: TAB_BUTTON_REGISTER,
        tabEl: tabRef.current,
        tabListItemIndex
      });
    }
  }, [dispatch, tabListItemIndex]);
  const onKeyUp = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === "Tab") {
      return;
    }
    if (onChange && (targetKey === "Enter" || targetKey === " ")) {
      onChange(tabListItemIndex, item);
    }
    const action = {
      ArrowRight: { type: TAB_BUTTON_RIGHT },
      ArrowLeft: { type: TAB_BUTTON_LEFT },
      Home: { type: TAB_BUTTON_HOME },
      End: { type: TAB_BUTTON_END },
      Enter: { type: TAB_BUTTON_ENTER, value: tabListItemIndex },
      " ": { type: TAB_BUTTON_SPACE, value: tabListItemIndex }
    };
    if (action[targetKey]) {
      dispatch(action[targetKey]);
    }
  };
  const onKeyDown = (event) => {
    const targetKey = normalizeKey(event);
    if (targetKey === "Tab" && focusedTabIndex !== null) {
      dispatch({ type: TAB_BUTTON_TAB });
      return;
    }
    const isArrowPress = targetKey.indexOf("Arrow") === 0;
    const isActionKeyPress = targetKey === "Enter" || targetKey === " ";
    if (isArrowPress || isActionKeyPress) {
      event.preventDefault();
    }
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      component: "button",
      type: "button",
      ...a11y.tabProps({ tabIndex: tabListItemIndex, isSelected }),
      ref: tabRef,
      onKeyUp,
      onKeyDown,
      onClick: (event) => {
        event.stopPropagation();
        event.preventDefault();
        if (onChange) {
          onChange(tabListItemIndex, item);
        }
        dispatch({ type: TAB_BUTTON_CLICK, value: tabListItemIndex });
      },
      onFocus: isSelected ? () => dispatch({
        type: TAB_LIST_FOCUSED,
        value: tabListItemIndex
      }) : void 0,
      display: "flex",
      alignItems: "center",
      textAlign: "left",
      borderRadius: "standard",
      cursor: "pointer",
      outline: "none",
      position: "relative",
      zIndex: 1,
      paddingLeft: tabListItemIndex > 0 ? paddingX : void 0,
      paddingRight: !isLast ? paddingX : void 0,
      paddingY: "medium",
      className: styles_lib_components_Tabs_Tabs_css_cjs.tab,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "span",
            display: "block",
            position: "absolute",
            "aria-hidden": true,
            transition: "fast",
            opacity: isSelected ? 0 : void 0,
            className: icon2 ? styles_lib_components_Tabs_Tabs_css_cjs.cropToIconX : void 0,
            children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { tone: "secondary", icon: icon2, children })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "span",
            display: "block",
            position: "absolute",
            "aria-hidden": true,
            transition: "fast",
            opacity: 0,
            className: [
              !isSelected ? styles_lib_components_Tabs_Tabs_css_cjs.hoveredTab : void 0,
              icon2 ? styles_lib_components_Tabs_Tabs_css_cjs.cropToIconX : void 0
            ],
            children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { icon: icon2, children })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "span",
            display: "block",
            transition: "fast",
            opacity: !isSelected ? 0 : void 0,
            className: icon2 ? styles_lib_components_Tabs_Tabs_css_cjs.cropToIconX : void 0,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Text,
              {
                ...a11y.tabLabelProps({ tabIndex: tabListItemIndex }),
                tone: "formAccent",
                icon: icon2,
                children
              }
            )
          }
        ),
        badge ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "span", paddingLeft: "xsmall", children: React.cloneElement(badge, { bleedY: true }) }) : null,
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            component: "span",
            zIndex: 1,
            boxShadow: "outlineFocus",
            borderRadius: "standard",
            className: styles_lib_components_Tabs_Tabs_css_cjs.tabFocusRing,
            visible: false,
            transition: "fast",
            onlyVisibleForKeyboardNavigation: true
          }
        )
      ]
    }
  );
};
Tab.__isTab__ = true;
const getActiveTabLinePosition = (button) => {
  if (!button) {
    return { left: 0, width: 0 };
  }
  const computedStyle = getComputedStyle(button);
  const elWidth = button.getBoundingClientRect().width;
  const paddingLeft = parseFloat(computedStyle.paddingLeft);
  const paddingRight = parseFloat(computedStyle.paddingRight);
  const width = elWidth - paddingLeft - paddingRight;
  return { left: button.offsetLeft + paddingLeft, width };
};
const Tabs = (props) => {
  const tabsContext = React.useContext(TabsContext);
  const tabsRef = React.useRef(null);
  const {
    children,
    label,
    data,
    align = "left",
    gutter,
    reserveHitArea = false,
    divider = "minimal",
    ...restProps
  } = props;
  assert__default.default(
    tabsContext !== null,
    "Tabs must be rendered as a child of TabsProvider. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/Tabs"
  );
  if (!tabsContext) {
    throw new Error("Tabs rendered outside TabsProvider");
  }
  const { dispatch, a11y, selectedIndex, selectedItem } = tabsContext;
  const tabItems = [];
  const childTabs = ToastContext.flattenChildren(children);
  const tabs = childTabs.map((tab, index) => {
    assert__default.default(
      // @ts-expect-error
      typeof tab === "object" && tab.type.__isTab__,
      "Only Tab elements can be direct children of a Tabs"
    );
    tabItems.push(tab.props.item ?? index);
    return /* @__PURE__ */ jsxRuntime.jsx(
      TabListContext.Provider,
      {
        value: {
          tabListItemIndex: index,
          scrollContainer: tabsRef.current,
          isLast: childTabs.length === index + 1
        },
        children: tab
      },
      index
    );
  });
  React.useEffect(() => {
    dispatch({ type: TAB_LIST_UPDATED, tabItems });
  }, [tabItems.join(), dispatch]);
  const {
    space: { grid, space }
  } = sideEffects_lib_components_BraidProvider_BraidProvider_cjs.useBraidTheme();
  const [showMask, setShowMask] = React.useState(true);
  const updateMask = React.useCallback(() => {
    if (!tabsRef.current) {
      return;
    }
    setShowMask(
      tabsRef.current.scrollWidth - tabsRef.current.offsetWidth - tabsRef.current.scrollLeft > grid * space.small
    );
  }, [tabsRef, setShowMask, grid, space]);
  React.useEffect(() => {
    updateMask();
    window.addEventListener("resize", updateMask);
    return () => window.removeEventListener("resize", updateMask);
  }, [updateMask]);
  const selectedTabIndex = typeof selectedItem !== "undefined" ? tabItems.indexOf(selectedItem) : selectedIndex;
  const selectedTabButtonEl = tabsContext.tabButtonElements[selectedTabIndex.toString()];
  const activeTab = getActiveTabLinePosition(selectedTabButtonEl);
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      className: reserveHitArea ? void 0 : ToastContext.negativeMargin("top", "medium"),
      children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { position: "relative", children: /* @__PURE__ */ jsxRuntime.jsxs(
        ToastContext.Box,
        {
          ref: tabsRef,
          className: [
            styles_lib_components_Tabs_Tabs_css_cjs.scroll,
            styles_lib_components_Tabs_Tabs_css_cjs.nowrap,
            showMask ? styles_lib_components_Tabs_Tabs_css_cjs.mask : null
          ],
          display: "flex",
          onScroll: updateMask,
          flexWrap: "nowrap",
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                display: "flex",
                className: align === "center" ? styles_lib_components_Tabs_Tabs_css_cjs.marginAuto : void 0,
                paddingX: gutter,
                flexWrap: "nowrap",
                position: "relative",
                zIndex: 1,
                children: /* @__PURE__ */ jsxRuntime.jsxs(
                  ToastContext.Box,
                  {
                    ...a11y.tabListProps({ label }),
                    display: "flex",
                    ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
                    flexWrap: "nowrap",
                    position: "relative",
                    children: [
                      tabs,
                      divider === "minimal" ? /* @__PURE__ */ jsxRuntime.jsx(
                        ToastContext.Box,
                        {
                          position: "absolute",
                          bottom: 0,
                          left: 0,
                          right: 0,
                          className: styles_lib_components_Tabs_Tabs_css_cjs.divider,
                          children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Divider, {})
                        }
                      ) : null,
                      selectedTabButtonEl ? /* @__PURE__ */ jsxRuntime.jsx(
                        ToastContext.Box,
                        {
                          component: "span",
                          position: "absolute",
                          display: "block",
                          left: 0,
                          right: 0,
                          bottom: 0,
                          background: "formAccent",
                          pointerEvents: "none",
                          className: [
                            styles_lib_components_Tabs_Tabs_css_cjs.tabUnderline,
                            styles_lib_components_Tabs_Tabs_css_cjs.tabUnderlineActiveDarkMode
                          ],
                          style: dynamic.assignInlineVars({
                            [styles_lib_components_Tabs_Tabs_css_cjs.underlineLeft]: activeTab.left.toString(),
                            [styles_lib_components_Tabs_Tabs_css_cjs.underlineWidth]: activeTab.width.toString()
                          })
                        }
                      ) : null
                    ]
                  }
                )
              }
            ),
            divider === "full" ? /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.Box,
              {
                position: "absolute",
                bottom: 0,
                left: 0,
                right: 0,
                className: styles_lib_components_Tabs_Tabs_css_cjs.divider,
                children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Divider, {})
              }
            ) : null
          ]
        }
      ) })
    }
  ) });
};
const TabPanelsContext = React.createContext(
  null
);
const TabPanels = ({
  renderInactivePanels = false,
  children
}) => {
  const tabsContext = React.useContext(TabsContext);
  if (!tabsContext) {
    throw new Error("TabPanels rendered outside TabsProvider context");
  }
  const { dispatch } = tabsContext;
  const panelItems = [];
  const panels = ToastContext.flattenChildren(children).map((panel, index) => {
    assert__default.default(
      // @ts-expect-error
      typeof panel === "object" && panel.type.__isTabPanel__,
      "Only TabPanel elements can be direct children of a TabPanels"
    );
    panelItems.push(index);
    return /* @__PURE__ */ jsxRuntime.jsx(
      TabPanelsContext.Provider,
      {
        value: {
          renderInactive: renderInactivePanels,
          panelIndex: index
        },
        children: panel
      },
      index
    );
  });
  React.useEffect(() => {
    dispatch({ type: TAB_PANELS_UPDATED, panels: panelItems });
  }, [panelItems.join(), dispatch]);
  return /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: panels });
};
const TabPanel = ({
  children,
  data,
  item,
  ...restProps
}) => {
  const tabsContext = React.useContext(TabsContext);
  const tabPanelsContext = React.useContext(TabPanelsContext);
  assert__default.default(
    tabsContext !== null,
    "A TabPanel must be rendered as a child of TabsProvider. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/Tabs"
  );
  if (!tabPanelsContext) {
    throw new Error("TabPanel rendered outside TabPanels");
  }
  if (!tabsContext) {
    throw new Error("TabPanel rendered outside TabsProvider");
  }
  const { a11y, selectedIndex, selectedItem } = tabsContext;
  const { panelIndex, renderInactive } = tabPanelsContext;
  const isSelected = selectedIndex > -1 ? panelIndex === selectedIndex : selectedItem === item;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      ...a11y.tabPanelProps({ panelIndex, isSelected }),
      display: isSelected ? void 0 : "none",
      position: "relative",
      outline: "none",
      className: styles_lib_components_Tabs_Tabs_css_cjs.tabPanel,
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        isSelected || renderInactive ? children : void 0,
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            zIndex: 1,
            boxShadow: "outlineFocus",
            borderRadius: "large",
            className: styles_lib_components_Tabs_Tabs_css_cjs.tabPanelFocusRing,
            onlyVisibleForKeyboardNavigation: true
          }
        )
      ]
    }
  );
};
TabPanel.displayName = "TabPanel";
TabPanel.__isTabPanel__ = true;
const Tag = ({
  onClear,
  clearLabel = "Clear",
  data,
  id,
  icon: icon2,
  children,
  ...restProps
}) => {
  assert__default.default(
    typeof children === "undefined" || typeof children === "string",
    "Tag may only contain a string"
  );
  assert__default.default(
    !icon2 || icon2.props.size === void 0 || icon2.props.tone === void 0,
    "Icons cannot set the 'size' or 'tone' prop when passed to a Tag component"
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToastContext.Box,
    {
      id,
      display: "flex",
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        ToastContext.Box,
        {
          display: "flex",
          minWidth: 0,
          alignItems: "center",
          background: "neutralLight",
          paddingY: onClear ? void 0 : "xxsmall",
          paddingLeft: icon2 ? "xsmall" : "small",
          paddingRight: onClear ? void 0 : "small",
          borderRadius: "full",
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { minWidth: 0, title: children, children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { baseline: false, maxLines: 1, icon: icon2, children }) }),
            onClear ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { flexShrink: 0, display: "flex", className: styles_lib_components_Tag_Tag_css_cjs.clearGutter, children: /* @__PURE__ */ jsxRuntime.jsx(
              ToastContext.ButtonIcon,
              {
                id: id ? `${id}-clear` : void 0,
                icon: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.IconClear, {}),
                label: clearLabel,
                tone: "secondary",
                variant: "transparent",
                bleed: false,
                onClick: onClear
              }
            ) }) : null
          ]
        }
      )
    }
  );
};
const styleForTone = { caution: styles_lib_components_Textarea_Highlight_Highlight_css_cjs.caution, critical: styles_lib_components_Textarea_Highlight_Highlight_css_cjs.critical };
const Highlight = ({ children, tone }) => /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Box, { component: "mark", className: [styles_lib_components_Textarea_Highlight_Highlight_css_cjs.root, styleForTone[tone]], children });
const formatRanges = (value, highlightRanges, tone) => {
  if (highlightRanges && value) {
    let lastEnd = 0;
    const validatedAndSortedRanges = highlightRanges.sort((a, b) => a.start > b.start ? 1 : -1).reduce((acc, { end, start }) => {
      const resolvedEnd = end || value.length;
      if (resolvedEnd <= start) {
        return acc;
      }
      const adjustedRange = [];
      if (resolvedEnd > lastEnd) {
        adjustedRange.push({
          // if overlapping, start from end of last range otherwise start from specified range
          start: start < lastEnd ? lastEnd : start,
          end
        });
        lastEnd = resolvedEnd;
      }
      return [...acc, ...adjustedRange];
    }, []);
    return parseHighlights__default.default(
      value,
      validatedAndSortedRanges.map(({ start, end }) => [
        start,
        end || value.length
      ])
    ).reduce((acc, { text, highlight }, i) => {
      if (text) {
        acc.push(
          highlight ? /* @__PURE__ */ jsxRuntime.jsx(Highlight, { tone, children: text }, i) : text
        );
      }
      return acc;
    }, []);
  }
  return [value];
};
const getCharacterLimitStatus = ({
  characterLimit,
  value
}) => {
  const inputLength = String(value).length;
  if (inputLength < Math.ceil(characterLimit * 0.7 / 10) * 10) {
    return null;
  }
  const diff = characterLimit - inputLength;
  const valid = diff >= 0;
  return /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { size: "small", tone: valid ? "secondary" : "critical", children: diff });
};
const pxToInt = (str) => typeof str === "string" ? parseInt(str.replace("px", ""), 10) : 0;
const calculateLines = (target, lines, lineLimit) => {
  const { paddingBottom, paddingTop, lineHeight } = window.getComputedStyle(target);
  if (!lineHeight.endsWith("px")) {
    return lines;
  }
  const padding = pxToInt(paddingTop) + pxToInt(paddingBottom);
  const currentRows = Math.floor(
    (target.scrollHeight - padding) / pxToInt(lineHeight)
  );
  if (target && target.value === "") {
    return lines;
  }
  return typeof lineLimit === "number" && currentRows > lineLimit ? lineLimit : currentRows;
};
const Textarea = React.forwardRef(
  ({
    value,
    onChange,
    onBlur,
    onFocus,
    onPaste,
    placeholder,
    characterLimit,
    highlightRanges: highlightRangesProp = [],
    lines = 3,
    lineLimit,
    grow = true,
    tone,
    spellCheck,
    ...restProps
  }, ref) => {
    const [rows, setRows] = React.useState(lines);
    const highlightsRef = React.useRef(null);
    const updateScroll = React.useCallback(
      (scrollTop) => {
        if (highlightsRef.current) {
          highlightsRef.current.scrollTop = scrollTop;
        }
      },
      [highlightsRef]
    );
    const inputLength = String(value).length;
    const hasExceededCharacterLimit = characterLimit && inputLength > characterLimit;
    const highlightTone = !hasExceededCharacterLimit && (tone === "critical" || tone === "caution") ? tone : "critical";
    const highlightRanges = hasExceededCharacterLimit ? [{ start: characterLimit }] : highlightRangesProp;
    const hasHighlights = highlightRanges.length > 0;
    return /* @__PURE__ */ jsxRuntime.jsx(
      Field,
      {
        ...restProps,
        tone,
        value,
        icon: void 0,
        prefix: void 0,
        labelId: void 0,
        secondaryMessage: characterLimit ? getCharacterLimitStatus({
          value,
          characterLimit
        }) : null,
        children: (overlays, { className, borderRadius: borderRadius2, background, ...fieldProps }) => /* @__PURE__ */ jsxRuntime.jsxs(
          ToastContext.Box,
          {
            position: "relative",
            width: "full",
            zIndex: 0,
            background,
            borderRadius: borderRadius2,
            children: [
              hasHighlights ? /* @__PURE__ */ jsxRuntime.jsx(
                ToastContext.Box,
                {
                  ref: highlightsRef,
                  position: "absolute",
                  overflow: "hidden",
                  pointerEvents: "none",
                  height: "full",
                  "aria-hidden": "true",
                  top: 0,
                  left: 0,
                  className: [styles_lib_components_Textarea_Textarea_css_cjs.highlights, className],
                  ...fieldProps,
                  children: formatRanges(String(value), highlightRanges, highlightTone)
                }
              ) : null,
              /* @__PURE__ */ jsxRuntime.jsx(
                ToastContext.Box,
                {
                  component: "textarea",
                  position: "relative",
                  zIndex: 1,
                  rows,
                  value,
                  onChange: (e) => {
                    if (grow) {
                      setRows(calculateLines(e.currentTarget, lines, lineLimit));
                    }
                    if (typeof onChange === "function") {
                      onChange(e);
                    }
                    if (hasHighlights) {
                      updateScroll(e.currentTarget.scrollTop);
                    }
                  },
                  onBlur,
                  onFocus,
                  onPaste,
                  onScroll: hasHighlights ? (event) => updateScroll(event.currentTarget.scrollTop) : void 0,
                  placeholder: !restProps.disabled ? placeholder : void 0,
                  spellCheck,
                  className: [styles_lib_components_Textarea_Textarea_css_cjs.field, className],
                  ...fieldProps,
                  ref
                }
              ),
              overlays
            ]
          }
        )
      }
    );
  }
);
Textarea.displayName = "Textarea";
function parseSimpleToComplexOption(option) {
  return typeof option === "object" && option !== null && "text" in option && "value" in option ? option : { value: option, text: String(option) };
}
function TextDropdown({
  id,
  value,
  onChange,
  onBlur,
  options,
  label,
  data,
  ...restProps
}) {
  assert__default.default(
    (() => {
      const inText = React.useContext(ToastContext.TextContext);
      const inHeading = React.useContext(ToastContext.HeadingContext);
      return inText || inHeading;
    })(),
    "TextDropdown components must be rendered within a Text or Heading component. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/TextDropdown"
  );
  const parsedOptions = options.map(parseSimpleToComplexOption);
  const [currentText] = parsedOptions.filter((o) => value === o.value);
  if (!currentText || !currentText.text) {
    throw new Error(
      `The provided value of "${value}" does not exist in the provided \`options\` list.`
    );
  }
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ToastContext.Box,
    {
      display: "inlineBlock",
      position: "relative",
      ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Box, { pointerEvents: "none", userSelect: "none", children: [
          currentText.text,
          " ",
          /* @__PURE__ */ jsxRuntime.jsx(IconChevron, { alignY: "lowercase" })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            component: "select",
            position: "absolute",
            inset: 0,
            width: "full",
            opacity: 0,
            className: styles_lib_components_TextDropdown_TextDropdown_css_cjs.select,
            "aria-label": label,
            title: label,
            id,
            value: String(value),
            onChange: (ev) => {
              if (typeof onChange === "function") {
                const newValue = parsedOptions[ev.currentTarget.selectedIndex].value;
                onChange(newValue);
              }
            },
            onBlur,
            children: /* @__PURE__ */ jsxRuntime.jsx("optgroup", { label, children: parsedOptions.map((option) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: String(option.value), children: option.text }, String(option.value))) })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Overlay,
          {
            boxShadow: "outlineFocus",
            borderRadius: "standard",
            transition: "fast",
            onlyVisibleForKeyboardNavigation: true,
            className: styles_lib_components_TextDropdown_TextDropdown_css_cjs.focusOverlay
          }
        )
      ]
    }
  );
}
const validTypes = {
  text: "text",
  password: "password",
  email: "email",
  search: "search",
  number: "number",
  tel: "tel",
  url: "url"
};
const defaultInputModesForType = {
  text: "text",
  password: "text",
  email: "email",
  search: "search",
  number: "numeric",
  tel: "tel",
  url: "url"
};
const TextField = React.forwardRef(
  ({
    value,
    type = "text",
    onChange,
    onBlur,
    onFocus,
    onClear,
    placeholder,
    characterLimit,
    id,
    clearLabel,
    inputMode,
    step,
    ...restProps
  }, forwardedRef) => {
    const defaultRef = React.useRef(null);
    const inputRef = forwardedRef || defaultRef;
    const clearable = Boolean(
      typeof onClear !== "undefined" && !restProps.disabled && typeof value === "string" && value.length > 0
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      Field,
      {
        ...restProps,
        id,
        value,
        labelId: void 0,
        secondaryMessage: characterLimit ? getCharacterLimitStatus({
          value,
          characterLimit
        }) : null,
        secondaryIcon: onClear ? /* @__PURE__ */ jsxRuntime.jsx(
          ClearField,
          {
            id: `${id}-clear`,
            hide: !clearable,
            onClear,
            label: clearLabel,
            inputRef
          }
        ) : null,
        children: (overlays, fieldProps, icon2, secondaryIcon, prefix) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
          icon2,
          prefix,
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              component: "input",
              type: validTypes[type],
              value,
              onChange,
              onFocus,
              onBlur,
              placeholder: !restProps.disabled ? placeholder : void 0,
              ...fieldProps,
              inputMode: inputMode || defaultInputModesForType[type],
              step,
              ref: inputRef
            }
          ),
          overlays,
          secondaryIcon
        ] })
      }
    );
  }
);
TextField.displayName = "TextField";
const Tiles = ({
  children,
  space = "none",
  columns = 1,
  dividers = false,
  data,
  ...restProps
}) => /* @__PURE__ */ jsxRuntime.jsx(
  ToastContext.Box,
  {
    className: ToastContext.negativeMargin("top", space),
    ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
    children: /* @__PURE__ */ jsxRuntime.jsx(
      ToastContext.Box,
      {
        display: "flex",
        flexWrap: "wrap",
        className: ToastContext.negativeMargin("left", space),
        children: React.Children.map(ToastContext.flattenChildren(children), (child, i) => /* @__PURE__ */ jsxRuntime.jsx(
          ToastContext.Box,
          {
            minWidth: 0,
            className: ToastContext.resolveResponsiveProp(
              columns,
              styles_lib_components_Tiles_Tiles_css_cjs.columnsMobile,
              styles_lib_components_Tiles_Tiles_css_cjs.columnsTablet,
              styles_lib_components_Tiles_Tiles_css_cjs.columnsDesktop,
              styles_lib_components_Tiles_Tiles_css_cjs.columnsWide
            ),
            children: /* @__PURE__ */ jsxRuntime.jsxs(
              ToastContext.Box,
              {
                height: "full",
                paddingTop: space,
                paddingLeft: space,
                children: [
                  dividers && i > 0 ? /* @__PURE__ */ jsxRuntime.jsx(
                    ToastContext.Box,
                    {
                      paddingBottom: space,
                      display: styles_lib_css_atoms_sprinkles_css_cjs.mapResponsiveValue(
                        columns,
                        (column) => column === 1 ? "block" : "none"
                      ),
                      children: typeof dividers === "string" ? /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Divider, { weight: dividers }) : /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Divider, {})
                    }
                  ) : null,
                  child
                ]
              }
            )
          }
        ))
      }
    )
  }
);
const handleChange = (onChange) => (event) => {
  if (typeof onChange === "function") {
    onChange(event.target.checked);
  }
};
const Toggle = React.forwardRef(
  ({
    id,
    on,
    onChange,
    label,
    align = "left",
    size = "standard",
    data,
    ...restProps
  }, forwardedRef) => {
    const lightness = ToastContext.useBackgroundLightness();
    return /* @__PURE__ */ jsxRuntime.jsxs(
      ToastContext.Box,
      {
        position: "relative",
        zIndex: 0,
        display: "flex",
        flexDirection: align === "left" ? void 0 : "rowReverse",
        className: styles_lib_components_Toggle_Toggle_css_cjs.root,
        ...ToastContext.buildDataAttributes({ data, validateRestProps: restProps }),
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              component: "input",
              type: "checkbox",
              id,
              checked: on,
              onChange: handleChange(onChange),
              position: "absolute",
              zIndex: 1,
              cursor: "pointer",
              opacity: 0,
              className: [
                styles_lib_components_Toggle_Toggle_css_cjs.realField,
                styles_lib_components_Toggle_Toggle_css_cjs.realFieldPosition[size],
                styles_lib_components_Toggle_Toggle_css_cjs.fieldSize[size]
              ],
              ref: forwardedRef
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsxs(
            ToastContext.Box,
            {
              position: "relative",
              display: "flex",
              alignItems: "center",
              flexShrink: 0,
              className: [
                styles_lib_components_Toggle_Toggle_css_cjs.slideContainer,
                styles_lib_components_Toggle_Toggle_css_cjs.slideContainerSize[size],
                styles_lib_components_Toggle_Toggle_css_cjs.fieldSize[size]
              ],
              children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  ToastContext.Box,
                  {
                    position: "absolute",
                    width: "full",
                    overflow: "hidden",
                    borderRadius: "full",
                    className: [
                      styles_lib_components_Toggle_Toggle_css_cjs.slideTrack[size],
                      styles_lib_components_Toggle_Toggle_css_cjs.slideTrackMask,
                      styles_lib_components_Toggle_Toggle_css_cjs.slideTrackBgLightMode[lightness.lightMode],
                      styles_lib_components_Toggle_Toggle_css_cjs.slideTrackBgDarkMode[lightness.darkMode]
                    ],
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      ToastContext.Box,
                      {
                        position: "absolute",
                        width: "full",
                        height: "full",
                        background: "formAccent",
                        transition: "fast",
                        className: styles_lib_components_Toggle_Toggle_css_cjs.slideTrackSelected
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntime.jsxs(
                  ToastContext.Box,
                  {
                    position: "absolute",
                    background: "surface",
                    transition: "fast",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    borderRadius: "full",
                    className: styles_lib_components_Toggle_Toggle_css_cjs.slider[size],
                    children: [
                      /* @__PURE__ */ jsxRuntime.jsx(
                        ToastContext.FieldOverlay,
                        {
                          variant: on ? "formAccent" : "default",
                          borderRadius: "full",
                          visible: true,
                          className: {
                            [styles_lib_components_Toggle_Toggle_css_cjs.hideBorderOnDarkBackgroundInLightMode]: lightness.lightMode === "dark"
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntime.jsx(ToastContext.FieldOverlay, { className: styles_lib_components_Toggle_Toggle_css_cjs.icon, children: /* @__PURE__ */ jsxRuntime.jsx(IconTick, { tone: "formAccent", size: "fill" }) }),
                      /* @__PURE__ */ jsxRuntime.jsx(
                        ToastContext.FieldOverlay,
                        {
                          variant: "focus",
                          borderRadius: "full",
                          className: styles_lib_components_Toggle_Toggle_css_cjs.focusOverlay
                        }
                      ),
                      /* @__PURE__ */ jsxRuntime.jsx(
                        ToastContext.FieldOverlay,
                        {
                          variant: "formAccent",
                          borderRadius: "full",
                          className: !on ? styles_lib_components_Toggle_Toggle_css_cjs.hoverOverlay : void 0
                        }
                      )
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            ToastContext.Box,
            {
              component: "label",
              htmlFor: id,
              paddingLeft: align === "left" ? "xsmall" : void 0,
              paddingRight: align === "right" || align === "justify" ? "xsmall" : void 0,
              flexGrow: align === "justify" ? 1 : void 0,
              userSelect: "none",
              cursor: "pointer",
              className: [styles_lib_components_Toggle_Toggle_css_cjs.label[size], ToastContext.virtualTouchable()],
              children: /* @__PURE__ */ jsxRuntime.jsx(ToastContext.Text, { baseline: false, weight: on ? "strong" : void 0, size, children: label })
            }
          )
        ]
      }
    );
  }
);
exports.Accordion = Accordion;
exports.AccordionItem = AccordionItem;
exports.Actions = Actions;
exports.Alert = Alert;
exports.AllowCloseContext = AllowCloseContext;
exports.Autosuggest = Autosuggest;
exports.Badge = Badge;
exports.BoxRenderer = BoxRenderer;
exports.ButtonLink = ButtonLink;
exports.Card = Card;
exports.Checkbox = Checkbox;
exports.CheckboxStandalone = CheckboxStandalone;
exports.Dialog = Dialog;
exports.Disclosure = Disclosure;
exports.Drawer = Drawer;
exports.Dropdown = Dropdown;
exports.FieldLabel = FieldLabel;
exports.FieldMessage = FieldMessage;
exports.Heading = Heading;
exports.HiddenVisually = HiddenVisually;
exports.IconAdd = IconAdd;
exports.IconArrow = IconArrow;
exports.IconBookmark = IconBookmark;
exports.IconCaution = IconCaution;
exports.IconChevron = IconChevron;
exports.IconCompany = IconCompany;
exports.IconCompose = IconCompose;
exports.IconCopy = IconCopy;
exports.IconCreditCard = IconCreditCard;
exports.IconDate = IconDate;
exports.IconDelete = IconDelete;
exports.IconDesktop = IconDesktop;
exports.IconDocument = IconDocument;
exports.IconDocumentBroken = IconDocumentBroken;
exports.IconDownload = IconDownload;
exports.IconEdit = IconEdit;
exports.IconEducation = IconEducation;
exports.IconEnlarge = IconEnlarge;
exports.IconFilter = IconFilter;
exports.IconFlag = IconFlag;
exports.IconGrid = IconGrid;
exports.IconHeart = IconHeart;
exports.IconHelp = IconHelp;
exports.IconHistory = IconHistory;
exports.IconHome = IconHome;
exports.IconImage = IconImage;
exports.IconInfo = IconInfo;
exports.IconInvoice = IconInvoice;
exports.IconLanguage = IconLanguage;
exports.IconLink = IconLink;
exports.IconLinkBroken = IconLinkBroken;
exports.IconList = IconList;
exports.IconLocation = IconLocation;
exports.IconMail = IconMail;
exports.IconMessage = IconMessage;
exports.IconMinus = IconMinus;
exports.IconMobile = IconMobile;
exports.IconMoney = IconMoney;
exports.IconNewWindow = IconNewWindow;
exports.IconNote = IconNote;
exports.IconNotification = IconNotification;
exports.IconOverflow = IconOverflow;
exports.IconPeople = IconPeople;
exports.IconPersonAdd = IconPersonAdd;
exports.IconPersonVerified = IconPersonVerified;
exports.IconPhone = IconPhone;
exports.IconPlatformAndroid = IconPlatformAndroid;
exports.IconPlatformApple = IconPlatformApple;
exports.IconPrint = IconPrint;
exports.IconProfile = IconProfile;
exports.IconPromote = IconPromote;
exports.IconRecommended = IconRecommended;
exports.IconRefresh = IconRefresh;
exports.IconResume = IconResume;
exports.IconSearch = IconSearch;
exports.IconSecurity = IconSecurity;
exports.IconSend = IconSend;
exports.IconSent = IconSent;
exports.IconSettings = IconSettings;
exports.IconShare = IconShare;
exports.IconSocialFacebook = IconSocialFacebook;
exports.IconSocialGitHub = IconSocialGitHub;
exports.IconSocialInstagram = IconSocialInstagram;
exports.IconSocialLinkedIn = IconSocialLinkedIn;
exports.IconSocialMedium = IconSocialMedium;
exports.IconSocialTwitter = IconSocialTwitter;
exports.IconSocialYouTube = IconSocialYouTube;
exports.IconStar = IconStar;
exports.IconStatistics = IconStatistics;
exports.IconSubCategory = IconSubCategory;
exports.IconTag = IconTag;
exports.IconThumb = IconThumb;
exports.IconTick = IconTick;
exports.IconTime = IconTime;
exports.IconTip = IconTip;
exports.IconUpload = IconUpload;
exports.IconVideo = IconVideo;
exports.IconVisibility = IconVisibility;
exports.IconWorkExperience = IconWorkExperience;
exports.IconZoomIn = IconZoomIn;
exports.IconZoomOut = IconZoomOut;
exports.Link = Link;
exports.List = List;
exports.Loader = Loader;
exports.MenuItem = MenuItem;
exports.MenuItemCheckbox = MenuItemCheckbox;
exports.MenuItemDivider = MenuItemDivider;
exports.MenuItemLink = MenuItemLink;
exports.MenuRenderer = MenuRenderer;
exports.MonthPicker = MonthPicker;
exports.Notice = Notice;
exports.OverflowMenu = OverflowMenu;
exports.Page = Page$1;
exports.PageBlock = PageBlock;
exports.Pagination = Pagination;
exports.PasswordField = PasswordField;
exports.Radio = Radio;
exports.RadioGroup = RadioGroup;
exports.RadioItem = RadioItem;
exports.Rating = Rating;
exports.Secondary = Secondary;
exports.Step = Step;
exports.Stepper = Stepper;
exports.Strong = Strong;
exports.Tab = Tab;
exports.TabPanel = TabPanel;
exports.TabPanels = TabPanels;
exports.Tabs = Tabs;
exports.TabsProvider = TabsProvider;
exports.Tag = Tag;
exports.TextDropdown = TextDropdown;
exports.TextField = TextField;
exports.Textarea = Textarea;
exports.ThemeNameConsumer = ThemeNameConsumer;
exports.Tiles = Tiles;
exports.Toggle = Toggle;
exports.defaultPageLimit = defaultPageLimit;
exports.filterSuggestions = filterSuggestions;
exports.parseSimpleToComplexOption = parseSimpleToComplexOption;
exports.tones = tones$1;
exports.useBreakpoint = useBreakpoint;
exports.useColor = useColor;
exports.validCardComponents = validCardComponents;
exports.validSpaceValues = validSpaceValues;
