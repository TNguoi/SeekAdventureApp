import React, { createContext, useContext, forwardRef, createElement, useEffect, Children, isValidElement, cloneElement, useMemo, useState, useRef, useLayoutEffect, useCallback, Fragment as Fragment$1, useReducer } from "react";
import { useBraidTheme, VanillaThemeContainer, breakpointContext, useLinkComponent } from "./side-effects/lib/components/BraidProvider/BraidProvider.mjs";
import { breakpointNames } from "./styles/lib/css/breakpoints.mjs";
import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { createPortal } from "react-dom";
import clsx from "clsx";
import dedent from "dedent";
import { base } from "./styles/lib/css/reset/reset.css.mjs";
import { atoms } from "./styles/lib/css/atoms/atoms.mjs";
import { mapColorModeValue, sprinkles, mapResponsiveValue, normalizeResponsiveValue } from "./styles/lib/css/atoms/sprinkles.css.mjs";
import { lightModeTone, darkModeTone, lightModeNeutralOverride, darkModeNeutralOverride, fontFamily, fontWeight, tone, textSizeTrimmed, textSizeUntrimmed } from "./styles/lib/css/typography.css.mjs";
import assert from "assert";
import { isFragment } from "react-is";
import { base as base$1, strong, regular, lightModeWeight, darkModeWeight } from "./styles/lib/components/Divider/Divider.css.mjs";
import { hiddenOnPrint } from "./styles/lib/components/Hidden/Hidden.css.mjs";
import { preventCollapsePseudo, top, right, bottom, left } from "./styles/lib/css/negativeMargin/negativeMargin.css.mjs";
import { column, width, columnContent } from "./styles/lib/components/Column/Column.css.mjs";
import { marginAuto } from "./styles/lib/components/ContentBlock/ContentBlock.css.mjs";
import { assignInlineVars } from "@vanilla-extract/dynamic";
import { base as base$2, multiLine, lineLimit } from "./styles/lib/components/private/MaxLines/MaxLines.css.mjs";
import { nowrap } from "./styles/lib/components/private/AvoidWidowIcon/AvoidWidowIcon.css.mjs";
import { virtualTouchable as virtualTouchable$1, yAxisOnly } from "./styles/lib/components/private/touchable/virtualTouchable.css.mjs";
import { weakLink, regularLinkLightMode, regularLinkDarkMode, base as base$3, visitedLightMode, visitedDarkMode } from "./styles/lib/components/TextLink/TextLink.css.mjs";
import { lineHeightContainer } from "./styles/lib/css/lineHeightContainer.css.mjs";
import { size, inlineCrop, inline, alignY, cropToTextSize, blockWidths } from "./styles/lib/hooks/useIcon/icon.css.mjs";
import { hideFocusRingsClassName } from "./styles/lib/components/private/hideFocusRings/hideFocusRings.css.mjs";
import { focusOverlay, hoverOverlay, invertedBackgroundsLightMode, invertedBackgroundsDarkMode, forceActive, activeOverlay, padToMinHeight, root, standard, small, bleedVerticallyToCapHeight, loadingDot } from "./styles/lib/components/Button/Button.css.mjs";
import { usePopperTooltip } from "react-popper-tooltip";
import isMobile from "is-mobile";
import { verticalOffsetBeforeEntrance, translateZ0, maxWidth, arrow } from "./styles/lib/components/TooltipRenderer/TooltipRenderer.css.mjs";
import { button } from "./styles/lib/components/ButtonIcon/ButtonIcon.css.mjs";
import { toast } from "./styles/lib/components/useToast/Toast.css.mjs";
const TextContext = createContext(null);
const BraidPortal = ({ children, container }) => {
  const { vanillaTheme } = useBraidTheme();
  return createPortal(
    /* @__PURE__ */ jsx(TextContext.Provider, { value: null, children: /* @__PURE__ */ jsx(VanillaThemeContainer, { theme: vanillaTheme, setDefaultTextTones: true, children }) }),
    container ?? document.body
  );
};
const useThemeName = () => useBraidTheme().name;
const useSpace = () => useBraidTheme().space;
function resolveResponsiveObject(breakpointName, value) {
  let resolvedValue = null;
  for (const currentBreakpointName of breakpointNames) {
    const valueForBreakpoint = value[currentBreakpointName];
    if (valueForBreakpoint !== void 0) {
      resolvedValue = valueForBreakpoint;
    }
    if (breakpointName === currentBreakpointName) {
      return resolvedValue;
    }
  }
  return resolvedValue;
}
const useResponsiveValue = () => {
  const breakpointName = useContext(breakpointContext);
  return function responsiveValue(value) {
    return breakpointName ? resolveResponsiveObject(breakpointName, value) : null;
  };
};
const buildDataAttributes = ({ data, validateRestProps }) => {
  if (process.env.NODE_ENV !== "production") {
    if (validateRestProps !== false) {
      const dataAttrs = Object.keys(validateRestProps).filter(
        (prop) => prop.startsWith("data-")
      );
      const formatter = (v) => {
        if (typeof v === "boolean") {
          return v ? "" : `={false}`;
        }
        if (typeof v === "number") {
          return `={${v}}`;
        }
        return `="${v}"`;
      };
      if (dataAttrs.length > 0) {
        console.warn(
          dedent`
          Braid components do not support the native data attribute format. Use the “data” prop instead.
            <Component
          %c${dataAttrs.map((attr) => `-    ${attr}${formatter(validateRestProps[attr])}`).join("\n")}
          %c+    data={{
          ${dataAttrs.map((attr) => {
            const attributeName = attr.replace(/^data-/, "");
            const property = attributeName.includes("-") ? `'${attributeName}'` : attributeName;
            return `+      ${property}: ${typeof validateRestProps[attr] === "string" ? `'${validateRestProps[attr]}'` : validateRestProps[attr]},`;
          }).join("\n")}
          +    }}
            %c/>
           For more details, see the “Data Attributes” documentation:
           https://seek-oss.github.io/braid-design-system/components/Box#data-attributes
        `,
          "color: red",
          "color: green",
          "color: inherit"
        );
      }
    }
  }
  if (!data) {
    return;
  }
  const keys = Object.keys(data);
  const dataAttributes = {};
  for (const key of keys) {
    dataAttributes[`data-${key}`] = data[key];
  }
  return dataAttributes;
};
const backgroundContext = createContext({
  lightMode: "body",
  darkMode: "bodyDark"
});
const BackgroundProvider = backgroundContext.Provider;
const useBackground = () => useContext(backgroundContext);
const useBackgroundLightness = (backgroundOverride) => {
  const backgroundFromContext = useBackground();
  const background = backgroundOverride || backgroundFromContext;
  const { backgroundLightness } = useBraidTheme();
  const lightnessMap = {
    ...backgroundLightness,
    customDark: "dark",
    customLight: "light"
  };
  return {
    lightMode: lightnessMap[background.lightMode],
    darkMode: lightnessMap[background.darkMode]
  };
};
const useColorContrast = () => {
  const background = useBackground();
  const backgroundLightness = useBackgroundLightness();
  return (map) => mapColorModeValue(
    backgroundLightness,
    (lightness, mode) => typeof map === "function" ? map(lightness, background[mode]) : map[lightness]
  );
};
const adaptiveBackgrounds = {
  body: "bodyDark",
  surface: "surfaceDark",
  brand: "neutral",
  promoteLight: "neutral",
  infoLight: "neutral",
  positiveLight: "neutral",
  cautionLight: "neutral",
  criticalLight: "neutral",
  neutralLight: "neutral",
  formAccentSoft: "neutral",
  formAccentSoftActive: "neutralActive",
  formAccentSoftHover: "neutralHover"
};
const adaptiveBoxShadow = {
  borderBrandAccent: "borderBrandAccentLight",
  borderBrandAccentLarge: "borderBrandAccentLightLarge",
  borderCaution: "borderCautionLight",
  borderCritical: "borderCriticalLight",
  borderCriticalLarge: "borderCriticalLightLarge",
  borderFormAccent: "borderFormAccentLight",
  borderFormAccentLarge: "borderFormAccentLightLarge",
  borderInfo: "borderInfoLight",
  borderNeutral: "borderNeutralInverted",
  borderNeutralLarge: "borderNeutralInvertedLarge",
  borderNeutralLight: "borderNeutral",
  borderPositive: "borderPositiveLight",
  borderPromote: "borderPromoteLight"
};
const normaliseBackground = (background) => ({
  lightMode: typeof background === "object" ? background.lightMode : background,
  darkMode: typeof background === "object" ? background.darkMode : adaptiveBackgrounds[background] || background
});
const normalisedBoxShadow = (boxShadow) => ({
  lightMode: typeof boxShadow === "object" ? boxShadow.lightMode : boxShadow,
  darkMode: typeof boxShadow === "object" ? boxShadow.darkMode : boxShadow
});
const useColoredBoxClasses = ({
  background,
  boxShadow
}) => {
  const parentLightness = useBackgroundLightness();
  const currentBackgroundContext = useBackground();
  const { backgroundLightness } = useBraidTheme();
  const lightnessMap = {
    ...backgroundLightness,
    customDark: "dark",
    customLight: "light"
  };
  const classList = [];
  if (boxShadow) {
    const normalisedBoxShadows = normalisedBoxShadow(boxShadow);
    const isSemantic = typeof boxShadow === "string";
    classList.push(
      atoms({
        boxShadow: {
          lightMode: isSemantic && parentLightness.lightMode === "dark" ? adaptiveBoxShadow[normalisedBoxShadows.lightMode] || normalisedBoxShadows.lightMode : normalisedBoxShadows.lightMode,
          darkMode: isSemantic && parentLightness.darkMode === "dark" ? adaptiveBoxShadow[normalisedBoxShadows.darkMode] || normalisedBoxShadows.darkMode : normalisedBoxShadows.darkMode
        }
      })
    );
  }
  if (background) {
    const { lightMode, darkMode } = normaliseBackground(background);
    classList.push(lightModeTone[lightnessMap[lightMode]]);
    classList.push(darkModeTone[lightnessMap[darkMode]]);
    const lightModeTone$1 = lightMode === "neutral" ? darkMode : lightMode;
    const darkModeTone$1 = darkMode === "neutral" ? lightMode : darkMode;
    if (lightModeTone$1 && lightModeNeutralOverride[lightModeTone$1]) {
      classList.push(lightModeNeutralOverride[lightModeTone$1]);
    }
    if (darkModeTone$1 && darkModeNeutralOverride[darkModeTone$1]) {
      classList.push(darkModeNeutralOverride[darkModeTone$1]);
    }
    classList.push(
      atoms({
        background: {
          lightMode: lightMode === "customDark" || lightMode === "customLight" ? void 0 : lightMode,
          darkMode: darkMode === "customDark" || darkMode === "customLight" ? void 0 : darkMode
        }
      })
    );
    return {
      backgroundContext: {
        lightMode: lightMode || currentBackgroundContext.lightMode,
        darkMode: darkMode || currentBackgroundContext.darkMode
      },
      classList: classList.join(" ")
    };
  }
  return {
    classList: classList.join(" ")
  };
};
const ColoredBox = forwardRef(
  ({ component, background, boxShadow, className, ...props }, ref) => {
    const { backgroundContext: backgroundContext2, classList: colorClasses } = useColoredBoxClasses(
      { background, boxShadow }
    );
    const element = createElement(component, {
      className: `${className}${colorClasses ? ` ${colorClasses}` : ""}`,
      ...props,
      ref
    });
    return backgroundContext2 ? /* @__PURE__ */ jsx(BackgroundProvider, { value: backgroundContext2, children: element }) : element;
  }
);
ColoredBox.displayName = "ColoredBox";
const Box = forwardRef(
  ({ component = "div", className, background, boxShadow, data, ...restProps }, ref) => {
    const atomProps = {};
    const nativeProps = {
      ...data ? (
        // Not validating rest props as Box supports native HTML element props
        // and we do not want to warn against using the native syntax.
        buildDataAttributes({ data, validateRestProps: false })
      ) : void 0
    };
    for (const key in restProps) {
      if (sprinkles.properties.has(key)) {
        atomProps[key] = restProps[key];
      } else {
        nativeProps[key] = restProps[key];
      }
    }
    const userClasses = clsx(className);
    if (process.env.NODE_ENV !== "production") {
      useEffect(() => {
        if (userClasses.includes(base)) {
          throw new Error(
            dedent`
              Reset class has been applied more than once. This is normally caused when asking for an explicit reset on the \`atoms\` function. This can be removed as Box automatically adds reset classes.

              atoms({
                reset: '...' // <-- Remove this
              })
            `
          );
        }
      }, [userClasses]);
    }
    const atomicClasses = atoms({
      reset: typeof component === "string" ? component : "div",
      ...atomProps
    });
    const combinedClasses = `${atomicClasses}${userClasses ? ` ${userClasses}` : ""}`;
    return background || boxShadow ? /* @__PURE__ */ jsx(
      ColoredBox,
      {
        component,
        background,
        boxShadow,
        className: combinedClasses,
        ref,
        ...nativeProps
      }
    ) : createElement(component, {
      className: combinedClasses,
      ...nativeProps,
      ref
    });
  }
);
Box.displayName = "Box";
const PublicBox = forwardRef(
  (props, ref) => {
    if (process.env.NODE_ENV !== "production") {
      if (typeof props.background !== "undefined" && typeof props.background !== "string") {
        throw new Error("Conditional backgrounds are not suppported");
      }
      if (typeof props.boxShadow !== "undefined" && typeof props.boxShadow !== "string") {
        throw new Error("Conditional boxShadows are not suppported");
      }
    }
    return /* @__PURE__ */ jsx(Box, { ...props, ref });
  }
);
PublicBox.displayName = "Box";
function flattenChildren(children, depth = 0, keys = []) {
  return Children.toArray(children).reduce(
    (acc, node, nodeIndex) => {
      if (isFragment(node)) {
        acc.push(
          ...flattenChildren(
            node.props.children,
            depth + 1,
            keys.concat(node.key || nodeIndex)
          )
        );
      } else if (isValidElement(node)) {
        acc.push(
          cloneElement(node, {
            key: keys.concat(String(node.key)).join(".")
          })
        );
      } else if (typeof node === "string" || typeof node === "number") {
        acc.push(node);
      }
      return acc;
    },
    []
  );
}
const Divider = ({ weight = "regular" }) => {
  const lightness = useBackgroundLightness();
  return /* @__PURE__ */ jsx(Box, { component: "span", display: "block", position: "relative", children: /* @__PURE__ */ jsx(
    Box,
    {
      component: "span",
      position: "absolute",
      width: "full",
      className: [
        base$1,
        weight === "strong" ? strong : regular,
        lightModeWeight[lightness.lightMode],
        darkModeWeight[lightness.darkMode]
      ]
    }
  ) });
};
const HeadingContext = createContext(false);
const resolveResponsiveRangeProps = (props) => {
  const { above, below } = props;
  if (!above && !below) {
    return [false, false, false, false];
  }
  const startIndex = above ? breakpointNames.indexOf(above) + 1 : 0;
  const endIndex = below ? breakpointNames.indexOf(below) - 1 : breakpointNames.length - 1;
  const range = breakpointNames.slice(startIndex, endIndex + 1);
  const includeMobile = range.indexOf("mobile") >= 0;
  const includeTablet = range.indexOf("tablet") >= 0;
  const includeDesktop = range.indexOf("desktop") >= 0;
  const includeWide = range.indexOf("wide") >= 0;
  return [includeMobile, includeTablet, includeDesktop, includeWide];
};
const optimizeResponsiveArray = (value) => {
  let lastValue;
  const values = value.map((v) => {
    if (v !== lastValue && v !== null) {
      lastValue = v;
      return v;
    }
    return null;
  });
  return [
    values[0] ?? null,
    values[1] ?? null,
    values[2] ?? null,
    values[3] ?? null
  ];
};
const Hidden = ({
  children,
  component,
  above,
  below,
  screen,
  print,
  inline: inlineProp,
  data,
  ...restProps
}) => {
  if (process.env.NODE_ENV === "development" && screen) {
    console.warn(
      `You used the "screen" prop on Hidden, but this probably doesn't do what you expect. If you're trying to provide content to screen readers without rendering it to the screen, use the <HiddenVisually> component instead. The "screen" prop is likely to be deprecated in a future release.`
    );
  }
  const inText = Boolean(useContext(TextContext));
  const inHeading = Boolean(useContext(HeadingContext));
  const hiddenOnScreen = Boolean(screen);
  const hiddenOnPrint$1 = Boolean(print);
  const [hiddenOnMobile, hiddenOnTablet, hiddenOnDesktop, hiddenOnWide] = resolveResponsiveRangeProps({ above, below });
  const inline2 = inlineProp ?? (inText || inHeading);
  const display = inline2 ? "inline" : "block";
  return /* @__PURE__ */ jsx(
    Box,
    {
      display: hiddenOnScreen ? "none" : optimizeResponsiveArray([
        hiddenOnMobile ? "none" : display,
        hiddenOnTablet ? "none" : display,
        hiddenOnDesktop ? "none" : display,
        hiddenOnWide ? "none" : display
      ]),
      className: hiddenOnPrint$1 ? hiddenOnPrint : void 0,
      component: component || (inline2 ? "span" : "div"),
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      children
    }
  );
};
const alignToFlexAlignLookup = {
  left: "flexStart",
  center: "center",
  right: "flexEnd"
};
const alignToFlexAlign = (align) => align ? mapResponsiveValue(align, (value) => alignToFlexAlignLookup[value]) : void 0;
const alignYToFlexAlignLookup = {
  top: "flexStart",
  center: "center",
  bottom: "flexEnd"
};
const alignYToFlexAlign = (alignY2) => alignY2 ? mapResponsiveValue(alignY2, (value) => alignYToFlexAlignLookup[value]) : void 0;
const resolveResponsiveProp = (value, mobileAtoms, tabletAtoms, desktopAtoms, wideAtoms) => {
  if (typeof value === "string" || typeof value === "number") {
    return mobileAtoms[value];
  }
  const normalized = normalizeResponsiveValue(value);
  const [mobile, tablet, desktop, wide] = optimizeResponsiveArray([
    normalized.mobile ?? null,
    normalized.tablet ?? null,
    normalized.desktop ?? null,
    normalized.wide ?? null
  ]);
  const mobileAtom = mobileAtoms[mobile];
  const tabletAtom = tabletAtoms[tablet];
  const desktopAtom = desktopAtoms[desktop];
  const wideAtom = wideAtoms[wide];
  return clsx(mobileAtom, tabletAtom, desktopAtom, wideAtom);
};
const directionStyles = {
  top,
  right,
  bottom,
  left
};
const negativeMargin = (direction, space) => space ? clsx([
  direction === "top" || direction === "bottom" ? preventCollapsePseudo[direction] : void 0,
  resolveResponsiveProp(
    space,
    directionStyles[direction].mobile,
    directionStyles[direction].tablet,
    directionStyles[direction].desktop,
    directionStyles[direction].wide
  )
]) : null;
const alignToDisplay = {
  left: "block",
  center: "flex",
  right: "flex"
};
const validStackComponents = ["div", "span", "ol", "ul"];
const useStackItem = ({ align, space, component }) => ({
  paddingTop: space,
  display: component === "span" ? "block" : void 0,
  // If we're aligned left across all screen sizes,
  // there's actually no alignment work to do.
  ...align === "left" ? null : {
    display: mapResponsiveValue(align, (value) => alignToDisplay[value]),
    flexDirection: "column",
    alignItems: alignToFlexAlign(align)
  }
});
const extractHiddenPropsFromChild = (child) => child && typeof child === "object" && "type" in child && child.type === Hidden ? child.props : null;
const resolveHiddenProps = ({ screen, above, below }) => screen ? [true, true, true, true] : resolveResponsiveRangeProps({
  above,
  below
});
const calculateHiddenStackItemProps = (stackItemProps, [hiddenOnMobile, hiddenOnTablet, hiddenOnDesktop, hiddenOnWide]) => {
  const normalizedValue = normalizeResponsiveValue(
    stackItemProps.display !== void 0 ? stackItemProps.display : "block"
  );
  const {
    mobile: displayMobile = "block",
    tablet: displayTablet = displayMobile,
    desktop: displayDesktop = displayTablet,
    wide: displayWide = displayDesktop
  } = normalizedValue;
  return {
    ...stackItemProps,
    display: optimizeResponsiveArray([
      hiddenOnMobile ? "none" : displayMobile,
      hiddenOnTablet ? "none" : displayTablet,
      hiddenOnDesktop ? "none" : displayDesktop,
      hiddenOnWide ? "none" : displayWide
    ])
  };
};
const Stack = ({
  component = "div",
  children,
  space = "none",
  align = "left",
  dividers = false,
  data,
  ...restProps
}) => {
  assert(
    validStackComponents.includes(component),
    `Invalid Stack component: '${component}'. Should be one of [${validStackComponents.map((c) => `'${c}'`).join(", ")}]`
  );
  const stackItemProps = useStackItem({ space, align, component });
  const stackItems = flattenChildren(children);
  const isList = component === "ol" || component === "ul";
  const stackItemComponent = isList ? "li" : component;
  let firstItemOnMobile = null;
  let firstItemOnTablet = null;
  let firstItemOnDesktop = null;
  let firstItemOnWide = null;
  return /* @__PURE__ */ jsx(
    Box,
    {
      component,
      display: component === "span" ? "block" : void 0,
      className: negativeMargin("top", space),
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      children: Children.map(stackItems, (child, index) => {
        assert(
          !(typeof child === "object" && child.type === Hidden && child.props.inline !== void 0),
          'The "inline" prop is invalid on Hidden elements within a Stack'
        );
        const hiddenProps = extractHiddenPropsFromChild(child);
        const hidden = hiddenProps ? resolveHiddenProps(hiddenProps) : [false, false, false, false];
        const [hiddenOnMobile, hiddenOnTablet, hiddenOnDesktop, hiddenOnWide] = hidden;
        const responsivelyHidden = hiddenOnMobile || hiddenOnTablet || hiddenOnDesktop || hiddenOnWide;
        if (firstItemOnMobile === null && !hiddenOnMobile) {
          firstItemOnMobile = index;
        }
        if (firstItemOnTablet === null && !hiddenOnTablet) {
          firstItemOnTablet = index;
        }
        if (firstItemOnDesktop === null && !hiddenOnDesktop) {
          firstItemOnDesktop = index;
        }
        if (firstItemOnWide === null && !hiddenOnWide) {
          firstItemOnWide = index;
        }
        return /* @__PURE__ */ jsxs(
          Box,
          {
            component: stackItemComponent,
            className: [
              hiddenProps && hiddenProps.print ? hiddenOnPrint : null
            ],
            ...responsivelyHidden ? calculateHiddenStackItemProps(stackItemProps, hidden) : stackItemProps,
            children: [
              dividers && index > 0 ? /* @__PURE__ */ jsx(
                Box,
                {
                  component: "span",
                  width: "full",
                  paddingBottom: space,
                  display: optimizeResponsiveArray([
                    index === firstItemOnMobile ? "none" : "block",
                    index === firstItemOnTablet ? "none" : "block",
                    index === firstItemOnDesktop ? "none" : "block",
                    index === firstItemOnWide ? "none" : "block"
                  ]),
                  children: typeof dividers === "string" ? /* @__PURE__ */ jsx(Divider, { weight: dividers }) : /* @__PURE__ */ jsx(Divider, {})
                }
              ) : null,
              hiddenProps ? hiddenProps.children : child
            ]
          }
        );
      })
    }
  );
};
const DefaultTextPropsContext = createContext({
  tone: void 0,
  weight: void 0,
  size: void 0
});
const DefaultTextPropsProvider = ({
  size: size2,
  weight,
  tone: tone2,
  children
}) => {
  const defaultTextProps = useMemo(
    () => ({
      size: size2,
      weight,
      tone: tone2
    }),
    [size2, weight, tone2]
  );
  return /* @__PURE__ */ jsx(DefaultTextPropsContext.Provider, { value: defaultTextProps, children });
};
const useDefaultTextProps = ({
  size: sizeProp,
  weight: weightProp,
  tone: toneProp
}) => {
  const { size: size2, weight, tone: tone2 } = useContext(DefaultTextPropsContext);
  return {
    size: sizeProp ?? size2 ?? "standard",
    weight: weightProp ?? weight ?? "regular",
    tone: toneProp ?? tone2 ?? "neutral"
  };
};
function textStyles({
  weight = "regular",
  size: size2 = "standard",
  tone: tone$1 = "neutral",
  baseline
}) {
  return [
    fontFamily,
    fontWeight[weight],
    tone[tone$1],
    (baseline ? textSizeTrimmed : textSizeUntrimmed)[size2]
  ];
}
const MaxLines = ({
  children,
  lines
}) => /* @__PURE__ */ jsx(
  Box,
  {
    component: "span",
    className: [base$2, lines > 1 ? multiLine : void 0],
    style: lines > 1 ? assignInlineVars({ [lineLimit]: String(lines) }) : void 0,
    children
  }
);
const Typography = ({
  id,
  component = "span",
  className,
  align,
  truncate = false,
  maxLines,
  icon,
  data,
  children,
  ...restProps
}) => {
  const lines = truncate ? 1 : maxLines;
  const contents = typeof lines === "number" ? /* @__PURE__ */ jsx(MaxLines, { lines, children }) : children;
  if (process.env.NODE_ENV !== "production") {
    if (truncate) {
      console.warn(
        dedent`
          The "truncate" prop has been deprecated and will be removed in a future version. Use "maxLines" instead.
             <Text
            %c-   truncate
            %c+   maxLines={1}
             %c/>
        `,
        "color: red",
        "color: green",
        "color: inherit"
      );
    }
  }
  return /* @__PURE__ */ jsx(
    Box,
    {
      id,
      display: "block",
      component,
      textAlign: align,
      className,
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      children: icon ? /* @__PURE__ */ jsxs(
        Box,
        {
          component: "span",
          display: "flex",
          justifyContent: alignToFlexAlign(align),
          children: [
            /* @__PURE__ */ jsx(
              Box,
              {
                component: "span",
                display: "block",
                paddingRight: "xsmall",
                flexGrow: 0,
                flexShrink: 0,
                minWidth: 0,
                textAlign: align,
                children: icon
              }
            ),
            /* @__PURE__ */ jsx(Box, { component: "span", display: "block", minWidth: 0, children: contents })
          ]
        }
      ) : contents
    }
  );
};
const Text = ({
  size: sizeProp,
  tone: toneProp,
  weight: weightProp,
  baseline = true,
  ...typographyProps
}) => {
  assert(
    !useContext(TextContext),
    "Text components should not be nested within each other"
  );
  const { size: size2, weight, tone: tone2 } = useDefaultTextProps({
    size: sizeProp,
    weight: weightProp,
    tone: toneProp
  });
  const textStylingProps = useMemo(
    () => ({
      tone: tone2,
      size: size2,
      weight,
      baseline
    }),
    [tone2, size2, weight, baseline]
  );
  return /* @__PURE__ */ jsx(TextContext.Provider, { value: textStylingProps, children: /* @__PURE__ */ jsx(
    Typography,
    {
      ...typographyProps,
      className: textStyles(textStylingProps)
    }
  ) });
};
function invertAlignment(alignment) {
  if (alignment === "flexStart") {
    return "flexEnd";
  }
  if (alignment === "flexEnd") {
    return "flexStart";
  }
  return alignment;
}
function resolveCollapsibleAlignmentProps({
  align,
  alignY: alignY2,
  collapseBelow,
  reverse
}) {
  const [collapseMobile, collapseTablet, collapseDesktop] = resolveResponsiveRangeProps({
    below: collapseBelow
  });
  const rowReverseTablet = collapseMobile && reverse;
  const rowReverseDesktop = (collapseMobile || collapseTablet) && reverse;
  const rowReverseWide = (collapseMobile || collapseTablet || collapseDesktop) && reverse;
  const normalizedAlign = normalizeResponsiveValue(
    alignToFlexAlign(align) || "flexStart"
  );
  const {
    mobile: justifyContentMobile = "flexStart",
    tablet: justifyContentTablet = justifyContentMobile,
    desktop: justifyContentDesktop = justifyContentTablet,
    wide: justifyContentWide = justifyContentDesktop
  } = normalizedAlign;
  return {
    collapseMobile,
    collapseTablet,
    collapseDesktop,
    orderChildren: (children) => {
      const childrenArray = Children.toArray(children);
      return !collapseMobile && !collapseTablet && reverse ? childrenArray.reverse() : childrenArray;
    },
    collapsibleAlignmentProps: {
      display: optimizeResponsiveArray([
        collapseMobile ? "block" : "flex",
        collapseTablet ? "block" : "flex",
        collapseDesktop ? "block" : "flex",
        "flex"
      ]),
      flexDirection: optimizeResponsiveArray([
        collapseMobile ? "column" : "row",
        // eslint-disable-next-line no-nested-ternary
        collapseTablet ? "column" : rowReverseTablet ? "rowReverse" : "row",
        // eslint-disable-next-line no-nested-ternary
        collapseDesktop ? "column" : rowReverseDesktop ? "rowReverse" : "row",
        rowReverseWide ? "rowReverse" : "row"
      ]),
      justifyContent: align ? optimizeResponsiveArray([
        justifyContentMobile,
        rowReverseTablet ? invertAlignment(justifyContentTablet) : justifyContentTablet,
        rowReverseDesktop ? invertAlignment(justifyContentDesktop) : justifyContentDesktop,
        rowReverseWide ? invertAlignment(justifyContentWide) : justifyContentWide
      ]) : void 0,
      alignItems: alignY2 ? alignYToFlexAlign(alignY2) : void 0
    },
    collapsibleAlignmentChildProps: {
      display: optimizeResponsiveArray([
        collapseMobile && justifyContentMobile !== "flexStart" ? "flex" : "block",
        collapseTablet && justifyContentTablet !== "flexStart" ? "flex" : "block",
        collapseDesktop && justifyContentDesktop !== "flexStart" ? "flex" : "block",
        "block"
      ]),
      justifyContent: optimizeResponsiveArray([
        justifyContentMobile,
        justifyContentTablet,
        justifyContentDesktop,
        justifyContentWide
      ])
    }
  };
}
const validColumnsComponents = ["div", "span"];
const ColumnsContext = createContext({
  collapseMobile: false,
  collapseTablet: false,
  collapseDesktop: false,
  mobileSpace: "none",
  tabletSpace: "none",
  desktopSpace: "none",
  wideSpace: "none",
  collapsibleAlignmentChildProps: null,
  component: "div"
});
const Columns = ({
  children,
  collapseBelow,
  reverse = false,
  space = "none",
  align,
  alignY: alignY2,
  component = "div",
  data,
  ...restProps
}) => {
  assert(
    validColumnsComponents.includes(component),
    `Invalid Columns component: '${component}'. Should be one of [${validColumnsComponents.map((c) => `'${c}'`).join(", ")}]`
  );
  const normalizedSpace = normalizeResponsiveValue(space);
  const {
    mobile: mobileSpace = "none",
    tablet: tabletSpace = mobileSpace,
    desktop: desktopSpace = tabletSpace,
    wide: wideSpace = desktopSpace
  } = normalizedSpace;
  const {
    collapsibleAlignmentProps,
    collapsibleAlignmentChildProps,
    collapseMobile,
    collapseTablet,
    collapseDesktop,
    orderChildren
  } = resolveCollapsibleAlignmentProps({
    collapseBelow,
    align,
    alignY: alignY2,
    reverse
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      component,
      ...collapsibleAlignmentProps,
      className: negativeMargin("left", {
        mobile: collapseMobile ? "none" : mobileSpace,
        tablet: collapseTablet ? "none" : tabletSpace,
        desktop: collapseDesktop ? "none" : desktopSpace,
        wide: wideSpace
      }),
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsx(
        ColumnsContext.Provider,
        {
          value: {
            collapseMobile,
            collapseTablet,
            collapseDesktop,
            mobileSpace,
            tabletSpace,
            desktopSpace,
            wideSpace,
            collapsibleAlignmentChildProps,
            component
          },
          children: orderChildren(children)
        }
      )
    }
  );
};
const Column = ({
  children,
  data,
  width: width$1,
  ...restProps
}) => {
  const {
    collapseMobile,
    collapseTablet,
    collapseDesktop,
    mobileSpace,
    tabletSpace,
    desktopSpace,
    wideSpace,
    collapsibleAlignmentChildProps,
    component
  } = useContext(ColumnsContext);
  return /* @__PURE__ */ jsx(
    Box,
    {
      component,
      display: component === "span" ? "block" : void 0,
      minWidth: 0,
      width: width$1 !== "content" ? "full" : void 0,
      flexShrink: width$1 === "content" ? 0 : void 0,
      flexGrow: 1,
      className: [
        column,
        width$1 !== "content" ? width[width$1] : null
      ],
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsx(
        Box,
        {
          component,
          paddingLeft: optimizeResponsiveArray([
            collapseMobile ? "none" : mobileSpace,
            collapseTablet ? "none" : tabletSpace,
            collapseDesktop ? "none" : desktopSpace,
            wideSpace
          ]),
          paddingTop: collapseMobile || collapseTablet || collapseDesktop ? optimizeResponsiveArray([
            collapseMobile ? mobileSpace : "none",
            collapseTablet ? tabletSpace : "none",
            collapseDesktop ? desktopSpace : "none",
            "none"
          ]) : void 0,
          height: "full",
          ...collapsibleAlignmentChildProps,
          className: columnContent,
          children
        }
      )
    }
  );
};
const validInlineComponents = ["div", "span", "ol", "ul"];
const Inline = ({
  space = "none",
  align,
  alignY: alignY2,
  collapseBelow,
  reverse,
  component = "div",
  data,
  children,
  ...restProps
}) => {
  assert(
    validInlineComponents.includes(component),
    `Invalid Inline component: '${component}'. Should be one of [${validInlineComponents.map((c) => `'${c}'`).join(", ")}]`
  );
  const isList = component === "ol" || component === "ul";
  const inlineItemComponent = isList ? "li" : component;
  const {
    collapsibleAlignmentProps,
    collapsibleAlignmentChildProps,
    orderChildren
  } = resolveCollapsibleAlignmentProps({
    align,
    alignY: alignY2,
    collapseBelow,
    reverse
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: component === "span" ? component : void 0,
      display: component === "span" ? "block" : void 0,
      className: negativeMargin("top", space),
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsx(
        Box,
        {
          component,
          className: negativeMargin("left", space),
          flexWrap: "wrap",
          ...collapsibleAlignmentProps,
          children: Children.map(
            orderChildren(flattenChildren(children)),
            (child) => child !== null && child !== void 0 ? /* @__PURE__ */ jsx(
              Box,
              {
                component: inlineItemComponent,
                minWidth: 0,
                marginLeft: space,
                marginTop: space,
                ...collapsibleAlignmentChildProps,
                children: child
              }
            ) : null
          )
        }
      )
    }
  );
};
const iconInlineSize = ({
  alignY: alignY$1 = "uppercase",
  verticalCorrection = "none"
} = {}) => clsx(
  atoms({
    display: "inlineBlock",
    position: "relative"
  }),
  size,
  inlineCrop,
  inline,
  alignY[alignY$1][verticalCorrection]
);
const IconRenderer = ({ children }) => {
  const textContext = useContext(TextContext);
  const headingContext = useContext(HeadingContext);
  assert(
    Boolean(textContext || headingContext),
    `IconRenderer must be inside either a \`Text\` or \`Heading\` component.`
  );
  return children({ className: iconInlineSize() });
};
const iconSize = ({
  size: size$1 = "standard",
  crop = false
} = {}) => clsx(size, textSizeUntrimmed[size$1], {
  [cropToTextSize]: crop
});
const iconContainerSize = (size2 = "standard") => clsx(blockWidths[size2], lineHeightContainer[size2]);
const defaultVerticalCorrection = {
  uppercase: "none",
  lowercase: "none"
};
const useIcon = ({ size: size2, tone: tone$1, alignY: alignY2, data, title, titleId, ...restProps }, { verticalCorrection = defaultVerticalCorrection } = {}) => {
  const textContext = useContext(TextContext);
  const headingContext = useContext(HeadingContext);
  const resolvedTone = tone[tone$1 || (textContext == null ? void 0 : textContext.tone) || "neutral"];
  const toneClass = tone$1 || !headingContext && !(textContext == null ? void 0 : textContext.tone) ? resolvedTone : void 0;
  const isInline = Boolean(textContext || headingContext);
  const a11yProps = title ? { title, titleId, role: "img" } : { "aria-hidden": true };
  assert(
    !(size2 && isInline),
    `Specifying a custom \`size\` for an \`Icon\` inside the context of a \`<${textContext ? "Text" : "Heading"}>\` component is invalid. See the documentation for correct usage: https://seek-oss.github.io/braid-design-system/components/${textContext ? "Text" : "Heading"}`
  );
  assert(
    !(alignY2 && !isInline),
    `Specifying \`alignY\` for an \`Icon\` outside of a text component is invalid.`
  );
  if (size2 === "fill") {
    return {
      width: "full",
      height: "full",
      display: "block",
      className: toneClass,
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      ...a11yProps
    };
  }
  return {
    className: [
      toneClass,
      isInline ? [
        iconInlineSize({
          alignY: alignY2 || "uppercase",
          verticalCorrection: verticalCorrection[alignY2 || "uppercase"]
        })
      ] : [
        atoms({
          display: "block"
        }),
        iconContainerSize(size2)
      ]
    ],
    ...buildDataAttributes({ data, validateRestProps: restProps }),
    ...a11yProps
  };
};
const IconClearSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsx("path", { d: "m13.4 12 5.3-5.3c.4-.4.4-1 0-1.4s-1-.4-1.4 0L12 10.6 6.7 5.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l5.3 5.3-5.3 5.3c-.4.4-.4 1 0 1.4.2.2.4.3.7.3s.5-.1.7-.3l5.3-5.3 5.3 5.3c.2.2.5.3.7.3s.5-.1.7-.3c.4-.4.4-1 0-1.4L13.4 12z" })
    ]
  }
);
const IconClear = (props) => {
  const iconProps = useIcon(props);
  return /* @__PURE__ */ jsx(Box, { component: IconClearSvg, ...iconProps });
};
const IconCriticalSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsx("path", { d: "M12 1C5.9 1 1 5.9 1 12s4.9 11 11 11 11-4.9 11-11S18.1 1 12 1zm0 20c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9z" }),
      /* @__PURE__ */ jsx("circle", { cx: 12, cy: 17, r: 1 }),
      /* @__PURE__ */ jsx("path", { d: "M12 14c.6 0 1-.4 1-1V8c0-.6-.4-1-1-1s-1 .4-1 1v5c0 .6.4 1 1 1z" })
    ]
  }
);
const IconCritical = (props) => {
  const iconProps = useIcon(props);
  return /* @__PURE__ */ jsx(Box, { component: IconCriticalSvg, ...iconProps });
};
const IconPositiveSvg = ({ title, titleId, ...props }) => /* @__PURE__ */ jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    xmlSpace: "preserve",
    focusable: "false",
    fill: "currentColor",
    width: 16,
    height: 16,
    "aria-labelledby": titleId,
    ...props,
    children: [
      title ? /* @__PURE__ */ jsx("title", { id: titleId, children: title }) : null,
      /* @__PURE__ */ jsx("path", { d: "M12 1C5.9 1 1 5.9 1 12s4.9 11 11 11 11-4.9 11-11S18.1 1 12 1zm0 20c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9z" }),
      /* @__PURE__ */ jsx("path", { d: "M15.3 9.3 11 13.6l-1.3-1.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l2 2c.2.2.5.3.7.3s.5-.1.7-.3l5-5c.4-.4.4-1 0-1.4s-1-.4-1.4 0z" })
    ]
  }
);
const IconPositive = (props) => {
  const iconProps = useIcon(props);
  return /* @__PURE__ */ jsx(Box, { component: IconPositiveSvg, ...iconProps });
};
function virtualTouchable({ xAxis } = { xAxis: true }) {
  return !xAxis ? [virtualTouchable$1, yAxisOnly] : virtualTouchable$1;
}
const Overlay = ({
  component,
  zIndex,
  background,
  borderRadius: borderRadius2,
  boxShadow,
  transition,
  visible = false,
  onlyVisibleForKeyboardNavigation = false,
  className,
  children
}) => /* @__PURE__ */ jsx(
  Box,
  {
    component,
    position: "absolute",
    zIndex,
    pointerEvents: "none",
    background,
    borderRadius: borderRadius2,
    boxShadow,
    transition,
    inset: 0,
    opacity: !visible ? 0 : void 0,
    className: [
      onlyVisibleForKeyboardNavigation ? hideFocusRingsClassName : null,
      className
    ],
    children
  }
);
const ActionsContext = createContext(null);
const boxShadowForVariant = {
  default: "borderField",
  disabled: "borderNeutralLight",
  focus: "outlineFocus",
  formAccent: "borderFormAccent",
  critical: "borderCritical"
};
const FieldOverlay = ({ variant, ...restProps }) => /* @__PURE__ */ jsx(
  Overlay,
  {
    component: "span",
    borderRadius: "standard",
    boxShadow: boxShadowForVariant[variant],
    transition: "fast",
    ...restProps
  }
);
const AvoidWidowIcon = ({
  children,
  iconPosition,
  space = "xxsmall",
  className
}) => /* @__PURE__ */ jsxs(
  Box,
  {
    component: "span",
    paddingRight: iconPosition === "leading" ? space : void 0,
    paddingLeft: iconPosition === "trailing" ? space : void 0,
    className: [nowrap, className],
    "aria-hidden": true,
    children: [
      iconPosition === "leading" ? children : void 0,
      "⁠",
      iconPosition === "trailing" ? children : void 0
    ]
  }
);
const validBleedComponents = ["div", "span"];
const Bleed = ({
  space,
  horizontal,
  vertical,
  top: top2,
  bottom: bottom2,
  left: left2,
  right: right2,
  children,
  component = "div",
  data,
  ...restProps
}) => /* @__PURE__ */ jsx(
  Box,
  {
    component,
    display: component === "span" ? "block" : void 0,
    className: [
      negativeMargin("top", top2 || vertical || space),
      negativeMargin("bottom", bottom2 || vertical || space),
      negativeMargin("left", left2 || horizontal || space),
      negativeMargin("right", right2 || horizontal || space)
    ],
    ...buildDataAttributes({ data, validateRestProps: restProps }),
    children: /* @__PURE__ */ jsx(
      Box,
      {
        component,
        display: component === "span" ? "block" : void 0,
        position: "relative",
        children
      }
    )
  }
);
const buttonVariants = [
  "solid",
  "ghost",
  "soft",
  "transparent"
];
const buttonTones = [
  "formAccent",
  "brandAccent",
  "critical",
  "neutral"
];
const variants = {
  solid: {
    formAccent: {
      textTone: void 0,
      background: "formAccent",
      backgroundHover: "formAccentHover",
      backgroundActive: "formAccentActive",
      boxShadow: void 0
    },
    brandAccent: {
      textTone: void 0,
      background: "brandAccent",
      backgroundHover: "brandAccentHover",
      backgroundActive: "brandAccentActive",
      boxShadow: void 0
    },
    critical: {
      textTone: void 0,
      background: "critical",
      backgroundHover: "criticalHover",
      backgroundActive: "criticalActive",
      boxShadow: void 0
    },
    neutral: {
      textTone: void 0,
      background: { light: "neutral", dark: "neutralSoft" },
      backgroundHover: { light: "neutralSoftHover", dark: "neutralHover" },
      backgroundActive: { light: "neutralSoftActive", dark: "neutralActive" },
      boxShadow: void 0
    }
  },
  soft: {
    formAccent: {
      textTone: "formAccent",
      background: { light: "formAccentSoft", dark: "customDark" },
      backgroundHover: "formAccentSoftHover",
      backgroundActive: "formAccentSoftActive",
      boxShadow: void 0
    },
    brandAccent: {
      textTone: "brandAccent",
      background: { light: "brandAccentSoft", dark: "customDark" },
      backgroundHover: "brandAccentSoftHover",
      backgroundActive: "brandAccentSoftActive",
      boxShadow: void 0
    },
    critical: {
      textTone: "critical",
      background: { light: "criticalSoft", dark: "customDark" },
      backgroundHover: "criticalSoftHover",
      backgroundActive: "criticalSoftActive",
      boxShadow: void 0
    },
    neutral: {
      textTone: "neutral",
      background: { light: "neutralSoft", dark: "customDark" },
      backgroundHover: "neutralSoftHover",
      backgroundActive: "neutralSoftActive",
      boxShadow: void 0
    }
  },
  transparent: {
    formAccent: {
      textTone: "formAccent",
      background: void 0,
      backgroundHover: "formAccentSoftHover",
      backgroundActive: "formAccentSoftActive",
      boxShadow: void 0
    },
    brandAccent: {
      textTone: "brandAccent",
      background: void 0,
      backgroundHover: "brandAccentSoftHover",
      backgroundActive: "brandAccentSoftActive",
      boxShadow: void 0
    },
    critical: {
      textTone: "critical",
      background: void 0,
      backgroundHover: "criticalSoftHover",
      backgroundActive: "criticalSoftActive",
      boxShadow: void 0
    },
    neutral: {
      textTone: "neutral",
      background: void 0,
      backgroundHover: "neutralSoftHover",
      backgroundActive: "neutralSoftActive",
      boxShadow: void 0
    }
  },
  ghost: {
    formAccent: {
      textTone: "formAccent",
      background: void 0,
      backgroundHover: "formAccentSoftHover",
      backgroundActive: "formAccentSoftActive",
      boxShadow: "borderFormAccent"
    },
    brandAccent: {
      textTone: "brandAccent",
      background: void 0,
      backgroundHover: "brandAccentSoftHover",
      backgroundActive: "brandAccentSoftActive",
      boxShadow: "borderBrandAccent"
    },
    critical: {
      textTone: "critical",
      background: void 0,
      backgroundHover: "criticalSoftHover",
      backgroundActive: "criticalSoftActive",
      boxShadow: "borderCritical"
    },
    neutral: {
      textTone: "neutral",
      background: void 0,
      backgroundHover: "neutralSoftHover",
      backgroundActive: "neutralSoftActive",
      boxShadow: "borderNeutral"
    }
  }
};
const ButtonLoader = () => /* @__PURE__ */ jsxs(Box, { "aria-hidden": true, component: "span", display: "inlineBlock", children: [
  /* @__PURE__ */ jsx(Box, { component: "span", className: loadingDot, children: "." }),
  /* @__PURE__ */ jsx(Box, { component: "span", className: loadingDot, children: "." }),
  /* @__PURE__ */ jsx(Box, { component: "span", className: loadingDot, children: "." })
] });
const transparentPaddingX = "small";
const buttonRadius = "standard";
const resolveToneAndVariant = ({
  variant: variantProp,
  tone: toneProp,
  legacy
}) => {
  if (legacy) {
    return {
      variant: variantProp ?? "solid",
      tone: toneProp ?? "formAccent"
    };
  }
  const fallbackVariant = toneProp ? "solid" : "ghost";
  return {
    variant: variantProp ?? fallbackVariant,
    tone: toneProp ?? "neutral"
  };
};
const ButtonOverlays = ({
  variant: variantProp,
  tone: toneProp,
  keyboardFocusable = true,
  forceActive: forceActive$1 = false,
  radius = buttonRadius
}) => {
  const { variant, tone: tone2 } = resolveToneAndVariant({
    variant: variantProp,
    tone: toneProp,
    legacy: useBraidTheme().legacy
  });
  const stylesForVariant = variants[variant][tone2];
  const colorContrast = useColorContrast();
  const lightness = useBackgroundLightness();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    keyboardFocusable ? /* @__PURE__ */ jsx(
      FieldOverlay,
      {
        borderRadius: radius,
        variant: "focus",
        onlyVisibleForKeyboardNavigation: true,
        className: focusOverlay
      }
    ) : null,
    /* @__PURE__ */ jsx(
      FieldOverlay,
      {
        borderRadius: radius,
        background: stylesForVariant.backgroundHover && typeof stylesForVariant.backgroundHover !== "string" ? colorContrast(stylesForVariant.backgroundHover) : stylesForVariant.backgroundHover,
        className: [
          hoverOverlay,
          variant !== "solid" && lightness.lightMode === "dark" ? invertedBackgroundsLightMode.hover : null,
          variant !== "solid" && lightness.darkMode === "dark" ? invertedBackgroundsDarkMode.hover : null
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      FieldOverlay,
      {
        borderRadius: radius,
        background: stylesForVariant.backgroundActive && typeof stylesForVariant.backgroundActive !== "string" ? colorContrast(stylesForVariant.backgroundActive) : stylesForVariant.backgroundActive,
        className: [
          forceActive$1 ? forceActive : void 0,
          activeOverlay,
          variant !== "solid" && lightness.lightMode === "dark" ? invertedBackgroundsLightMode.active : null,
          variant !== "solid" && lightness.darkMode === "dark" ? invertedBackgroundsDarkMode.active : null
        ]
      }
    ),
    stylesForVariant.boxShadow ? /* @__PURE__ */ jsx(
      Box,
      {
        component: "span",
        boxShadow: stylesForVariant.boxShadow,
        borderRadius: radius,
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    ) : null
  ] });
};
const ButtonText = ({
  children,
  loading,
  size: sizeProp,
  icon,
  iconPosition = "leading",
  variant: variantProp,
  tone: toneProp,
  bleed
}) => {
  const { variant, tone: tone2 } = resolveToneAndVariant({
    variant: variantProp,
    tone: toneProp,
    legacy: useBraidTheme().legacy
  });
  const lightness = useBackgroundLightness();
  const actionsContext = useContext(ActionsContext);
  const isLegacyTheme = useBraidTheme().legacy;
  const size2 = sizeProp ?? (actionsContext == null ? void 0 : actionsContext.size) ?? "standard";
  const stylesForVariant = variants[variant][tone2];
  const shouldReducePaddingX = size2 === "small" || variant === "transparent";
  const labelPaddingXForTheme = isLegacyTheme ? "medium" : "gutter";
  const labelPaddingX = shouldReducePaddingX ? transparentPaddingX : labelPaddingXForTheme;
  assert(
    !icon || icon.props.size === void 0 && icon.props.tone === void 0,
    "Icons cannot set the 'size' or 'tone' prop when passed to a Button component"
  );
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "span",
      position: "relative",
      display: "flex",
      justifyContent: "center",
      flexWrap: "wrap",
      overflow: "hidden",
      pointerEvents: "none",
      paddingX: labelPaddingX,
      className: padToMinHeight,
      background: tone2 === "neutral" && variant !== "solid" ? {
        lightMode: lightness.lightMode === "light" ? "customLight" : "customDark",
        darkMode: lightness.darkMode === "light" ? "customLight" : "customDark"
      } : void 0,
      children: /* @__PURE__ */ jsxs(
        Text,
        {
          tone: stylesForVariant.textTone,
          weight: "medium",
          align: "center",
          size: size2,
          children: [
            icon && iconPosition === "leading" ? /* @__PURE__ */ jsx(
              AvoidWidowIcon,
              {
                iconPosition,
                space: "xsmall",
                className: shouldReducePaddingX || bleed ? null : negativeMargin("left", "xxsmall"),
                children: icon
              }
            ) : null,
            children,
            loading ? /* @__PURE__ */ jsx(ButtonLoader, {}) : null,
            !loading && icon && iconPosition === "trailing" ? /* @__PURE__ */ jsx(
              AvoidWidowIcon,
              {
                iconPosition,
                space: "xsmall",
                className: shouldReducePaddingX || bleed ? null : negativeMargin("right", "xxsmall"),
                children: icon
              }
            ) : null
          ]
        }
      )
    }
  );
};
const useButtonStyles = ({
  variant: variantProp,
  size: sizeProp,
  tone: toneProp,
  loading,
  radius = buttonRadius,
  bleed
}) => {
  const { variant, tone: tone2 } = resolveToneAndVariant({
    variant: variantProp,
    tone: toneProp,
    legacy: useBraidTheme().legacy
  });
  const actionsContext = useContext(ActionsContext);
  const size2 = sizeProp ?? (actionsContext == null ? void 0 : actionsContext.size) ?? "standard";
  const stylesForVariant = variants[variant][tone2];
  const colorConstrast = useColorContrast();
  const lightness = useBackgroundLightness();
  return {
    borderRadius: radius,
    width: "full",
    position: "relative",
    display: "block",
    transform: { active: "touchable" },
    transition: "touchable",
    outline: "none",
    textAlign: "center",
    userSelect: "none",
    cursor: !loading ? "pointer" : void 0,
    background: stylesForVariant.background && typeof stylesForVariant.background !== "string" ? colorConstrast(stylesForVariant.background) : stylesForVariant.background,
    className: [
      variant === "soft" && lightness.lightMode === "dark" ? invertedBackgroundsLightMode.soft : null,
      variant === "soft" && lightness.darkMode === "dark" ? invertedBackgroundsDarkMode.soft : null,
      root,
      size2 === "small" ? virtualTouchable({ xAxis: false }) : null,
      size2 === "standard" ? standard : small,
      bleed ? bleedVerticallyToCapHeight : null
    ]
  };
};
const ButtonContainer = ({
  children,
  bleed,
  variant = "solid"
}) => bleed && variant === "transparent" ? /* @__PURE__ */ jsx(Bleed, { horizontal: transparentPaddingX, children }) : /* @__PURE__ */ jsx(Fragment, { children });
const Button = forwardRef(
  ({
    onClick,
    children,
    size: size2,
    tone: tone2,
    icon,
    iconPosition,
    bleedY,
    bleed,
    variant,
    loading,
    type = "button",
    id,
    tabIndex,
    onKeyUp,
    onKeyDown,
    "aria-haspopup": ariaHasPopup,
    "aria-controls": ariaControls,
    "aria-expanded": ariaExpanded,
    "aria-describedby": ariaDescribedBy,
    "aria-label": ariaLabel,
    data,
    ...restProps
  }, ref) => {
    if (process.env.NODE_ENV !== "production") {
      if (typeof bleedY !== "undefined") {
        console.warn(
          dedent`
            The "bleedY" prop has been deprecated and will be removed in a future version. Use "bleed" instead.
               <Button
              %c-   bleedY
              %c+   bleed
               %c/>
          `,
          "color: red",
          "color: green",
          "color: inherit"
        );
      }
    }
    return /* @__PURE__ */ jsx(ButtonContainer, { bleed, variant, children: /* @__PURE__ */ jsxs(
      Box,
      {
        component: "button",
        ref,
        id,
        type,
        tabIndex,
        onKeyUp,
        onKeyDown,
        "aria-haspopup": ariaHasPopup,
        "aria-controls": ariaControls,
        "aria-expanded": ariaExpanded,
        "aria-describedby": ariaDescribedBy,
        "aria-label": ariaLabel,
        onClick,
        disabled: loading,
        ...buildDataAttributes({ data, validateRestProps: restProps }),
        ...useButtonStyles({
          variant,
          tone: tone2,
          size: size2,
          bleed: bleed || bleedY,
          loading
        }),
        children: [
          /* @__PURE__ */ jsx(ButtonOverlays, { variant, tone: tone2 }),
          /* @__PURE__ */ jsx(
            ButtonText,
            {
              variant,
              tone: tone2,
              size: size2,
              loading,
              icon,
              iconPosition,
              bleed,
              children
            }
          )
        ]
      }
    ) });
  }
);
Button.displayName = "Button";
const StaticTooltipContext = createContext(false);
const TooltipTextDefaultsProvider = ({
  children
}) => {
  const themeName = useThemeName();
  return /* @__PURE__ */ jsx(
    DefaultTextPropsProvider,
    {
      size: themeName === "docs" ? "small" : void 0,
      weight: "medium",
      children
    }
  );
};
const borderRadius$1 = "large";
const TooltipContent = ({
  children,
  opacity,
  arrowProps
}) => /* @__PURE__ */ jsx(
  Box,
  {
    display: "flex",
    position: "relative",
    transition: "fast",
    opacity: opacity === 0 ? 0 : void 0,
    className: opacity === 0 ? verticalOffsetBeforeEntrance : translateZ0,
    children: /* @__PURE__ */ jsx(
      Box,
      {
        boxShadow: "large",
        background: "neutral",
        borderRadius: borderRadius$1,
        padding: "small",
        className: [maxWidth, translateZ0],
        children: /* @__PURE__ */ jsxs(TooltipTextDefaultsProvider, { children: [
          /* @__PURE__ */ jsx(Box, { position: "relative", zIndex: 1, children }),
          /* @__PURE__ */ jsx(
            Box,
            {
              ...arrowProps,
              borderRadius: borderRadius$1,
              background: "neutral",
              className: arrow
            }
          )
        ] })
      }
    )
  }
);
const validPlacements = ["top", "bottom"];
const normaliseRect = (domRect) => ({
  top: Math.round((domRect == null ? void 0 : domRect.top) || 0),
  left: Math.round((domRect == null ? void 0 : domRect.left) || 0),
  height: Math.round((domRect == null ? void 0 : domRect.height) || 0),
  width: Math.round((domRect == null ? void 0 : domRect.width) || 0)
});
const defaultRect = normaliseRect();
const doesBoundingBoxNeedUpdating = (element, previousRect) => {
  const currentRect = normaliseRect(element == null ? void 0 : element.getBoundingClientRect());
  return JSON.stringify(currentRect) !== JSON.stringify(previousRect);
};
const TooltipRenderer = ({
  id,
  tooltip,
  placement = "top",
  children
}) => {
  assert(
    validPlacements.includes(placement),
    `The 'placement' prop must be one of the following: ${validPlacements.join(
      ", "
    )}`
  );
  const isStatic = useContext(StaticTooltipContext);
  const [controlledVisible, setControlledVisible] = useState(false);
  const [opacity, setOpacity] = useState(0);
  const { grid, space } = useSpace();
  const triggerBoundingBoxRef = useRef(defaultRect);
  const tooltipBoundingRectRef = useRef(defaultRect);
  const {
    visible,
    getTooltipProps,
    setTooltipRef,
    tooltipRef,
    setTriggerRef,
    triggerRef,
    getArrowProps,
    update
  } = usePopperTooltip(
    {
      placement,
      trigger: [isMobile() ? "click" : "hover", "focus"],
      visible: isStatic || controlledVisible,
      onVisibleChange: (newState) => {
        triggerBoundingBoxRef.current = normaliseRect(
          triggerRef == null ? void 0 : triggerRef.getBoundingClientRect()
        );
        tooltipBoundingRectRef.current = normaliseRect(
          tooltipRef == null ? void 0 : tooltipRef.getBoundingClientRect()
        );
        setControlledVisible(newState);
      }
    },
    {
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            padding: space.xsmall * grid
          }
        },
        {
          name: "offset",
          options: {
            offset: [0, space.small * grid]
          }
        },
        {
          name: "arrow",
          options: {
            padding: space.xsmall * grid
          }
        },
        ...isStatic ? [
          {
            name: "flip",
            options: {
              fallbackPlacements: []
            }
          }
        ] : []
      ]
    }
  );
  useLayoutEffect(() => {
    if (controlledVisible && update && (doesBoundingBoxNeedUpdating(triggerRef, triggerBoundingBoxRef.current) || doesBoundingBoxNeedUpdating(tooltipRef, tooltipBoundingRectRef.current))) {
      triggerBoundingBoxRef.current = normaliseRect(
        triggerRef == null ? void 0 : triggerRef.getBoundingClientRect()
      );
      tooltipBoundingRectRef.current = normaliseRect(
        tooltipRef == null ? void 0 : tooltipRef.getBoundingClientRect()
      );
      update();
    }
  });
  useEffect(() => {
    if (visible) {
      const handleKeyDown = ({ key }) => {
        if (key === "Escape") {
          setControlledVisible(false);
        }
      };
      const handleScroll = () => {
        setControlledVisible(false);
      };
      const scrollHandlerOptions = {
        capture: true,
        passive: true
      };
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("scroll", handleScroll, scrollHandlerOptions);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener(
          "scroll",
          handleScroll,
          scrollHandlerOptions
        );
      };
    }
  }, [visible]);
  useEffect(() => {
    if (!triggerRef) {
      return;
    }
    if (visible) {
      const handleFocusIn = (event) => {
        if (event.currentTarget !== triggerRef) {
          setControlledVisible(false);
        }
      };
      document.addEventListener("focusin", handleFocusIn);
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
      };
    }
  }, [triggerRef, visible]);
  assert(
    useEffect(() => {
      if (tooltipRef) {
        assert(
          tooltipRef.querySelectorAll("button, input, select, textarea, a").length === 0,
          "For accessibility reasons, tooltips must not contain interactive elements"
        );
      }
    }, [tooltipRef]) === void 0
  );
  useEffect(() => {
    if (!tooltipRef || !visible) {
      return setOpacity(0);
    }
    const timeout = setTimeout(() => setOpacity(100), isMobile() ? 0 : 250);
    return () => clearTimeout(timeout);
  }, [tooltipRef, visible]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    children({
      triggerProps: {
        tabIndex: 0,
        ref: setTriggerRef,
        "aria-describedby": id
      }
    }),
    triggerRef && /* @__PURE__ */ jsx(BraidPortal, { children: /* @__PURE__ */ jsx(
      "div",
      {
        id,
        role: "tooltip",
        hidden: !visible ? true : void 0,
        className: atoms({
          reset: "div",
          zIndex: "notification",
          pointerEvents: "none",
          display: triggerRef && visible ? void 0 : "none"
        }),
        ...visible ? getTooltipProps({
          ref: setTooltipRef
        }) : null,
        children: /* @__PURE__ */ jsx(TooltipContent, { opacity, arrowProps: getArrowProps(), children: tooltip })
      }
    ) })
  ] });
};
const buttonIconVariants = ["soft", "transparent"];
const buttonIconTones = ["neutral", "secondary"];
const padding = "xsmall";
const PrivateButtonIcon = forwardRef(
  ({
    icon,
    label,
    id,
    size: size2 = "standard",
    tone: tone2 = "neutral",
    variant = "soft",
    type = "button",
    bleed,
    onClick,
    onMouseDown,
    onKeyUp,
    onKeyDown,
    "aria-haspopup": ariaHasPopUp,
    "aria-expanded": ariaExpanded,
    tabIndex,
    data,
    ...restProps
  }, forwardedRef) => {
    const {
      className: buttonClasses,
      width: _,
      ...buttonStyleProps
    } = useButtonStyles({
      variant,
      tone: "neutral",
      size: "standard",
      radius: "full"
    });
    assert(
      icon.props.size === void 0,
      "Icons cannot set the 'size' prop when passed to a ButtonIcon component"
    );
    const button$1 = /* @__PURE__ */ jsxs(
      Box,
      {
        component: "button",
        type,
        id,
        zIndex: 0,
        title: !id ? label : void 0,
        ref: forwardedRef,
        "aria-label": label,
        "aria-haspopup": ariaHasPopUp,
        "aria-expanded": ariaExpanded,
        padding,
        onClick,
        onKeyUp,
        onKeyDown,
        onMouseDown,
        className: [buttonClasses, button, virtualTouchable()],
        tabIndex,
        ...buildDataAttributes({ data, validateRestProps: restProps }),
        ...buttonStyleProps,
        children: [
          /* @__PURE__ */ jsx(
            ButtonOverlays,
            {
              variant,
              tone: "neutral",
              radius: "full",
              keyboardFocusable: typeof tabIndex === "undefined" || tabIndex >= 0,
              forceActive: ariaExpanded === "true" || ariaExpanded === true
            }
          ),
          /* @__PURE__ */ jsx(
            Box,
            {
              component: "span",
              display: "block",
              position: "relative",
              className: size2 === "large" ? iconContainerSize() : iconSize({ crop: true }),
              children: cloneElement(icon, { tone: icon.props.tone || tone2, size: "fill" })
            }
          )
        ]
      }
    );
    const shouldBleed = typeof bleed === "undefined" && variant === "transparent" || bleed;
    return shouldBleed ? /* @__PURE__ */ jsx(Bleed, { space: padding, children: button$1 }) : button$1;
  }
);
const ButtonIcon = forwardRef(
  ({ id, label, ...restProps }, forwardedRef) => {
    if (!id) {
      return /* @__PURE__ */ jsx(PrivateButtonIcon, { label, ref: forwardedRef, ...restProps });
    }
    return /* @__PURE__ */ jsx(TooltipRenderer, { id: `${id}-tooltip`, tooltip: /* @__PURE__ */ jsx(Text, { children: label }), children: ({ triggerProps: { ref: triggerRef, ...triggerProps } }) => /* @__PURE__ */ jsx(
      PrivateButtonIcon,
      {
        id,
        label,
        ref: (node) => {
          if (forwardedRef) {
            if (typeof forwardedRef === "function") {
              forwardedRef(node);
            } else {
              forwardedRef.current = node;
            }
          }
          triggerRef(node);
        },
        ...triggerProps,
        ...restProps
      }
    ) });
  }
);
ButtonIcon.displayName = "ButtonIcon";
const ContentBlock = ({
  width: width2 = "medium",
  data,
  children,
  ...restProps
}) => /* @__PURE__ */ jsx(
  Box,
  {
    width: "full",
    maxWidth: width2,
    className: marginAuto,
    ...buildDataAttributes({ data, validateRestProps: restProps }),
    children
  }
);
const isPlainBackground = (backgroundContext2, contrast) => contrast === "light" && (backgroundContext2 === "body" || backgroundContext2 === "surface" || backgroundContext2 === "neutralLight") || contrast === "dark" && (backgroundContext2 === "bodyDark" || backgroundContext2 === "surfaceDark" || backgroundContext2 === "neutral");
const useLinkStyles = ({
  reset = "a",
  weight,
  showVisited = false,
  hitArea = "standard"
}) => {
  const backgroundLightness = useBackgroundLightness();
  const backgroundContext2 = useBackground();
  const textContext = useContext(TextContext);
  const headingContext = useContext(HeadingContext);
  const isWeakDueToTextTone = !headingContext && (textContext == null ? void 0 : textContext.tone) !== "neutral" && (textContext == null ? void 0 : textContext.tone) !== "secondary";
  const linkStyles = weight === "weak" || isWeakDueToTextTone ? weakLink : [
    isPlainBackground(backgroundContext2.lightMode, "light") || weight === "regular" ? regularLinkLightMode[backgroundLightness.lightMode] : weakLink,
    isPlainBackground(backgroundContext2.darkMode, "dark") || weight === "regular" ? regularLinkDarkMode[backgroundLightness.darkMode] : weakLink
  ];
  return clsx(
    base$3,
    linkStyles,
    weight !== "weak" ? fontWeight.medium : void 0,
    showVisited ? [
      visitedLightMode[backgroundLightness.lightMode],
      visitedDarkMode[backgroundLightness.darkMode]
    ] : "",
    reset !== false ? atoms({
      reset: typeof reset === "string" ? reset : "a"
    }) : null,
    atoms({
      cursor: "pointer"
    }),
    hitArea === "large" && virtualTouchable()
  );
};
const TextLinkContent = ({
  icon,
  iconPosition = "leading",
  children
}) => /* @__PURE__ */ jsxs(Fragment, { children: [
  icon && iconPosition === "leading" ? /* @__PURE__ */ jsx(AvoidWidowIcon, { iconPosition, children: icon }) : null,
  children,
  icon && iconPosition === "trailing" ? /* @__PURE__ */ jsx(AvoidWidowIcon, { iconPosition, children: icon }) : null
] });
const TextLink = forwardRef(
  ({
    weight,
    showVisited,
    hitArea,
    data,
    icon,
    children,
    iconPosition,
    ...restProps
  }, ref) => {
    const LinkComponent = useLinkComponent(ref);
    const classes = useLinkStyles({
      weight,
      showVisited,
      hitArea
    });
    return /* @__PURE__ */ jsx(
      LinkComponent,
      {
        ref,
        ...restProps,
        className: classes,
        ...buildDataAttributes({ data, validateRestProps: false }),
        children: /* @__PURE__ */ jsx(TextLinkContent, { icon, iconPosition, children })
      }
    );
  }
);
TextLink.displayName = "TextLink";
const noop = () => {
};
const TextLinkButton = ({
  weight,
  hitArea,
  id,
  onClick = noop,
  data,
  children,
  "aria-controls": ariaControls,
  "aria-expanded": ariaExpanded,
  "aria-describedby": ariaDescribedBy,
  "aria-label": ariaLabel,
  tabIndex,
  icon,
  iconPosition,
  ...restProps
}) => {
  const buttonRef = useRef(null);
  const classes = useLinkStyles({
    reset: false,
    weight,
    hitArea
  });
  const handleKeyboard = useCallback(
    (event) => {
      var _a;
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        (_a = buttonRef.current) == null ? void 0 : _a.click();
      }
    },
    [buttonRef]
  );
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref: buttonRef,
      role: "button",
      tabIndex: tabIndex ?? 0,
      component: "span",
      onClick,
      onKeyDown: handleKeyboard,
      "aria-controls": ariaControls,
      "aria-expanded": ariaExpanded,
      "aria-describedby": ariaDescribedBy,
      "aria-label": ariaLabel,
      id,
      className: classes,
      ...buildDataAttributes({ data, validateRestProps: restProps }),
      children: /* @__PURE__ */ jsx(TextLinkContent, { icon, iconPosition, children })
    }
  );
};
const useTimeout = ({ onTimeout, duration }) => {
  const [activated, setActivated] = useState(true);
  const timeoutRef = useRef();
  const stopTimeout = useCallback(() => {
    window.clearTimeout(timeoutRef.current);
    setActivated(false);
  }, []);
  useEffect(() => {
    if (activated) {
      timeoutRef.current = window.setTimeout(() => {
        onTimeout();
      }, duration);
      return () => {
        stopTimeout();
      };
    }
  }, [onTimeout, activated, duration, stopTimeout]);
  const startTimeout = useCallback(() => {
    setActivated(true);
  }, []);
  return {
    stopTimeout,
    startTimeout
  };
};
const toneToIcon = {
  critical: IconCritical,
  positive: IconPositive
};
const toastDuration = 1e4;
const borderRadius = "large";
const Action = ({ label, onClick, removeToast }) => {
  const handleClick = useCallback(() => {
    removeToast();
    onClick();
  }, [removeToast, onClick]);
  return /* @__PURE__ */ jsx(Text, { baseline: false, children: /* @__PURE__ */ jsx(Box, { component: "span", "aria-hidden": true, children: /* @__PURE__ */ jsx(TextLinkButton, { onClick: handleClick, hitArea: "large", children: label }) }) });
};
const ToastIcon = ({ tone: tone2, icon }) => {
  if (tone2 !== "neutral") {
    const Icon = toneToIcon[tone2];
    return /* @__PURE__ */ jsx(Icon, { tone: tone2 });
  }
  if (icon) {
    return cloneElement(icon, { tone: tone2 });
  }
  return null;
};
const Toast = React.forwardRef(
  ({
    id,
    vanillaTheme,
    dedupeKey,
    message,
    description,
    tone: tone2,
    icon,
    onClose,
    closeLabel = "Close",
    action,
    shouldRemove,
    data,
    ...restProps
  }, ref) => {
    const remove = useCallback(
      () => onClose(dedupeKey, id),
      [onClose, dedupeKey, id]
    );
    const { stopTimeout, startTimeout } = useTimeout({
      duration: toastDuration,
      onTimeout: remove
    });
    useEffect(() => {
      if (shouldRemove) {
        stopTimeout();
        remove();
      }
    }, [shouldRemove, remove, stopTimeout]);
    assert(
      !icon || icon.props.size === void 0 && icon.props.tone === void 0,
      "Icons cannot set the 'size' or 'tone' prop when passed to a Toast component"
    );
    assert(
      !icon || icon && tone2 === "neutral",
      `Icons cannot be customised on a Toast component using '${tone2}' tone`
    );
    const content = description ? /* @__PURE__ */ jsxs(Stack, { space: "xxsmall", children: [
      /* @__PURE__ */ jsx(Text, { weight: "medium", tone: tone2, baseline: false, children: message }),
      description ? /* @__PURE__ */ jsx(Text, { baseline: false, tone: "secondary", children: description }) : null,
      action ? /* @__PURE__ */ jsx(Action, { removeToast: remove, ...action }, action.label) : null
    ] }) : /* @__PURE__ */ jsxs(Inline, { space: "xxsmall", children: [
      /* @__PURE__ */ jsx(Box, { paddingRight: "medium", children: /* @__PURE__ */ jsx(Text, { weight: "medium", tone: tone2, baseline: false, children: message }) }),
      action ? /* @__PURE__ */ jsx(Action, { removeToast: remove, ...action }, action.label) : null
    ] });
    return /* @__PURE__ */ jsx(
      Box,
      {
        display: "flex",
        justifyContent: "center",
        role: "alert",
        ref,
        onMouseEnter: stopTimeout,
        onMouseLeave: startTimeout,
        className: vanillaTheme,
        ...buildDataAttributes({ data, validateRestProps: restProps }),
        children: /* @__PURE__ */ jsx(Box, { boxShadow: "large", borderRadius, children: /* @__PURE__ */ jsx(ContentBlock, { width: "xsmall", children: /* @__PURE__ */ jsx(
          Box,
          {
            background: { lightMode: "surfaceDark", darkMode: "surface" },
            position: "relative",
            borderRadius,
            paddingY: "medium",
            paddingX: "gutter",
            overflow: "hidden",
            className: toast,
            children: /* @__PURE__ */ jsxs(Columns, { space: "none", children: [
              tone2 !== "neutral" || tone2 === "neutral" && icon ? /* @__PURE__ */ jsx(Column, { width: "content", children: /* @__PURE__ */ jsx(Box, { paddingRight: "small", children: /* @__PURE__ */ jsx(ToastIcon, { tone: tone2, icon }) }) }) : null,
              /* @__PURE__ */ jsx(Column, { children: content }),
              /* @__PURE__ */ jsx(Column, { width: "content", children: /* @__PURE__ */ jsx(
                Box,
                {
                  width: "touchable",
                  display: "flex",
                  justifyContent: "flexEnd",
                  alignItems: "center",
                  className: lineHeightContainer.standard,
                  "aria-hidden": true,
                  children: /* @__PURE__ */ jsx(
                    ButtonIcon,
                    {
                      id: `${dedupeKey}-clear`,
                      icon: /* @__PURE__ */ jsx(IconClear, {}),
                      tone: "secondary",
                      variant: "transparent",
                      onClick: remove,
                      label: closeLabel,
                      data: process.env.NODE_ENV !== "production" ? { testid: "clearToast" } : {}
                    }
                  )
                }
              ) })
            ] })
          }
        ) }) })
      }
    );
  }
);
const ToastComponent = Toast;
const animationTimeout = 300;
const entranceTransition = "transform 0.2s ease, opacity 0.2s ease";
const exitTransition = "opacity 0.1s ease";
const animate = (element, transforms, transition, done) => {
  const fallbackTimeout = setTimeout(() => {
    if (done) {
      done();
    }
  }, animationTimeout);
  transforms.forEach(({ property, from = "" }) => {
    element.style.setProperty(property, from);
  });
  element.style.setProperty("transition", "");
  const transitionEndHandler = (ev) => {
    if (ev.target !== element) {
      return;
    }
    element.style.setProperty("transition", "");
    if (done) {
      done();
    }
    element.removeEventListener("transitionend", transitionEndHandler);
    clearTimeout(fallbackTimeout);
  };
  element.addEventListener("transitionend", transitionEndHandler);
  window.requestAnimationFrame(() => {
    window.requestAnimationFrame(() => {
      element.style.setProperty("transition", transition);
      transforms.forEach(({ property, to = "" }) => {
        element.style.setProperty(property, to);
      });
    });
  });
};
const useFlipList = () => {
  const refs = useMemo(() => /* @__PURE__ */ new Map(), []);
  const positions = useMemo(() => /* @__PURE__ */ new Map(), []);
  useLayoutEffect(() => {
    const animations = [];
    Array.from(refs.entries()).forEach(([id, element]) => {
      if (element) {
        const prevTop = positions.get(id);
        const { top: top2, height } = element.getBoundingClientRect();
        if (typeof prevTop === "number" && prevTop !== top2) {
          animations.push({
            element,
            transition: entranceTransition,
            transforms: [
              {
                property: "transform",
                from: `translateY(${prevTop - top2}px)`
              }
            ]
          });
        } else if (typeof prevTop !== "number") {
          animations.push({
            element,
            transition: entranceTransition,
            transforms: [
              {
                property: "transform",
                from: `translateY(${height}px)`
              },
              {
                property: "opacity",
                from: "0"
              }
            ]
          });
        }
        positions.set(id, element.getBoundingClientRect().top);
      } else {
        refs.delete(id);
      }
    });
    animations.forEach(({ element, transforms, transition }) => {
      animate(element, transforms, transition);
    });
  });
  const remove = useCallback(
    (id, cb) => {
      const element = refs.get(id);
      if (element) {
        animate(
          element,
          [
            {
              property: "opacity",
              to: "0"
            }
          ],
          exitTransition,
          cb
        );
      }
    },
    [refs]
  );
  const itemRef = useCallback(
    (id) => (ref) => {
      refs.set(id, ref);
    },
    [refs]
  );
  return {
    itemRef,
    remove
  };
};
const Toaster = ({ toasts, removeToast }) => {
  const { itemRef, remove } = useFlipList();
  const onClose = useCallback(
    (dedupeKey, id) => {
      remove(id, () => {
        removeToast(dedupeKey);
      });
    },
    [remove, removeToast]
  );
  return /* @__PURE__ */ jsx(
    Box,
    {
      position: "fixed",
      zIndex: "notification",
      width: "full",
      pointerEvents: "none",
      paddingX: "gutter",
      bottom: 0,
      children: toasts.map(({ id, ...rest }) => /* @__PURE__ */ jsx(Box, { paddingBottom: "small", children: /* @__PURE__ */ jsx(
        ToastComponent,
        {
          ref: itemRef(id),
          id,
          onClose,
          ...rest
        }
      ) }, id))
    }
  );
};
let toastCounter = 0;
const ToastControllerContext = createContext(null);
const QUEUE_TOAST = 0;
const REMOVE_TOAST = 1;
function reducer(state, action) {
  switch (action.type) {
    case QUEUE_TOAST: {
      const { toast: toast2 } = action;
      const hasExistingToast = state.toasts.some(
        (t) => t.dedupeKey === toast2.dedupeKey
      );
      if (hasExistingToast) {
        return {
          toasts: state.toasts.map((t) => {
            if (t.dedupeKey === toast2.dedupeKey) {
              return {
                ...t,
                shouldRemove: true
              };
            }
            return t;
          }),
          queuedToasts: {
            ...state.queuedToasts,
            [toast2.dedupeKey]: toast2
          }
        };
      }
      return {
        ...state,
        toasts: [...state.toasts, action.toast]
      };
    }
    case REMOVE_TOAST: {
      const toasts = state.toasts.filter(
        ({ dedupeKey }) => dedupeKey !== action.dedupeKey
      );
      const queuedToast = state.queuedToasts[action.dedupeKey];
      if (queuedToast) {
        return {
          queuedToasts: {
            ...state.queuedToasts,
            [action.dedupeKey]: void 0
          },
          toasts: [...toasts, queuedToast]
        };
      }
      return {
        ...state,
        toasts
      };
    }
  }
}
const InternalToastProvider = ({ children }) => {
  const [{ toasts }, dispatch] = useReducer(reducer, {
    toasts: [],
    queuedToasts: {}
  });
  const addToast = useCallback(
    (toast2) => dispatch({ type: QUEUE_TOAST, toast: toast2 }),
    []
  );
  const removeToast = useCallback(
    (dedupeKey) => dispatch({ type: REMOVE_TOAST, dedupeKey }),
    []
  );
  return /* @__PURE__ */ jsxs(ToastControllerContext.Provider, { value: addToast, children: [
    children,
    /* @__PURE__ */ jsx(ToastPortal, { children: /* @__PURE__ */ jsx(Toaster, { toasts, removeToast }) })
  ] });
};
const ToastProvider = ({ children }) => {
  const currentContext = useContext(ToastControllerContext);
  if (currentContext !== null) {
    return /* @__PURE__ */ jsx(Fragment$1, { children });
  }
  return /* @__PURE__ */ jsx(InternalToastProvider, { children });
};
const ToastPortal = ({ children }) => {
  const [toastElement, setElement] = useState(null);
  useEffect(() => {
    const toastContainerId = "braid-toast-container";
    let element = document.getElementById(toastContainerId);
    if (!element) {
      element = document.createElement("div");
      element.setAttribute("id", toastContainerId);
      element.setAttribute("class", "");
      document.body.appendChild(element);
    }
    setElement(element);
  }, []);
  if (!toastElement) {
    return null;
  }
  return /* @__PURE__ */ jsx(BraidPortal, { container: toastElement, children });
};
const useToast = () => {
  const { vanillaTheme } = useBraidTheme();
  const addToast = useContext(ToastControllerContext);
  if (addToast === null) {
    throw new Error('No "ToastProvider" configured');
  }
  return useCallback(
    (toast2) => {
      const id = `${toastCounter++}`;
      const dedupeKey = toast2.key ?? id;
      addToast({
        ...toast2,
        vanillaTheme,
        id,
        dedupeKey,
        shouldRemove: false
      });
    },
    [vanillaTheme, addToast]
  );
};
export {
  ActionsContext,
  AvoidWidowIcon,
  BackgroundProvider,
  Bleed,
  Box,
  BraidPortal,
  Button,
  ButtonContainer,
  ButtonIcon,
  ButtonOverlays,
  ButtonText,
  Column,
  Columns,
  ContentBlock,
  DefaultTextPropsProvider,
  Divider,
  FieldOverlay,
  HeadingContext,
  Hidden,
  IconClear,
  IconCritical,
  IconPositive,
  IconRenderer,
  Inline,
  Overlay,
  PublicBox,
  Stack,
  Text,
  TextContext,
  TextLink,
  TextLinkButton,
  ToastProvider,
  TooltipRenderer,
  Typography,
  buildDataAttributes,
  buttonIconTones,
  buttonIconVariants,
  buttonTones,
  buttonVariants,
  flattenChildren,
  iconContainerSize,
  iconSize,
  negativeMargin,
  optimizeResponsiveArray,
  resolveResponsiveProp,
  resolveResponsiveRangeProps,
  textStyles,
  useBackground,
  useBackgroundLightness,
  useButtonStyles,
  useColoredBoxClasses,
  useDefaultTextProps,
  useIcon,
  useResponsiveValue,
  useSpace,
  useThemeName,
  useToast,
  validBleedComponents,
  validColumnsComponents,
  validInlineComponents,
  validStackComponents,
  virtualTouchable
};
